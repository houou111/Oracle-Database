================== mysqlmonitor
  ALTER SESSION SET "_with_subquery"=INLINE; 
 WITH    active_sess AS (SELECT service_name,s.inst_id i#, s.username, s.sid, s.command, s.SID || ',' || s.serial# || ',@' || s.inst_id AS sid_ser#,  
DECODE (S.WAIT_TIME, 0, S.EVENT, 'CPU') ACTION, s.sql_id, TO_CHAR (ROUND ((SYSDATE - SQL_EXEC_START) * 86400)) sql_ela, 
CASE WHEN last_call_et > 60 THEN TRIM (TO_CHAR (FLOOR (last_call_et / 60))) || ':' || TRIM (TO_CHAR (MOD (last_call_et, 60), '00')) ELSE TO_CHAR (last_call_et) END elapse, 
s.SQL_HASH_VALUE plan_hash, s.module, s.osuser, s.machine, blocking_session || '@' || blocking_instance blk_sid,  
S.STATUS, PLSQL_ENTRY_OBJECT_ID, PLSQL_ENTRY_SUBPROGRAM_ID, CLIENT_INFO||'-'||CLIENT_IDENTIFIER client_id_info, s.p1text, S.P1, s.p2text, S.P2, s.p3text, S.P3 FROM GV$SESSION S 
WHERE S.STATUS NOT IN ('INACTIVE', 'SNIPED') AND (s.TYPE <> 'BACKGROUND' or s.username IS NOT NULL) and (program NOT LIKE '%(O0%' or program is  null) and ( not (PROGRAM like '%(J0%' and event like 'jobq slave wait')) ) 
SELECT service_name,sid_ser#,USERNAME, s.ACTION, SQL_ELA, ELAPSE, s.SQL_ID, 
 SUBSTR (DECODE (SS.SQL_TEXT, NULL, AA.NAME, SS.SQL_TEXT), 1, 100) SQLTEXT, MODULE, OSUSER, MACHINE, BLK_SID, STATUS, 
PLAN_HASH, PLSQL_ENTRY_OBJECT_ID, PLSQL_ENTRY_SUBPROGRAM_ID, client_id_info, P1TEXT, P1, P2TEXT, P2, P3TEXT, P3, 
'alter system kill session ''' || SID_SER# || ''' immediate;' kill_sess FROM active_sess s, V$SQLSTATS  ss, AUDIT_ACTIONS AA 
WHERE 1 = 1 /*s.i#=ss.inst_id*/ AND AA.ACTION(+) = S.COMMAND AND ss.sql_id(+) = s.sql_id AND i# || '#' || sid NOT IN (SELECT i# || '#' || sid 
 FROM active_sess WHERE sql_id = (SELECT sql_id FROM active_sess WHERE i# || '#' || sid = SYS_CONTEXT ('USERENV', 'INSTANCE') || '#' || SYS_CONTEXT ('USERENV', 'SID'))) 
 and s.status not in ('KILLED') 
 and s.username not in ('C##GGADM') 
 ORDER BY username, sqltext, sql_id, machine, i#; 

 SELECT /* SQL monitor */ dbms_sqltune.report_sql_monitor (sql_id=>'0540z6guyyh8r', event_detail=>'YES', report_level=>'ALL') from dual;  

SELECT sql_fulltext,plan_hash_value,sql_patch, sql_plan_baseline,sql_profile,last_load_time,last_active_time,SQL_ID,EXECUTIONS,ELAPSED_TIME/1000/1000,CPU_TIME,ELAPSED_TIME/1000/1000/EXECUTIONS average_time FROM 
gV$SQL WHERE SQL_ID='48wx9u1u5cmxf' order by last_active_time desc; 

 select a.instance_number inst_id, a.snap_id,a.plan_hash_value, to_char(begin_interval_time,'dd-mon-yy hh24:mi') btime,  
abs(extract(minute from (end_interval_time-begin_interval_time)) + extract(hour from (end_interval_time-begin_interval_time))*60 + extract(day from (end_interval_time-begin_interval_time))*24*60) minutes,
executions_delta executions, round(ELAPSED_TIME_delta/1000000/greatest(executions_delta,1),4) avg_duration_sec from dba_hist_SQLSTAT a, dba_hist_snapshot b
where sql_id='bu374zwsm906z' and a.snap_id=b.snap_id and a.instance_number=b.instance_number order by snap_id desc, a.instance_number; 

SELECT * FROM TABLE(DBMS_XPLAN.display_cursor(sql_id=>'aaxqm7nf8nhtd', format=>'ADVANCED +OUTLINE +NOTE')); 
SELECT * FROM TABLE(DBMS_XPLAN.display_cursor(sql_id=>'58wtttk8cy3z5', format=>'ADVANCED +OUTLINE +NOTE')); 
SELECT * FROM TABLE(DBMS_XPLAN.display_cursor(sql_id=>'58wtttk8cy3z5',cursor_child_no => 1, format=>'ADVANCED +OUTLINE +NOTE')); 
select * from table(dbms_xplan.display_awr('4nzhk5pfmv2nw','2868752829','','ADVANCED +OUTLINE +NOTE')); 

select SQL_EXEC_START, session_state, event, count(*)*10 secs_in_state FROM dba_hist_active_sess_history where sql_id='48wx9u1u5cmxf'
    group by sql_exec_start, session_state, event order by 1,4 desc;
	
select sysdate, a.user_id,last_active_time, a.sql_id, plan_hash_value, round(elapsed_time/executions/1000,2) duration, a.machine, a.inst_id,a.inst_id, b.EXECUTIONS,b.ELAPSED_TIME,b.APPLICATION_WAIT_TIME,b.CONCURRENCY_WAIT_TIME, c.username,sql_text
from (
select distinct user_id, sql_id, machine,inst_id from gv$active_session_history
where sample_time > sysdate -15/24/60
and sql_id is not null) a
left join ( select sql_id,last_active_time,EXECUTIONS,ELAPSED_TIME,APPLICATION_WAIT_TIME,CONCURRENCY_WAIT_TIME, inst_id, sql_text, plan_hash_value
from gv$sqlstats
where last_active_time > sysdate -15/24/60
-- and last_active_time < to_date('20210817 10:20','yyyymmdd hh24:mi')
) b on a.sql_id=b.sql_id and a.inst_id=b.inst_id
left join dba_users c on a.user_id=c.user_id
-- where c.username='DBSNMP' and
where c.username='GCM_AGCM_VIET_MBTT_RET' and
-- where c.username='GCM_AGCM_VIETNAM_MBTT' and
executions >0
order by elapsed_time/executions/1000 desc
;

ALTER TABLE T24RPT.MB_TR_FT SPLIT PARTITION P20220625 INTO 
  (PARTITION P20220625 VALUES LESS THAN (25),
   PARTITION P20220626 VALUES LESS THAN (50), 
   PARTITION P20220627 VALUES LESS THAN (75),
   PARTITION P20220628
   );
============= fast split
truoc tien fai gather
ALTER TABLE T24RPT.MB_TR_FT SPLIT PARTITION P20220624 AT (TO_DATE ('2022-06-25 00:00:00', 'YYYY-MM-DD hh24:mi:ss')) INTO (PARTITION P20220624 TABLESPACE DATAFAST, PARTITION P20220625 TABLESPACE DATAFAST) PARALLEL ( DEGREE 16 );
select FILE_ID,EXTENT_ID,BLOCK_ID,PARTITION_NAME from dba_extents where segment_NAME='DOC' and owner ='WAY4RPT';
select * from dba_tab_partitions where table_name='DOC' and table_owner ='WAY4RPT';

oracle se dua vao 2 cau nay de xac dinh co fast split hay ko
select /*+ FIRST_ROWS(1) PARALLEL("DOC", 1) */ 1 from "WAY4RPT"."DOC" PARTITION ("PART_FUTURE")  where ( (  (  ( "TRANS_DATE" < TO_DATE(' 2020-08-20 00:00:00', 'SYYYY-MM-DD HH24:MI:SS', 'NLS_CALENDAR=GREGORIAN') )  )  ) ) and rownum < 2;
select /*+ FIRST_ROWS(1) PARALLEL("DOC", 1) */ a.* from "WAY4RPT"."DOC" PARTITION ("PART_FUTURE") a where ( (  (  ( "TRANS_DATE" >= TO_DATE(' 2020-08-20 00:00:00', 'SYYYY-MM-DD HH24:MI:SS', 'NLS_CALENDAR=GREGORIAN') OR "TRANS_DATE" IS NULL  )  )  ) ) and rownum < 2;

==> xuat hien dong thu 2 la ok roi, neen chay song song cho no access full  bang
============= chu y partition index: gia su partition index (CUS_CODE) co invalid partition thang 7/2020 = thang hien tai
SELECT NVL (MAX (A.BOOKING_DATE), NULL)   FROM APPS.MB_TR_SOPHU A
 WHERE     A.cus_code = '5309907'
       AND A.BOOKING_DATE >= trunc(sysdate)-100
       AND A.BOOKING_DATE <= trunc(sysdate)-40
--> Nhu nay se ko an index (CUS_CODE), se an index (BOOKING_DATE) or full partition scan 
--> Mac du ko co unusable partition index (CUS_CODE) trong khoang thoi gian BOOKING_DATE query.

SELECT NVL (MAX (A.BOOKING_DATE), NULL)   FROM APPS.MB_TR_SOPHU A
 WHERE     A.cus_code = '5309907'
       AND A.BOOKING_DATE between to_date('2019-06-01','YYYY-MM-DD') 
       AND to_date('2020-06-01','YYYY-MM-DD') 
--> Nhu nay thi lai an index (CUS_CODE) ok.	 

SELECT NVL (MAX (A.BOOKING_DATE), NULL)   FROM APPS.MB_TR_SOPHU A
 WHERE     A.cus_code = '5309907'
       AND A.BOOKING_DATE between to_date('2019-06-01','YYYY-MM-DD') 
       AND to_date('2020-07-01','YYYY-MM-DD')
-> Nhu nay thi lai chi an index BOOKING_DATE, mac du cau query chi dinh co 1 ngay trong unusable index CUS_CODE.	   
==============indexing ON OFF
--Elapsed: 00:00:18.98
BEGIN
    FOR aPart IN (SELECT PARTITION_NAME FROM dba_tab_partitions WHERE TABLE_NAME = 'MB_TR_SOPHU') LOOP
        EXECUTE IMMEDIATE 'ALTER TABLE T24RPT.MB_TR_SOPHU MODIFY PARTITION '||aPart.PARTITION_NAME||' INDEXING OFF';
    END LOOP;   
END;
/

-- ktra lai
SELECT table_name, partition_name, num_rows, indexing
FROM dba_tab_partitions
WHERE table_name = 'MB_TR_SOPHU'
ORDER BY partition_name;

--
--Elapsed: 00:00:00.47 cac index deu la unusable 
-- create index T24RPT.MB_TR_SOPHU$ACCOUNT_NUMBER on T24RPT.MB_TR_SOPHU(ACCOUNT_NUMBER) TABLESPACE INDEXFAST  LOCAL INDEXING PARTIAL;
create index T24RPT.MB_TR_SOPHU$CUS_CODE on T24RPT.MB_TR_SOPHU(CUS_CODE) tablespace indexfast LOCAL  INDEXING PARTIAL;
SELECT index_name,
       partition_name,
       status
FROM   dba_ind_partitions
where index_name='MB_TR_SOPHU$CUS_CODE'
ORDER BY 1,2;

-- Elapsed: 00:09:40.69 cho 1  partition rebuild online
--Elapsed: 00:01:55.12 cho 1 partition rebuild ko online
vi script.sql
BEGIN
    FOR aPart IN (SELECT PARTITION_NAME FROM dba_ind_partitions WHERE index_name = 'MB_TR_SOPHU$CUS_CODE') LOOP
        EXECUTE IMMEDIATE 'ALTER INDEX T24RPT.MB_TR_SOPHU$CUS_CODE REBUILD PARTITION '||aPart .PARTITION_NAME||' PARALLEL 10 ';
    END LOOP;   
END;
/
--ALTER INDEX T24RPT.MB_TR_SOPHU$ACCOUNT_NUMBER REBUILD PARTITION SYS_P136078 PARALLEL 16 ;

nohup sqlplus "/ as sysdba" @script.sql > script.out 2>&1 &
nohup sqlplus "/ as sysdba" @script1.sql > script1.out 2>&1 &
nohup sqlplus "/ as sysdba" @gather2.sql > gather2.out 2>&1 &

nohup sqlplus "/ as sysdba" @gather.sql > gather.out 2>&1 &

---00:00:24.54  Elapsed: 00:00:36.11
BEGIN
    FOR aPart IN (SELECT PARTITION_NAME FROM dba_tab_partitions WHERE TABLE_NAME = 'MB_TR_SOPHU') LOOP
        EXECUTE IMMEDIATE 'ALTER TABLE T24RPT.MB_TR_SOPHU MODIFY PARTITION '||aPart.PARTITION_NAME||' INDEXING ON';
    END LOOP;   
END;
/


-- Enable indexing, otherwise new partitions will not get indexed.
ALTER TABLE T24RPT.MB_TR_SOPHU MODIFY DEFAULT ATTRIBUTES INDEXING ON; 

======================== change primary key
(ID,TRANS_DATE)
  USING INDEX WAY4RPT.PK_DOC
  
ALTER TABLE GCM_AGCM_VIETNAM_MBTT.APIGW_TRANSACTION_LOG
DROP CONSTRAINT PK_DOC1;

select status from dba_indexes where index_name='PK_DOC';
ALTER TABLE GCM_AGCM_VIETNAM_MBTT.APIGW_TRANSACTION_LOG ADD (
  CONSTRAINT APIGW_TRANSACTION_LOG_PK
  PRIMARY KEY
  (ID,TRANS_DATE)
  USING INDEX GCM_AGCM_VIETNAM_MBTT.APIGW_TRANSACTION_LOG_PK
  ENABLE NOVALIDATE);
  
  ALTER SESSION FORCE PARALLEL DDL PARALLEL 8;

ALTER TABLE GCM_AGCM_VIETNAM_MBTT.APIGW_TRANSACTION_LOG
    ENABLE CONSTRAINT   APIGW_TRANSACTION_LOG_PK;
=============== chungtc hash chia luong song song ================
where ( (MOD(ORA_HASH(APIGW_TRANSACTION_LOG.ROWID), 2) = 0)) AND (  CREATE_DATE >= TO_TIMESTAMP('2021-11-19 19:48:25','YYYY-MM-DD hh24:mi:ss') - interval '1' hour)	
WHERE ( (MOD(ORA_HASH(E.ROWID), 6) = 5))

        AND MOD (DBMS_ROWID.ROWID_BLOCK_NUMBER(ACNT_CONTRACT.ROWID), :B3 ) = :B2
AND MOD(DBMS_ROWID.ROWID_BLOCK_NUMBER(OCC.ROWID),20)+1=10

============== tungnt16
UPDATE ACFBNK_ACCO018 t SET t.xmlrecord = PK_UPDATE_ACC_HIS.SP_CONVERT(t.rowid,t.xmlrecord) WHERE rowid BETWEEN :start_id AND :end_id
		
===========================================================================
------way4 --PROCESS_LOG__OID   --DOC__ID
----- index composite thi  selective column duoc uu tien (uu tien truong duoc access, roi cac truong phu), compress thi de default cung ok nhat
create index AMLMCOB.GWGKUNDE$HISTBIS_INSTITUTSNR on AMLMCOB.GWGKUNDE("HISTBIS","INSTITUTSNR") TABLESPACE AMLTAB  parallel 8 online;
create bitmap index AMLMCOB.GWGKUNDE$HISTBIS on AMLMCOB.GWGKUNDE("HISTBIS") TABLESPACE AMLTAB  online;
create bitmap index AMLMCOB.GWGTRANS$BUCHDAT on AMLMCOB.GWGTRANS("BUCHDAT") TABLESPACE AMLTAB  online;
create index msb.entry$new1 on msb.entry(ITEM__ID  ,ID,AMOUNT,FEE_AMOUNT ,POSTING_DATE ) COMPRESS ADVANCED LOW  compute statistics 
create index CRM1.RM_TINDUNGTD_MONTH$BCODE_KHOI on CRM1.RM_TINDUNGTD_MONTHLY(BRANCH_CODE  ,KHOI ) COMPRESS 1 TABLESPACE INDEXS  parallel 8 online compute statistics ;

CREATE INDEX MSB.DOC_TARGET_NUMBER_POSTING_DATE_I ON MSB.DOC
(TARGET_NUMBER, POSTING_DATE)
  TABLESPACE OWDOC_I
  PCTFREE    10
  INITRANS   2
  MAXTRANS   255
  STORAGE    (
              BUFFER_POOL      DEFAULT
              FLASH_CACHE      DEFAULT
              CELL_FLASH_CACHE DEFAULT
             )
GLOBAL PARTITION BY HASH (TARGET_NUMBER) 
PARTITIONS 256;

create index AMLMCOB.PRESULT$NEW on AMLMCOB.PRESULT(ANWEND_KZ,HISTBIS,STATUS,INSTITUTSNR) TABLESPACE AMLTAB  parallel 8 online;
"A0"."ANWEND_KZ"=:1 AND "A0"."HISTBIS"=U'9999' AND "A0"."STATUS"=:2 AND "A0"."INSTITUTSNR"=:3
exec for c in (select address,hash_value,users_executing,sql_text from v$sqlarea where sql_id='angjwnm1wckgt') loop sys.dbms_shared_pool.purge(c.address||','||c.hash_value,'...'); end loop;
execute dbms_stats.gather_table_stats(ownname => 'T24CORE', tabname =>'ARC_AZF_ASSET_CLASS_XHTD', estimate_percent =>DBMS_STATS.AUTO_SAMPLE_SIZE, method_opt => 'FOR ALL COLUMNS SIZE skewonly', cascade => TRUE,degree => 32,no_invalidate => false);
execute dbms_stats.gather_table_stats(ownname => 'AMLMCOB', tabname =>'PRESULT', estimate_percent =>DBMS_STATS.AUTO_SAMPLE_SIZE, method_opt => 'FOR COLUMNS SIZE 3 SYS_STSYJAZCFMUKX#LJ#ZIV1K91II', cascade => TRUE,degree => 8,no_invalidate => false);
	 execute dbms_stats.gather_index_stats(ownname => 'AMLMCOB', indname =>'PRESULT$NEW', estimate_percent =>100,no_invalidate => false);

SELECT DBMS_STATS.create_extended_stats('AMLMCOB', 'PRESULT','(ANWEND_KZ,HISTBIS,STATUS,INSTITUTSNR)') FROM   dual;
Gather_table_stats('SH', 'SALES', - method_opt => 'FOR ALL COLUMNS SIZE 1 FOR COLUMNS SIZE 254 CUST_ID'); 

f90ssjhb4btbb = ghhxht6xdn9ku
/*+
      BEGIN_OUTLINE_DATA
      IGNORE_OPTIM_EMBEDDED_HINTS
      OPTIMIZER_FEATURES_ENABLE('12.1.0.2')
      DB_VERSION('12.1.0.2')
      ALL_ROWS
      OUTLINE_LEAF(@"SEL$8BB11450")
      OUTER_JOIN_TO_INNER(@"SEL$63F05DA2" "A1"@"SEL$1")
      OUTLINE(@"SEL$63F05DA2")
      MERGE(@"SEL$66B15841")
      OUTLINE(@"SEL$41465E65")
      ANSI_REARCH(@"SEL$3")
      OUTLINE(@"SEL$66B15841")
      MERGE(@"SEL$8812AA4E")
      OUTLINE(@"SEL$3")
      OUTLINE(@"SEL$10B37F33")
      ANSI_REARCH(@"SEL$948754D7")
      OUTLINE(@"SEL$8812AA4E")
      ANSI_REARCH(@"SEL$1")
      OUTLINE(@"SEL$948754D7")
      ANSI_REARCH(@"SEL$2")
      OUTLINE(@"SEL$1")
      OUTLINE(@"SEL$2")
      INDEX(@"SEL$8BB11450" "A0"@"SEL$1" ("PRESULT"."ANWEND_KZ" "PRESULT"."HISTBIS" "PRESULT"."STATUS" "PRESULT"."INSTITUTSNR" "PRESULT"."KUNDNR"))
      BITMAP_TREE(@"SEL$8BB11450" "A1"@"SEL$1" AND(("GWGKUNDE"."HISTBIS") ("GWGKUNDE"."INSTITUTSNR" "GWGKUNDE"."KUNDNR" "GWGKUNDE"."HISTVON" "GWGKUNDE"."HISTBIS"
              "GWGKUNDE"."FK_BETRNR")))
      BATCH_TABLE_ACCESS_BY_ROWID(@"SEL$8BB11450" "A1"@"SEL$1")
      INDEX_RS_ASC(@"SEL$8BB11450" "A2"@"SEL$2" ("KYCCUST"."INSTITUTSNR" "KYCCUST"."KUNDNR" "KYCCUST"."HISTBIS"))
      LEADING(@"SEL$8BB11450" "A0"@"SEL$1" "A1"@"SEL$1" "A2"@"SEL$2")
      USE_NL(@"SEL$8BB11450" "A1"@"SEL$1")
      USE_NL(@"SEL$8BB11450" "A2"@"SEL$2")
      END_OUTLINE_DATA
  */
  
select dbms_sqltune.report_tuning_task('ghhxht6xdn9ku') from dual;
 EXEC DBMS_SQLTUNE.execute_tuning_task(task_name => 'f90ssjhb4btbb'); 
 dvzp8rth933av

CREATE INDEX AMLMCOB.GWGKUNDE_FKBETRNR0 ON AMLMCOB.GWGKUNDE
(INSTITUTSNR, FK_BETRNR, HISTBIS)
LOGGING
TABLESPACE AMLIDX
PCTFREE    10
INITRANS   2
MAXTRANS   255
STORAGE    (
            INITIAL          64K
            NEXT             1M
            MAXSIZE          UNLIMITED
            MINEXTENTS       1
            MAXEXTENTS       UNLIMITED
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
            FLASH_CACHE      DEFAULT
            CELL_FLASH_CACHE DEFAULT
           )
PARALLEL ( DEGREE 8 INSTANCES 1 );


select * from acnt_contract acnt where last_billing_date=to_date('12/26/2019','mm/dd/yyyy') 
and acnt.con_cat = 'A'
    /*Update for VISA*/
        AND (acnt.contract_number LIKE '%-M-%' OR acnt.contract_number LIKE '%-V-%')
        AND acnt.pcat = 'C'
        AND acnt.ccat = 'P'
        and last_scan <>to_date('12/26/2019','mm/dd/yyyy')

select count(*) from acnt_contract acnt where 
 acnt.con_cat = 'A'
    /*Update for VISA*/
        AND (acnt.contract_number LIKE '%-M-%' OR acnt.contract_number LIKE '%-V-%')
        AND acnt.pcat = 'C'
        AND acnt.ccat = 'P'
                and last_scan =to_date('12/26/2019','mm/dd/yyyy');		 --140881
EXTERNALGW  khong co thong tin pass
FEEDN	FXDLING  GWWEB  HCMCITAD HOSIMAGES chua dien owner
[‎08/‎11/‎2019 3:47 CH] Vinh Nguyen Trong (CN-VHCN QTHT): 
alter user dbsnmp identified by msbdbsnmp123 ACCOUNT_MASK unlock;
alter user dbsnmp ACCOUNT_MASK unlock; 
quangtn1
Msb#1234
hoang.nh@svtech.com.vn/Qwer!234
hieunt@atnavn.com/120tranbinH
chungtc2@msb.com.vn Nothing2143
flashback data archive
1. Increase per process memlock (soft) limit to at least 60GB
 to lock 100% of SHARED GLOBAL AREA (SGA) pages into physical memory
2

=============== transportable tablespace ===================================
https://support.oracle.com/epmos/faces/DocumentDisplay?_afrLoop=348204103500238&id=2005729.1&_afrWindowMode=0&_adf.ctrl-state=idlbhkf13_21
================display X11 AIX 
cat /etc/ssh/sshd_config
X11Forwarding yes 
X11DisplayOffset 10
X11UseLocalhost yes
========= hung mb cai grid AIX=============== smitty iocp
https://docs.oracle.com/en/database/oracle/oracle-database/12.2/axdbi/enabling-io-completion-ports.html#GUID-9907E8AC-A260-4369-8BF6-EE5BED434FD2

======= Hung MB ==================
-- kiem tra co bi drop goi UDP hay ko, lien quan toi RAC
[root@dcr16db01:/]# netstat -p udp
udp:
        3752748065 datagrams received
        0 incomplete headers
        2117 bad data length fields
        4662 bad checksums
        3441777 dropped due to no socket  --------------------------------------drop nay
        918714 broadcast/multicast datagrams dropped due to no socket
        2224668 socket buffer overflows
        3746156127 delivered
        2555798833 datagrams output
[root@dcr16db01:/]# no -o udp_recvspace  ------------- tham so hien tai
udp_recvspace = 655360
-- dat udp_recvspace lon hon ket qua duoi
netstat -M | sort -n -k 4 | tail -3
16384         128 460907332  2030891      128          920 F1000E000292A600
          2048         512 1035246933  3722745      511         2115 F1000E00097B7400
          2048         514 18446744071792041864  4249902----con so day      512         2339 F1000E0003255400
[root@dc
====================OS watcher ======================================== https://support.oracle.com/epmos/faces/DocumentDisplay?_afrLoop=348210239702427&id=461053.1&_afrWindowMode=0&_adf.ctrl-state=idlbhkf13_70#Using%20OSWg:%20Menu%20Option
dung user grid, tao 1 thu muc co thuoc owner grid roi lam
tar xvf oswbb.tar
./startOSWbb.sh &

1. Thực hiện lấy thông tin đường dẫn archive và đường dẫn của tool OSW
ps -ef|grep OS
  oracle 18678056 24380146   0 10:31:07  pts/3  0:00 grep OSW
    grid 38994202        1   0   Mar 06      - 18:03 /bin/sh ./OSWatcher.sh 30 48 NONE /u01/app/oracle.ahf/data/repository/suptools/carddb01/oswbb/grid/archive
    grid 22610632 38994202   0   Mar 06      -  8:32 /bin/sh ./OSWatcherFM.sh 48 /u01/app/oracle.ahf/data/repository/suptools/carddb01/oswbb/grid/archive

=> Đường dẫn archive: /u01/app/oracle.ahf/data/repository/suptools/carddb01/oswbb/grid/archive
=> Đường dẫn của tool OSW: /u01/app/oracle.ahf/data/repository/suptools/carddb01/oswbb/grid/oswbb

2. Thực hiện analyze dữ liệu OSW (Dùng user root) , java nho dung ban cao (1.8 tro len ) 
cd /u01/app/oracle.ahf/data/repository/suptools/carddb01/oswbb/grid/oswbb
 cd /oracle/app/gridbase/oracle.ahf/data/repository/suptools/dr-r20db02/oswbb/grid/oswbb
 /oracle/app/gridbase/tfa/repository/suptools/dr-r20db01/oswbb/grid/oswbb/
# java -jar oswbba.jar -i /oracle/app/oracle.ahf/data/repository/suptools/test-db01/oswbb/grid/archive
-- chon option
/usr/java8_64/jre/bin/java -jar oswbba.jar -i /u01/app/oracle.ahf/data/repository/suptools/carddb01/oswbb/grid/archive -b May 02 15:01:00 2020 -e May 02 17:59:00 2020
/usr/java8_64/jre/bin/java -jar oswbba.jar -i /oracle/app/gridbase/oracle.ahf/data/repository/suptools/t24vn-db01/oswbb/grid/archive  -b Nov 02 15:00:00 2022 -e Nov 0 16:00:00 2022
--
/usr/java8_64/jre/bin/java -jar oswbba.jar -i /u01/app/oracle.ahf/data/repository/suptools/carddb01/oswbb/grid/archive -b May 05 00:01:00 2020 -e May 05 00:59:00 2020  -GC

/usr/java8_64/jre/bin/java -jar oswbba.jar -i /u01/app/oracle.ahf/data/repository/suptools/carddb01/oswbb/grid/archive -b May 05 00:01:00 2020 -e May 05 23:59:00 2020 -A

/usr/java8_64/jre/bin/java -jar oswbba.jar -i /u01/app/oracle.ahf/data/repository/suptools/carddb01/oswbb/grid/archive -b May 05 00:01:00 2020 -e May 05 00:59:00 2020 -D -P 0505_11h_crash

This directory already exists. Rewriting...

-- neu chon option A thi ra file txt trong 
A new analysis file analysis/carddb01_May05000049_1588750108/analysis.txt has been created.
/oracle/app/gridbase/tfa/repository/suptools/t24vn-db01/oswbb/grid/oswbb/analysis
--------------------
++GIAPDV2@MSB.COM.VN	- 2+ months ago		[Update from Customer]


Hello Mohammed Nizamuddin,

I am AIX system admin, I have just installed OS Watcher on both nodes of Oracle RAC, I understand that we need run command "./startOSWbb.sh 5 48 None /usr/app/archive" (with SnapshotInterval = 5 and ArchiveInterval = 48) on both nodes and archive the log files to /usr/app/archive folder. Is this correct?

++
Hello

Thanks for your update !

After some time please review does this archive directories has all logs like
vmstat/netstat/top/iostat
cd to any of this directory and check does logs are getting dumped?
and also login to prvtnet dir
ls -ltr
cat prvtnet-dat-file
If no prvtnet stat configure

Please configure it


Note- You need the "traceroute" OS utility to collect private Network statistics.

To configure OSWatcher statistics collection for Private Network, please check following steps -

1)Copy the Exampleprivate.net file as private.net in OSW folder

2)Remove the other entries and keep the one intended for your O/S
Use only the private names for all Nodes in private.net file.

E.g.- In Linux Platform, the file private.net has following entries.

--------------------------------
traceroute -r -F <nodename1>-priv
traceroue -r -F <nodename2>-priv
rm lock.file
--------------------------------

Remember to keep the last line -rm lock.file

3)Save the private.net file

4)Chmod 777 private.net

This will enable OSWatcher to collect private statistics.
In case, the private.net is created, edited whilst OSWatcher was running then we need to re-start OSWatcher.


++GIAPDV2@MSB.COM.VN	- 2+ months ago		[Update from Customer]


Hello,

I configured private.net for AIX OS, the server detected the OSWatcher process are running by grid user as below, can we stop this OSWatcher process to run new OSWatcher process by root?
root@carddb01 /home/monitor/oswbb >./startOSWbb.sh 5 48 None /tmp/oswbb/archive
An OSWatcher process has been detected.
Please stop it before starting a new OSWatcher process.
root@carddb01 /home/monitor/oswbb >ps -ef |grep OSWatcher
root 32899650 22413676 0 15:20:13 pts/3 0:00 grep OSWatcher
grid 36700844 1 0 Dec 17 - 22:50 /bin/sh ./OSWatcher.sh 30 48 NONE /u01/app/oracle.ahf/data/repository/suptools/carddb01/oswbb/grid/archive
grid 41681474 36700844 0 Dec 17 - 10:23 /bin/sh ./OSWatcherFM.sh 48 /u01/app/oracle.ahf/data/repository/suptools/carddb01/oswbb/grid/archive
root@carddb01 /home/monitor/oswbb >

++
As root user please configure osw then Start and Stop OS Watcher
Start Oswatcher - Collect data every second and run OSWatcher for 1 hour !
# cd /u01/app/grid/oswbb
# ./startOSWbb.sh 05 48 &

Stop OSWatcher
# cd /u01/app/grid/oswbb
# ./stopOSWbb.sh

==============================table point in time =========================================
===========================================================================================
cd /usr/openv/netbackup/bin

./bplist -S dc-nbumaster.msb.com.vn  -s 03/29/2020 -e 03/29/2020  -C ibprd01 -t 4 -l -R /


RECOVER TABLE IBS.BK_ACCOUNT_MASK_INFO ,IBS.BC_RELATED_ACCOUNT_MASK
  UNTIL TIME "TO_DATE('29-MAR-2020 23:00', 'DD-MON-YYYY HH24:MI')"
  AUXILIARY DESTINATION '/u01/aux'  
  REMAP TABLE 'IBS'.'BK_ACCOUNT_MASK_INFO':'BK_ACCOUNT_MASK_INFO_OLD','IBS'.'BC_RELATED_ACCOUNT_MASK':'BC_RELATED_ACCOUNT_MASK_OLD';
  
CONFIGURE DEVICE TYPE  'sbt_tape' PARALLELISM 2;

   configure channel device type sbt_tape FORMAT '%U' PARMS='ENV=(NB_ORA_SERV=dc-nbumaster.msb.com.vn, NB_ORA_CLIENT= ibprd01, SBT_LIBRARY=/usr/openv/netbackup/bin/libobk.a64(shr.o))';

   vi /home/oracle/rman_restore_bdmdr.rman

run{
RECOVER TABLE IBS.BK_ACCOUNT_MASK_INFO ,IBS.BC_RELATED_ACCOUNT_MASK
  UNTIL TIME "TO_DATE('29-MAR-2020 23:00', 'DD-MON-YYYY HH24:MI')"
  AUXILIARY DESTINATION '/data/'
  DATAPUMP DESTINATION 'data/'
  DUMP FILE 'IBS_dump.dat'
  NOTABLEIMPORT;
	}
	
Starting recover at 09-APR-20
using target database control file instead of recovery catalog
allocated channel: ORA_DISK_1
channel ORA_DISK_1: SID=803 device type=DISK
RMAN-05026: WARNING: presuming following set of tablespaces applies to specified Point-in-Time

List of tablespaces expected to have UNDO segments
Tablespace SYSTEM
Tablespace UNDOTBS2

Creating automatic instance, with SID='aduF'

initialization parameters used for automatic instance:
db_name=IBPROD
db_unique_name=aduF_pitr_IBPROD
compatible=12.1.0.2.0
db_block_size=8192
db_files=200
diagnostic_dest=/u01/app/oracle
_system_trig_enabled=FALSE
sga_target=2560M
processes=200
db_create_file_dest=/data/
log_archive_dest_1='location=/data/'
*.cluster_database=false
*.control_files='/u01/app/oracle/product/12.1.0/dbhome_1/dbs/control_ibp.dbf'

#No auxiliary parameter file used


starting up automatic instance IBPROD

Oracle instance started

Total System Global Area    2684354560 bytes

Fixed Size                     3788008 bytes
Variable Size                654312216 bytes
Database Buffers            2013265920 bytes
Redo Buffers                  12988416 bytes
Automatic instance created

contents of Memory Script:
{
# set requested point in time
set until  time "TO_DATE('29-MAR-2020 23:00', 'DD-MON-YYYY HH24:MI')";
# restore the controlfile
restore clone controlfile;
 
# mount the controlfile
sql clone 'alter database mount clone database';
 
# archive current online log 
sql 'alter system archive log current';
}
executing Memory Script

executing command: SET until clause

Starting restore at 09-APR-20
allocated channel: ORA_AUX_DISK_1
channel ORA_AUX_DISK_1: SID=191 device type=DISK
====================================
cd /usr/openv/netbackup/bin

./bplist -S dc-nbumaster.msb.com.vn  -s 03/29/2020 -e 03/29/2020  -C ibprd01 -t 4 -l -R /
alter system set control_files='/u01/app/oracle/product/12.1.0/dbhome_1/dbs/control_ibp.dbf' scope=spfile;
*.control_files='/u01/app/oracle/product/12.1.0/dbhome_1/dbs/control_ibp.dbf'

run {
allocate channel c1 device type 'sbt_tape' parms 'SBT_LIBRARY=/usr/openv/netbackup/bin/libobk.a64(shr.o)';
send 'NB_ORA_SERV=dc-nbumaster.msb.com.vn, NB_ORA_CLIENT= ibprd01';
restore controlfile  from '/ctrl_dIBPROD_uerus8t2j_s12763_p1_t1036285011';
release channel c1;
}


CONFIGURE CHANNEL DEVICE TYPE 'SBT_TAPE'  clear



run{
RECOVER TABLE IBS.BK_ACCOUNT_MASK_INFO ,IBS.BC_RELATED_ACCOUNT_MASK
  UNTIL TIME "TO_DATE('29-MAR-2020 23:00', 'DD-MON-YYYY HH24:MI')"
  AUXILIARY DESTINATION '/backup/'
  DATAPUMP DESTINATION 'backup/'
  DUMP FILE 'IBS_dump.dat'
  NOTABLEIMPORT;
	}
 
============== chungtc tuning log_buffer
--3.29798406351089E-5	202135	6129047203
SELECT  substr(ln.name, 1, 20), gets, misses, immediate_gets, immediate_misses
FROM v$latch l, v$latchname ln
WHERE   ln.name in ('redo allocation', 'redo copy')
                and ln.latch# = l.latch#;
                
select retries.value/entries.value  "redo buffer retries ratio",
retries.value retry_val,
entries.value entry_val
           from v$sysstat retries,

          v$sysstat entries

          where retries.name='redo buffer allocation retries'

          and entries.name='redo entries';                
=====================================================================================
==================== drop partition
ALTER TABLE bec.source TRUNCATE PARTITION SYS_P30957 DROP STORAGE UPDATE INDEXES;
-- khi do global index se co ophaned_entries la YES, status van la VALID
SELECT index_name,
       orphaned_entries,status
FROM   dba_indexes
where table_name='SOURCE'; 
-- sau do luc 2h sang se co job index maintenance, hoac minh co the goi lenh muanual
EXEC DBMS_PART.cleanup_gidx('BEC', 'SOURCE');
no se sinh ra cac lenh tuong duong nhu duoi:
ALTER INDEX "BEC"."SYS_C0058929" COALESCE CLEANUP ONLY
Bang 9G, partition 1 trieu row  =1/31 bang mat 8p de clean xong 2 index global  size 1,2 va 1,4G
============================chungtc index cost optimizer_index_cost_adj ==========================================
 col c1 heading 'Average Waits for|Full Scan Read I/O' format 9999.999
col c2 heading 'Average Waits for|Index Read I/O' format 9999.999
col c3 heading 'Percent of| I/O Waits|for scattered|Full Scans' format 9.99
col c4 heading 'Percent of| I/O Waits|for sequential|Index Scans' format 9.99
col c5 heading 'Starting|Value|for|optimizer|index|cost|adj' format 999
 
select
   sum(a.time_waited_micro)/sum(a.total_waits)/1000000 c1,
   sum(b.time_waited_micro)/sum(b.total_waits)/1000000 c2,
   (
      sum(a.total_waits) /
      sum(a.total_waits + b.total_waits)
   ) * 100 c3,
   (
      sum(b.total_waits) /
      sum(a.total_waits + b.total_waits)
   ) * 100 c4,
  (
      sum(b.time_waited_micro) /
      sum(b.total_waits)) /
      (sum(a.time_waited_micro)/sum(a.total_waits)
   ) * 100 c5
from
   dba_hist_system_event a,
   dba_hist_system_event b
where
   a.snap_id = b.snap_id
and
   a.event_name = 'db file scattered read'
and
   b.event_name = 'db file sequential read';
----aml
SQL> SQL> create index AMLMCOB.IDX_GWGKUNDE_NEW on AMLMCOB.GWGKUNDE(UPPER("KUNDNR"),"KU_ART","INSTITUTSNR") online;

Index created.

SQL>     execute dbms_stats.gather_index_stats(ownname => 'AMLMCOB', indname =>'GWGKUNDE$INSTITUTSNR_HISTBIS', estimate_percent =>DBMS_STATS.AUTO_SAMPLE_SIZE);

========================MYSQL ===================================================
netstat -tlnp |grep mysql
[root@FS-wap01 mysql]# ps aux|grep mysql
root      1385  0.0  0.0 103252   832 pts/1    S+   14:02   0:00 grep mysql
root     20639  0.0  0.0 149992  2780 pts/2    S+   Jan26   0:00 mysql -uroot
root     26057  0.0  0.0 106232  1448 ?        S     2016   0:00 /bin/sh /usr/bin/mysqld_safe --datadir=/var/lib/mysql --pid-file=/var/lib/mysql/FS-wap01.pid --wsrep-new-cluster
mysql    26234  3.1 32.3 8866860 7962176 ?     Sl    2016 29533:34 /usr/sbin/mysqld --basedir=/usr --datadir=/var/lib/mysql --plugin-dir=/usr/lib64/mysql/plugin --user=mysql --wsrep_provider=/usr/lib64/galera/libgalera_smm.so --wsrep-new-cluster --log-error=/var/lib/mysql/FS-wap01.err --pid-file=/var/lib/mysql/FS-wap01.pid --wsrep_start_position=00000000-0000-0000-0000-000000000000:-1
-- start mysql
root@host# cd /usr/bin
./mysqld_safe &
-- stop mysql
root@host# cd /usr/bin
./mysqladmin -u root -p shutdown
Enter password: ******
-- login mysql
mysql -u root -p -h <ip>
mysql --host=127.0.0.1 --port=3306 -uroot -p
mysql -u {username} -p{password} -h {remote server ip}   -- connect to remote host
-- important command
USE Databasename − This will be used to select a database in the MySQL workarea.

SHOW DATABASES − Lists out the databases that are accessible by the MySQL DBMS.

SHOW TABLES − Shows the tables in the database once a database has been selected with the use command.

SHOW COLUMNS FROM <tablename>: Shows the attributes, types of attributes, key information, whether NULL is permitted, defaults, and other information for a table.

SHOW INDEX FROM <tablename> − Presents the details of all indexes on the table, including the PRIMARY KEY.

SHOW TABLE STATUS LIKE <tablename>\G − Reports details of the MySQL DBMS performance and statistics.
--- show ddl of table
SHOW CREATE TABLE  tbl_otp  \G;
-- Getting Server Metadata
1	
SELECT VERSION( )

Server version string

2	
SELECT DATABASE( )

Current database name (empty if none)

3	
SELECT USER( )

Current username

4	
SHOW STATUS

Server status indicators

5	
SHOW VARIABLES\G;

Server configuration variables
------
select current_user;
SHOW GLOBAL VARIABLES LIKE 'PORT';
show databases;
use <DATABASE NAME>
SHOW TABLES;
show table status like 'tbl_action_his';
SHOW VARIABLES LIKE "%version%";
[root@FS-wap01 mysql]# mysqladmin --version
mysqladmin  Ver 9.1 Distrib 10.0.24-MariaDB, for Linux on x86_64

------------------mysql replication
mysql --host=127.0.0.1 --port=3306 -uroot -p
show slave status\G  -> OK thi co dong Slave_IO_State: Waiting for master to send event
show master status
=> 2 lenh nay co truong Master_Log_File: mysql-bin.025341 giong nhau la dang dong bo ok
[root@database01 bin]# find / -name my.cnf
/etc/my.cnf
[root@database01 bin]# cat /etc/my.cnf
[mysqld]
datadir=/home/data/mysql
socket=/home/data/mysql/mysql.sock
user=mysql
# Disabling symbolic-links is recommended to prevent assorted security risks
symbolic-links=0
innodb_buffer_pool_size=20G
innodb_log_buffer_size = 256M
innodb_flush_log_at_trx_commit = 0

server_id           = 1
log_bin             = mysql-bin.log
log_bin_index       = mysql-bin.log.index
relay_log           = mysql-relay-bin
relay_log_index     = mysql-relay-bin.index
expire_logs_days    = 10
max_binlog_size     = 100M
log_slave_updates   = 1
auto-increment-increment = 2
auto-increment-offset = 1
binlog_format=row

[mysqld_safe]
lower_case_table_names=1
log-error=/var/log/mysqld.log
#log-error=/home/data/mysql/mysqld.log
pid-file=/var/run/mysqld/mysqld.pid
[root@database01 bin]# 
=================================================================================
==========How to enable Large Page Feature on AIX-Based Systems (Doc ID 372157.1)
https://support.oracle.com/epmos/faces/DocumentDisplay?_afrLoop=356161322303624&parent=EXTERNAL_SEARCH&sourceId=HOWTO&id=372157.1&_afrWindowMode=0&_adf.ctrl-state=sqh0pwq9o_4
vmo -a |egrep "lgpg_regions|lgpg_size"
======================== chungtc check memory =====================================
Total memory occupied by Instance (SGA + PGA)
select sum(bytes)/1024/1024 mb from (select bytes from v$sgastat union select value bytes from v$sesstat s, v$statname n where n.STATISTIC# = s.STATISTIC# and  n.name = 'session pga memory' );

Process memory (individual process memory)
select a.sid,value/(1024*1024),program from v$session a, v$sesstat b where a.sid=b.sid and b.statistic#=(select statistic# from v$statname where name='session pga memory');

select
  st.sid,
  s.name, 
  st.value
from v$statname s, v$sesstat st
where st.statistic# = s.statistic#
and s.name = 'session pga memory max';

--- check pga
select inst_id,name,value/1024/1024/1024,unit from gv$pgastat order by inst_id,name;

=====================CHUNGTC AUTOTASK ========================================
select dbtimezone from dual;
select systimestamp from dual;
select * from dba_autotask_window_clients;
select * from dba_scheduler_windows;
select * from dba_autotask_job_history order by window_start_time desc;

select * from cdb_autotask_task;
select * from cdb_autotask_client_history order by window_start_time,con_id desc;
select * from cdb_autotask_job_history order by job_start_time desc;
-- check autotask nao duoc enable

  SELECT con_id,
         client_name,
         status,
         service_name,
         window_group,
         attributes,
         TO_CHAR (last_change, 'DD-MON-YY HH24:MI') last_change
    FROM cdb_autotask_client
ORDER BY 1, 2;


-- check autotask gather job theo window

  SELECT con_id,
         window_name,
         TO_CHAR (window_start_time, 'DD-MON HH24:MI:ss') wst,
           EXTRACT (HOUR FROM window_duration)
         + ROUND (EXTRACT (MINUTE FROM window_duration) / 60)
            window_duration,
         jobs_created,
         jobs_started,
         jobs_completed,
         TO_CHAR (window_end_time, 'DD-MON HH24:MI:ss') wet
    FROM cdb_autotask_client_history
   WHERE client_name = 'auto optimizer stats collection'
ORDER BY window_start_time, con_id;

-- xem lich su job gather

  SELECT con_id,
         window_name,
         TO_CHAR (window_start_time, 'DD-MON HH24:MI:ss') wst,
           EXTRACT (HOUR FROM window_duration)
         + ROUND (EXTRACT (MINUTE FROM window_duration) / 60)
            window_duration,
         job_name,
         TO_CHAR (job_start_time, 'DD-MON HH24:MI:ss') jst,
         job_status,
           EXTRACT (HOUR FROM job_duration) * 60
         + ROUND (EXTRACT (MINUTE FROM job_duration))
            job_duration,
         job_error,
         job_info
    FROM cdb_autotask_job_history
   WHERE client_name = 'auto optimizer stats collection'
ORDER BY job_start_time, con_id;
-- cai nay chinh xac
  SELECT con_id,
         id,
         operation,
         job_name,
         target,
         TO_CHAR (start_time, 'DD-MON HH24:MI:ss') jst,
           EXTRACT (HOUR FROM (end_time - start_time)) * 60
         + EXTRACT (MINUTE FROM (end_time - start_time))
            duration,
         status
    FROM cdb_optstat_operations
   WHERE operation = 'gather_database_stats (auto)'
ORDER BY start_time, con_id;

-- xem cac table da duoc gather cua 1 job cu the

  SELECT con_id,
         TO_CHAR (start_time, 'DD-MON HH24:mi:ss') jst,
         target,
         target_type,
         status,
           EXTRACT (HOUR FROM (end_time - start_time)) * 60
         + EXTRACT (MINUTE FROM (end_time - start_time))
            duration
    FROM cdb_optstat_operation_tasks
   WHERE opid = 19220
ORDER BY start_time, con_id;
===================== CHUNGTC JOIN METHOD ======================================
A)SORT MERGE JOIN:
- thu tu join bang ko quan trong. 
- 2 bang se duoc sort truoc roi join.
- Hieu qua trong cac the loai join so sanh ko bang (> < between )

b) NESTED LOOP JOIN
- Bang nho hon la bang outer, la bang ngay duoi tu khoa nested loop.
- Su dung khi key join duoc index tren INNER TABLE
- Bang outter la bang nho, nghia la chi it hon 2% total rows cua no duoc su dung trong loop.
- Vay nen khi nested loop join kem: Kiem tra cardinality misestimate cua outer table + index co dc su dung tot trong inner table?
c) HASH JOIN 
- Chi dung cho equi-join ( = ). Chi phu hop trong warehouse.
- Ca 2 bang deu la bang to, va thuong key join ko co loi the index.
- Bang nho hon se duoc hash len memory ( lien quan toi hash_area_size)  , sau do duoc so sanh vs larger table.
- bang duoc hash va dua len memory la bang ngay duoi tu khoa hash join
- Phu hop voi cac bang da duoc partition using the same partitioning criteria
- Cai tien: reduce the size of the join ; increase hash_area_size; su dung  partition, su dung parallel query
================================== DB LINK TUNE ==================================
- dung hint drinving_site
- tao view phia remote database
SQL*Net message to client – time to pack a message (no network time included) possibly tune SDU
SQL*Net more data from client – possible network issues, possibly tune SDU
SQL*Net more data to client – time to pack a message (no network time included) possibly tune SDU
 
 The same events exist, but where the client is the shadow process and another database plays the roll of shadow process:
 
SQL*Net message to dblink 
SQL*Net more data from dblink – possible network issues, possibly tune SDU
SQL*Net more data to dblink 
================ OR transform =====================================================
https://blogs.oracle.com/optimizer/optimizer-transformations:-or-expansion
Select *
From products
Where prod_category = 'Photo' 
or    prod_subcategory = 'Camera Media';

tuong duong voi

Select *
From   products
Where  prod_subcategory ='Camera Media'
UNION ALL
Select *
From   products
Where  prod_category = 'Photo'
And    lnnvl(prod_subcategory = 'Camera Media')

LNNVL() function in the second branch in order to avoid duplicates being generated across branches. The LNNVL function returns TRUE, if the predicate evaluates to FALSE or if the predicate involves NULL; otherwise it will return FALSE.
================================ HINT ===========================================
select * from V$SQL_HINT;
select * from V$SQL_FEATURE;
--
COL sqlfh_feature HEAD SQL_FEATURE FOR A55
COL hinth_path HEAD PATH FOR A150
PROMPT Display Hint feature hierarchy for hints like &1
WITH feature_hierarchy
     AS (    SELECT f.sql_feature,
                    SYS_CONNECT_BY_PATH (REPLACE (f.sql_feature, 'QKSFM_', ''),
                                         ' -> ')
                       PATH
               FROM v$sql_feature f, v$sql_feature_hierarchy fh
              WHERE f.sql_feature = fh.sql_feature
         CONNECT BY fh.parent_id = PRIOR f.sql_Feature
         START WITH fh.sql_feature = 'QKSFM_ALL')
  SELECT hi.name, REGEXP_REPLACE (fh.PATH, '^ -> ', '') hinth_path
    FROM v$sql_hint hi, feature_hierarchy fh
   WHERE hi.sql_feature = fh.sql_feature --    hi.sql_feature = REGEXP_REPLACE(fh.sql_feature, '_[[:digit:]]+$')
         AND UPPER (hi.name) LIKE UPPER ('%&1%')
ORDER BY PATH;
--
COL sqlfh_feature HEAD SQL_FEATURE FOR A55
PROMPT Display full SQL Feature Hierarchy from v$sql_feature ...

    SELECT LPAD (' ', (LEVEL - 1) * 2) || REPLACE (f.sql_feature, 'QKSFM_', '')
              sqlfh_feature,
           f.description
      FROM v$sql_feature f, v$sql_feature_hierarchy fh
     WHERE f.sql_feature = fh.sql_feature
CONNECT BY fh.parent_id = PRIOR f.sql_Feature
START WITH fh.sql_feature = 'QKSFM_ALL'
--
COL sqlfh_feature HEAD SQL_FEATURE FOR A55
PROMPT Display full SQL Feature Hierarchy from v$sql_feature ...
    SELECT LPAD (' ', (LEVEL - 1) * 2) || REPLACE (f.sql_feature, 'QKSFM_', '')
              sqlfh_feature,
           f.description
      FROM v$sql_feature f, v$sql_feature_hierarchy fh
     WHERE f.sql_feature = fh.sql_feature
CONNECT BY fh.parent_id = PRIOR f.sql_Feature
START WITH fh.sql_feature = 'QKSFM_ALL'
/

-- UNZIP KHI CAI RAC
unzip LINUX.X64_193000_grid_home.zip -d /u01/app/grid/
============ find parrallel session
WITH px_session AS
(SELECT qcsid,
qcserial#,
MAX (degree) degree,
MAX (req_degree) req_degree,
COUNT ( * ) nb_of_processes
FROM gv$px_session p
GROUP BY qcsid,
qcserial#
)
SELECT s.INST_ID, s.sid,s.username,degree,
req_degree,nb_of_processes, s.sql_id,
SUBSTR(sql_text,1,100)
FROM gv$session s JOIN px_session p
ON (s.sid = p.qcsid AND s.serial# = p.qcserial#)
JOIN gv$sql SQL ON (sql.sql_id = s.sql_id
AND sql.child_number = s.sql_child_number);
============= parallel control  
- parallel_max_servers: Specifies the maximum number of parallel execution processes and parallel recovery processes for an instance
	http://devel.hotpilot.cz/ora-12cR1-lin-64-inst/E50529_01/VLDBG/parallel004.htm#VLDBG1480
	parallel_max_servers = (cpu_count) * (parallel_threads_per_cpu) * (concurrent_users * 5)
	if the MEMORY_TARGET or SGA_TARGET initialization parameter is set, then concurrent_users = 4
- parallel_servers_target = 4 * (DOP) = 4*(cpu_count) * (parallel_threads_per_cpu) * (instances in a cluster)
	This formula holds true unless:
	parallel_max_servers is set to a non-default value. In this case, parallel_servers_target = cpu_count * parallel_max_servers.
	cpu_count=1. In this case, parallel_max_servers = cpu_count * 4.

1 câu select full scan bình thường có thể được chọn thành parallel excute , chi phối bởi các tham số dưới
- trước tiên, optimizer tính toán khi serial thì câu lệnh sẽ tốn thời gian hơn parallel_min_time_threshold 
thì câu lệnh fullscan đó sẽ được tính toán parallel.
- Degree of parallel sẽ được tính toán từ PARALLEL_THREADS_PER_CPU*cpu_count* no_instance

SQL> show parameter PARALLEL_DEGREE_LIMIT

NAME                                 TYPE        VALUE
------------------------------------ ----------- ------------------------------
parallel_degree_limit                string      CPU
SQL> show parameter PARALLEL_THREADS_PER_CPU

NAME                                 TYPE        VALUE
------------------------------------ ----------- ------------------------------
parallel_threads_per_cpu             integer     4
SQL> show parameter CPU_COUNT 

NAME                                 TYPE        VALUE
------------------------------------ ----------- ------------------------------
cpu_count                            integer     72
SQL> show parameter PARALLEL_MIN_TIME_THRESHOLD 

NAME                                 TYPE        VALUE
------------------------------------ ----------- ------------------------------
parallel_min_time_threshold          string      7200

====================REWRITE LOOP chungtc============================== http://www.orafaq.com/tuningguide/high%20vol%20nl.html
--
SELECT a.*
FROM   table_a a
WHERE  NOT EXISTS (
       SELECT 1
       FROM   table_b
       WHERE  b.col1 = a.col1)
becomes ....

SELECT a.*
FROM   table_a a , table_b b
WHERE  a.col1 = b.col1 (+)
AND    b.rowid IS NULL
--
SELECT *
FROM   table_a
WHERE  EXISTS (
       SELECT 1
       FROM   table_b b, table_c c
       WHERE  b.key2 = c.key2
       AND    b.key1 = a.key1);

becomes ...

SELECT a.*
FROM   table_a a
, (    SELECT DISTINCT b.key1
       FROM   table_b b, table_c c
       WHERE  b.key2 = c.key2
  ) d
WHERE  a.key1 = d.key1

--
SELECT a.*
FROM   table_a a
WHERE  col2 = (
       SELECT max(col2)
       FROM   table_b
       WHERE  b.col1 = a.col1)
becomes ....

SELECT a.*
FROM   table_a a,
(      SELECT col1, max(col2)
       FROM   table_b
       GROUP  BY col1
) b
WHERE  a.col1 = b.col1
====================================================== full hint paralell
ALTER SESSION FORCE PARALLEL DML PARALLEL 16;
ALTER SESSION FORCE PARALLEL QUERY PARALLEL 64;
ALTER SESSION ENABLE PARALLEL DML;
INSERT /*+ PARALLEL(a,4) */ INTO APPS.tR_THLK_chungtc a
SELECT /*+ PARALLEL(b,4) */ *  FROM APPS.TR_THLK b;

insert /*+enable_parallel_dml parallel(128)*/ into t24core.ACFBNK_STMT008 (recid,xmlrecord)
select /*+enable_parallel_dml parallel(128)*/recid,xmlrecord from t24core.ACFBNK_STMT008_TAFC where recid like 'F%' and recid not in
(select /*+enable_parallel_dml parallel(128)*/recid from t24core.ACFBNK_STMT008);
commit;


-- hint monitor
ALTER SYSTEM SET EVENTS 'sql_monitor [sql: gp0r0bc8mac1g|sql: 9ht3ba3arrzt3] force=true';
ALTER SYSTEM SET EVENTS 'sql_monitor [sql: gp0r0bc8mac1g] force=true';
-- hint reparse
select /*B*/ count(*) from t where a2 <= 42
-- hint nhanh
Select /*+ parallel(8) index_ffs(t) */     count(*)     From <TABLE_NAME> t

select /*+ FULL(a) PARALLEL(a, 3) */  * from FTP.GLFT_MASTER partition (GLFT_MASTER_201702) a ;

select /*+ index(MB_TR_T24_STMT_NOW MB_TR_T24_STMT_NOW_IDX1) */ * from customer;

SELECT /*+ parallel(t 4) */ * FROM Table1 t;

SELECT /*+ OPTIMIZER_FEATURES_ENABLE('12.1.0.2')*/ b.LFD_NR BranchID

/*+ parallel(16) index (t(TRAN_TIME)) */
drinving_site

/*+NO_CPU_COSTING */
/*+  gather_plan_statistics*/  ~  alter session set statistics_level=all

/*+  USE_NL(ITEM, ENTRY, M_TRANSACTION, DOC, ACCOUNT_MASK, ACNT_CONTRACT, ACCOUNT_MASK_TYPE, ccy1, ccy2, ctrf)*/
select /*+ use_nl(p1,kbwyv1) ordered */  sum(prc_pd)  from parent1 p1,  kbwyv1

/*+ use_hash(e,b) parallel(e, 4) parallel(b, 4) */
AND EXISTS (SELECT /*+ HASH_SJ */    -- dung trong subquery

/*+OPTIMIZER_FEATURES_ENABLE('12.1.0.2') MONITOR*/

select /*+ dynamic_sampling(test1 3) */ * from test1;

INSERT /*+ SYS_DL_CURSOR */ INTO TRAN ("CKEY","LNUM","ACTNBR") VALUES  --Direct-Path loading API 

SELECT /*+ FIRST_ROWS(10) */ empno, ename FROM empWHERE deptno = 10;

SELECT /*+ NO_INDEX(emp emp_ix) */ empno, ename FROM emp, dept WHERE emp.deptno = dept.deptno;

SELECT /*+ LEADING (dept) */ empno, ename FROM emp, dept WHERE emp.deptno = dept.deptno;

SELECT /*+ CACHE (d) */ deptno, dname FROM dept d;

SELECT /*+ DYNAMIC_SAMPLING(e, 2) */        *    FROM   departments              d    ,      TABLE(employees_piped)   e    WHERE  d.department_id = e.department_id;

SELECT /*+ OPT_ESTIMATE(table, e, scale_rows=2.62) */   * FROM   departments    d ,      TABLE(employees_piped)   e   WHERE  d.department_id = e.department_id;

SELECT /*+ OPT_ESTIMATE (TABLE "TEST_DATA" ROWS=44.000000 ) OPT_ESTIMATE (INDEX_SCAN "TEST_DATA" "INDEX2" MIN=69.000000 ) 
OPT_ESTIMATE (INDEX_FILTER "TEST_DATA" "INDEX2" ROWS=69.000000 ) */  FROM "BGRENN"."TEST_DATA" "TEST_DATA"

SELECT /*+ CARDINALITY(e, 21400) */ *  FROM   departments              d    ,      TABLE(employees_piped)   e    WHERE  d.department_id = e.department_id;

use_concat   : hint cho cau lenh co join va or , dk la cac cot do fai duoc danh index 
/*+ USE_CONCAT (or_predicates(2) ) index(a,IDX_ACCOUNT_PHONE) index(a,IDX_ACCOUNT_MOBILE)*/*
opt_estimate(join(alias1 alias2) scale_rows=factor),
where <factor> should be replaced with the actual rescaling factor, e.g. 10 if the optimizer underestimates the join cardinality by the factor of 10. Or instead of scale_rows you can use rows=<correct_number_of_rows>.


SELECT /*+ gather_plan_statistics */  MIN(R.BUC_RATING_FINAL_SBV) FROM B2CRISK.TBCP_RW_CPTY
                R JOIN B2RAW.TBCP_CPTY_KP CP ON R.CPTY_ID = CP.CPTY_ID WHERE
                R.POSTED_DT = to_date('12/02/2019 00:00:00','mm/dd/yyyy hh24:mi:ss') AND (CP.CPTY_CODE = 'KBNN' OR CP.CPTY_CODE =
                NULL ) AND (R.TERM = 'T01' OR R.TERM IS NULL) AND
                R.REPORT_TYPE_ID = 1;
                
select * from table(dbms_xplan.display_cursor(null,null,'iostats last')); 

----- optimized goal
Chạy trên soe/soe
SET LINESIZE 180
SET AUTOT TRACE EXP
SELECT /*+ FIRST_ROWS */ /* MYTEST */ ORDER_ID FROM ORDERS;
SELECT /*+ FIRST_ROWS(10) */ /* MYTEST */ ORDER_ID FROM ORDERS;

Chạy trên sysdba để ktra lại
SET LINESIZE 150
col SQL_TEXT format A60
SELECT OPTIMIZER_MODE, SUBSTR(SQL_TEXT,1,60) SQL_TEXT
FROM V$SQL
WHERE SQL_TEXT LIKE '%MYTEST%ORDERS%'

===============bulk collect bulk insert===============================
declare
  -- define array type of the new table
  TYPE new_table_array_type IS TABLE OF NEW_TABLE%ROWTYPE INDEX BY BINARY_INTEGER;

  -- define array object of new table
  new_table_array_object new_table_array_type;

  -- fetch size on  bulk operation, scale the value to tweak
  -- performance optimization over IO and memory usage
  fetch_size NUMBER := 5000;

  -- define select statment of old table
  -- select desiered columns of OLD_TABLE to be filled in NEW_TABLE
  CURSOR old_table_cursor IS
    select * from OLD_TABLE; 

BEGIN

  OPEN old_table_cursor;
  loop
    -- bulk fetch(read) operation
    FETCH old_table_cursor BULK COLLECT
      INTO new_table_array_object LIMIT fetch_size;
    EXIT WHEN old_table_cursor%NOTFOUND;

    -- do your business logic here (if any)
    -- FOR i IN 1 .. new_table_array_object.COUNT  LOOP
    --   new_table_array_object(i).some_column := 'HELLO PLSQL';    
    -- END LOOP;    

    -- bulk Insert operation
    FORALL i IN INDICES OF new_table_array_object SAVE EXCEPTIONS
      INSERT INTO NEW_TABLE VALUES new_table_array_object(i);
    COMMIT;

  END LOOP;
  CLOSE old_table_cursor;
End;

===
CREATE OR REPLACE PROCEDURE ORSWARM.ARC_TABLE_AT_ORSLIVE
AUTHID CURRENT_USER AS 

CREATE OR REPLACE PROCEDURE test_proc (p_array_size IN PLS_INTEGER DEFAULT 100)
IS
TYPE ARRAY IS TABLE OF all_objects%ROWTYPE;
l_data ARRAY;

CURSOR c IS SELECT * FROM all_objects;

BEGIN
    OPEN c;
    LOOP
    FETCH c BULK COLLECT INTO l_data LIMIT p_array_size;

    FORALL i IN 1..l_data.COUNT
    INSERT INTO t1 VALUES l_data(i);

    EXIT WHEN c%NOTFOUND;
    END LOOP;
    CLOSE c;
END test_proc;
/
==============
declare
TYPE ARRAY IS TABLE OF citad1_new.TBLGENKEY_NEW_LF%ROWTYPE;
l_data ARRAY;

CURSOR c IS  select SERV_CODE, CURRENTKEY, CURRENYEAR   from citad1_new.TBLGENKEY_NEW_LF;

BEGIN
    OPEN c;
    LOOP
    FETCH c BULK COLLECT INTO l_data LIMIT 1000;

    FORALL i IN 1..l_data.COUNT
    delete from citad1_new.TBLGENKEY_NEW where SERV_CODE=l_data(i).SERV_CODE and  CURRENTKEY=l_data(i).CURRENTKEY and CURRENYEAR=l_data(i).CURRENYEAR;
    commit;	
    EXIT WHEN c%NOTFOUND;
    END LOOP;
    CLOSE c;
END ;
/


============================ bulk collect - bulk update ===============================
SET SERVEROUTPUT ON

DECLARE
   TYPE t_id_tab IS TABLE OF forall_test.id%TYPE;

   TYPE t_forall_test_tab IS TABLE OF forall_test%ROWTYPE;

   l_id_tab   t_id_tab := t_id_tab ();
   l_tab      t_forall_test_tab := t_forall_test_tab ();
   l_start    NUMBER;
   l_size     NUMBER := 10000;
BEGIN
   -- Populate collections.
   FOR i IN 1 .. l_size
   LOOP
      l_id_tab.EXTEND;
      l_tab.EXTEND;

      l_id_tab (l_id_tab.LAST) := i;
      l_tab (l_tab.LAST).id := i;
      l_tab (l_tab.LAST).code := TO_CHAR (i);
      l_tab (l_tab.LAST).description := 'Description: ' || TO_CHAR (i);
   END LOOP;
-- Time bulk updates.

   FORALL i IN l_tab.FIRST .. l_tab.LAST
      UPDATE forall_test
         SET ROW = l_tab (i)
       WHERE id = l_id_tab (i);

   DBMS_OUTPUT.put_line (
      'Bulk Updates   : ' || (DBMS_UTILITY.get_time - l_start));

   COMMIT;
END;
/
---------
DECLARE
    CURSOR rec_cur IS
    SELECT object_id,owner,object_name
    FROM dba_objects;
        TYPE rec_cur_obj IS TABLE OF dba_objects.object_id%TYPE; --forall_test%ROWTYPE;

    TYPE rec_cur_owner IS TABLE OF dba_objects.owner%TYPE; --forall_test%ROWTYPE;
    TYPE rec_cur_object IS TABLE OF dba_objects.object_name%TYPE;

    pk_tab rec_cur_obj;
    
    fk_tab rec_cur_owner;
    a_tab rec_cur_object;
BEGIN
    OPEN rec_cur;
    LOOP
        FETCH rec_cur BULK COLLECT INTO pk_tab, fk_tab,a_tab LIMIT 1000;
        EXIT WHEN pk_tab.COUNT() = 0;

        FORALL i IN pk_tab.FIRST .. pk_tab.LAST
           UPDATE chungtc.test
            SET    object_name = fk_tab(i)||'t'
            WHERE  object_id = pk_tab(i);
            commit;
    END LOOP;
    CLOSE rec_cur;
END;
/   
============
DECLARE
    CURSOR rec_cur IS
    SELECT *
    FROM test4;

    TYPE num_tab_t IS TABLE OF NUMBER(38);
    TYPE vc2_tab_t IS TABLE OF VARCHAR2(4000);

    pk_tab NUM_TAB_T;
    fk_tab NUM_TAB_T;
    fill_tab VC2_TAB_T;
BEGIN
    OPEN rec_cur;
    LOOP
        FETCH rec_cur BULK COLLECT INTO pk_tab, fk_tab, fill_tab LIMIT 1000;
        EXIT WHEN pk_tab.COUNT() = 0;

        FORALL i IN pk_tab.FIRST .. pk_tab.LAST
           UPDATE test
            SET    fk = fk_tab(i)
            ,      fill = fill_tab(i)
            WHERE  pk = pk_tab(i);
    END LOOP;
    CLOSE rec_cur;
END;
/   

============================== update column function chungtc masking
CREATE OR REPLACE PACKAGE SYS.remap_data_masking
IS
   -- masking function for import with remap_data parameter
   -- 2020-02-21 thinhdd
   FUNCTION mask_name (col_data IN VARCHAR2)
      RETURN VARCHAR2;
END;
/
CREATE OR REPLACE PACKAGE BODY SYS.remap_data_masking
IS
   FUNCTION mask_name (col_data IN VARCHAR2)
      RETURN VARCHAR2
   IS
      space_cnt     NUMBER;
      KQ   VARCHAR2 (32767);
      avg_len       NUMBER;
   BEGIN
      space_cnt :=
         REGEXP_COUNT (REGEXP_REPLACE (TRIM (col_data), ' +', ' '), ' ');


      IF LENGTH (col_data) > 0
      THEN
         KQ := UPPER (col_data);
         KQ := REPLACE (KQ, 'A', 'Z');
         KQ := REPLACE (KQ, 'E', 'Y');
         KQ := REPLACE (KQ, 'U', 'X');
         KQ := REPLACE (KQ, 'I', 'R');
         KQ := REPLACE (KQ, 'O', 'S');

         KQ := REPLACE (KQ, '1', '4');
         KQ := REPLACE (KQ, '3', '6');
         KQ := REPLACE (KQ, '5', '8');
         KQ := REPLACE (KQ, '7', '0');
         KQ := REPLACE (KQ, '9', '2');
      ELSE
         KQ := NULL;
      END IF;

      RETURN SUBSTR (TRIM (KQ), 1, LENGTH (col_data));
   END;
END;
/
begin
   merge into CHUNGTC.OPT_CLIENT r
   using CHUNGTC.OPT_CLIENT e
   on (r.rowid = e.rowid)
   when matched then
   update set
      r.E_MAIL = sys.remap_data_masking.mask_name(r.E_MAIL); 
   commit;
   end;
   /   
=================================== chungtc masking new
/* Formatted on 9/6/2021 3:59:07 PM (QP5 v5.287) */
CREATE OR REPLACE PACKAGE SYS.remap_data_masking
IS
   -- masking function for import with remap_data parameter
   -- 2020-02-21 thinhdd
   FUNCTION mask_name (col_data IN VARCHAR2)
      RETURN VARCHAR2;

   FUNCTION mask_date (col_data IN DATE)
      RETURN DATE;
END;
/

CREATE OR REPLACE PACKAGE BODY SYS.remap_data_masking
IS
   FUNCTION mask_name (col_data IN VARCHAR2)
      RETURN VARCHAR2
   IS
      space_cnt   NUMBER;
      KQ          VARCHAR2 (32767);

      avg_len     NUMBER;
   BEGIN
      space_cnt :=
         REGEXP_COUNT (REGEXP_REPLACE (TRIM (col_data), ' +', ' '), ' ');


      IF LENGTH (col_data) > 0
      THEN
         KQ := UPPER (col_data);
         KQ := REPLACE (KQ, 'A', 'Z');
         KQ := REPLACE (KQ, 'E', 'Y');
         KQ := REPLACE (KQ, 'U', 'X');
         KQ := REPLACE (KQ, 'I', 'R');
         KQ := REPLACE (KQ, 'O', 'S');

         KQ := REPLACE (KQ, '1', '4');
         KQ := REPLACE (KQ, '3', '6');
         KQ := REPLACE (KQ, '5', '8');
         KQ := REPLACE (KQ, '7', '0');
         KQ := REPLACE (KQ, '9', '2');
      ELSE
         KQ := NULL;
      END IF;

      RETURN SUBSTR (TRIM (KQ), 1, LENGTH (col_data));
   END;

   FUNCTION mask_date (col_data IN DATE)
      RETURN DATE
   IS
      space_cnt   NUMBER;
      KQ          VARCHAR2 (32767);
      KQD         VARCHAR2 (32767);
      KQM         VARCHAR2 (32767);
      KQY         VARCHAR2 (32767);

      avg_len     NUMBER;
   BEGIN
      IF LENGTH (col_data) > 0
      THEN
         KQD := TO_CHAR (col_data, 'dd');
         KQD := REPLACE (KQD, '4', '1');
         KQD := REPLACE (KQD, '3', '2');
         KQD := REPLACE (KQD, '5', '8');
         KQD := REPLACE (KQD, '9', '6');

         KQM := TO_CHAR (col_data, 'mm');
         KQM := REPLACE (KQM, '02', '04');
         KQM := REPLACE (KQM, '06', '03');
         KQM := REPLACE (KQM, '05', '08');
         KQM := REPLACE (KQM, '09', '01');
         KQM := REPLACE (KQM, '07', '10');
         KQM := REPLACE (KQM, '11', '12');

         KQY := TO_CHAR (col_data, 'yyyy');
         KQY := REPLACE (KQY, '3', '6');
         KQY := REPLACE (KQY, '5', '8');
         KQY := REPLACE (KQY, '7', '0');

         KQ := TO_CHAR (col_data, 'hh24:mi:ss');
         KQ := KQD || '/' || KQM || '/' || KQY || ' ' || KQ;
      ELSE
         KQ := '01/01/1000 00:00:01';
      END IF;

      RETURN TO_DATE (KQ, 'dd/mm/yyyy hh24:mi:ss');
   END;
END;
/

begin
   merge into chungtc.OPT_APPL_ACNT r
   using chungtc.OPT_APPL_ACNT e
   on (r.rowid = e.rowid)
   when matched then
   update set
      r.BIRTH_DATE = sys.remap_data_masking.mask_date(r.BIRTH_DATE);
   commit;
   end;
   /  
=============================== migrate table partition chungtc ===========
/* Formatted on 9/13/2021 7:50:13 PM (QP5 v5.287) */
SET SERVEROUTPUT ON

DECLARE
   CURSOR cur
   IS
        SELECT a.owner,
               a.table_name,
               a.partition,
               a.partition_date,
               a.high_value,
               a.PARTITION_POSITION,
               b.column_name
          FROM (WITH xml
                     AS (SELECT DBMS_XMLGEN.getxmltype (
                                   'select table_owner,table_name,partition_name,tablespace_name, high_value,PARTITION_POSITION from dba_tab_partitions 
                    where TABLE_OWNER = ''BANKPLUS'' 
                           AND TABLE_NAME in ( ''H2H_TRANSACTIONS_BK'') order by table_name,partition_name')
                                   AS x
                           FROM DUAL)
                  SELECT EXTRACTVALUE (rws.object_value, '/ROW/TABLE_OWNER')
                            OWNER,
                         EXTRACTVALUE (rws.object_value, '/ROW/TABLE_NAME')
                            table_name,
                         EXTRACTVALUE (rws.object_value, '/ROW/PARTITION_NAME')
                            partition,
                         EXTRACTVALUE (rws.object_value, '/ROW/HIGH_VALUE')
                            high_value,
                         REGEXP_SUBSTR (
                            EXTRACTVALUE (rws.object_value, '/ROW/HIGH_VALUE'),
                            '[^ ]+',
                            1,
                            2)
                            partition_date, -- truong hop partition theo interval
                         EXTRACTVALUE (rws.object_value,
                                       '/ROW/PARTITION_POSITION')
                            PARTITION_POSITION
                    FROM xml x,
                         TABLE (XMLSEQUENCE (EXTRACT (x.x, '/ROWSET/ROW'))) rws
                ORDER BY TABLE_NAME, HIGH_VALUE) a,
               DBA_PART_KEY_COLUMNS b
         WHERE     TO_DATE (a.partition_date, 'yyyy-mm-dd') <=
                      TO_DATE ('2021-01-01', 'YYYY-MM-DD') ----------------------
               AND a.owner = b.owner
               AND a.table_name = b.name
      ORDER BY table_name, TO_DATE (a.partition_date, 'yyyy-mm-dd');

   TYPE array_of_partition IS TABLE OF cur%ROWTYPE;

   vds       array_of_partition;
   c_limit   PLS_INTEGER := 5;
BEGIN
   OPEN cur;
    DBMS_OUTPUT.put_line ('set serveroutput on;');
   LOOP
      FETCH cur BULK COLLECT INTO vds;

      -- LIMIT c_limit;

      EXIT WHEN vds.COUNT = 0;

      FOR j IN 1 .. vds.COUNT
      LOOP
         IF vds (j).PARTITION_POSITION = 1
         --IF j = 1
         THEN
            DBMS_OUTPUT.put_line ('exec DBMS_OUTPUT.put_line('''||vds (j).owner
               || '.'
               || vds (j).table_name
               ||'.'
               ||vds(j).partition||' '|| vds (j).column_name
               || ' < '
               || vds (j).partition_Date
               || ' and '
               || vds (j).column_name
               
               ||''');');
            DBMS_OUTPUT.put_line (
                  'insert into '
               || vds (j).owner
               || '.'
               || vds (j).table_name
               || ' select * from '
               || vds (j).owner
               || '.'
               || vds (j).table_name
               || '@TO_BANKPLUS_DR where '
               || vds (j).column_name
               || ' < '
               || vds (j).high_value
               || ';');
            DBMS_OUTPUT.put_line ('commit;');
         ELSE
             DBMS_OUTPUT.put_line ('exec DBMS_OUTPUT.put_line('''||vds (j).owner
               || '.'
               || vds (j).table_name
               ||'.'
               ||vds(j).partition||' '|| vds (j).column_name
               || ' < '
               || vds (j).partition_Date
               || ' and '
               || vds (j).column_name
               || ' >= '
               || vds (j - 1).partition_Date
               ||''');');
            DBMS_OUTPUT.put_line (
                  'insert into '
               || vds (j).owner
               || '.'
               || vds (j).table_name
               || ' select * from '
               || vds (j).owner
               || '.'
               || vds (j).table_name
               || '@TO_BANKPLUS_DR where '
               || vds (j).column_name
               || ' < '
               || vds (j).high_value
               || ' and '
               || vds (j).column_name
               || ' >= '
               || vds (j - 1).high_value
               || ';');
            DBMS_OUTPUT.put_line ('commit;');
         END IF;
      END LOOP;
   END LOOP;
END;   
-------- recovery 11g
http://dbaworkshop.blogspot.com/p/recovery-scenarios_5.html?m=1

EVS CONFIGURE COMPRESSION ALGORITHM 'BASIC' AS OF RELEASE 'DEFAULT' OPTIMIZE FOR LOAD TRUE ; # default
Size	57,8 Gb AUD$ EVS 03/04/2016
IOStat by Function summary
IOStat by Function summary
/s01/ingw/diag/rdbms/ingwlc/INGWLC/trace/alert_INGWLC.log
/s01/ingw/diag/rdbms/ingwyh/INGWYH/trace/alert_INGWYH.log
/app/oracle/diag/rdbms/evsyh/evsyh1/trace/
/app/oracle/diag/rdbms/evsyh/evsyh2/trace/
/u01/ingw/diag/rdbms/ingw5/INGW5/trace/alert_INGW5.log

/u01/oracle/diag/rdbms/kmtd5_stby/kmtd5/trace
http://10.50.12.28:7007/console/login/LoginForm.jsp
http://10.50.12.28:7007/kmtd5-em/login.jsp;jsessionid=g5sFJgTFhhn7xwyqmgjhc1KNsLb713nHpygsPlchwPq2z1FK0DJl!908522978
http://10.151.242.224:7001/console/console.portal?_nfpb=true&_pageLabel=JdbcDatasourcesJDBCDataSourceConfigConnectionPoolTabPage&handle=com.bea.console.handles.JMXHandle%28%22com.bea%3AName%3DKmtd%2CType%3Dweblogic.j2ee.descriptor.wl.JDBCDataSourceBean%2CParent%3D%5Bj2ee_domain%5D%2FJDBCSystemResources%5BKmtd%5D%2CPath%3DJDBCResource%5BKmtd%5D%22%29

============ impdp from standby database
drop user orswarm;
CREATE USER ba_users 
  IDENTIFIED BY "ba_users123"
  DEFAULT TABLESPACE USERs
  TEMPORARY TABLESPACE TEMP
  ACCOUNT_MASK UNLOCK;

GRANT CREATE SESSION  TO ba_users;
grant DATAPUMP_EXP_FULL_DATABASE to orswarm;
grant  dba to orswarm;
sqlplus 'orswarm/test1234@ors'

DROP PUBLIC DATABASE LINK dblink_t24vndr
CREATE PUBLIC DATABASE LINK dblink_t24dr
 CONNECT TO chungtc
 IDENTIFIED BY Rich1234
 USING '(DESCRIPTION=
    (ADDRESS=
      (PROTOCOL=TCP)
      (HOST=10.2.3.25)
      (PORT=1521)
    )
    (CONNECT_DATA=
      (SERVER=dedicated)
      (SERVICE_NAME=T24COB)
    )
)';

select db_unique_name from v$database@dblink_t24vndr;

nohup impdp chungtc/uatrich tables=T24CORE.STFBNK_CUST000 network_link=dblink_t24vndr directory=CHUNGTC_DIR logfile=STFBNK_CUST000_IMP.log parallel=2 remap_schema=t24core:chungtc REMAP_TABLESPACE=T24ACCT_DATA:MCREDIT job_name=STFBNK_CUST000_IMP  2>&1 &
nohup impdp orswarm/orswarm123 tables=APPS.REP_TOI_FINAL_DAILY network_link=dblink_ors directory=DATA_PUMP_DIR logfile=DATA_PUMP_DIR:REP_TOI_FINAL_DAILY.log parallel=2  transform=disable_archive_logging:y 2>&1 &
expdp orswarm/orswarm123 network_link=dblink_ors dumpfile=REP_TOI_FINAL_DAILY.dmp logfile=REP_TOI_FINAL_DAILY.log tables=APPS.REP_TOI_FINAL_DAILY directory=DATA_PUMP_DIR

++ import schema / data from one schema++++++++++++++++++++++++++++++
DROP DIRECTORY DPUMP;

create directory DPUMP as '/backup/FTP';
grant read,write on directory DPUMP to sys;
impdp  \'sys/msbsysadmin123@FTPHIS as sysdba\' directory=DPUMP dumpfile=real_full.dmp sqlfile=real_full.sql   --- chi sinh ra cau sql ma ko import
impdp  \'sys/msbsysadmin123@FTPHIS as sysdba\' directory=DPUMP dumpfile=real_full.dmp sqlfile=real_full.sql transport_datafiles=1,2  --- chi sinh ra cau sql ma ko import, dung cho transportable tablespace
impdp \'sys/msbsysadmin123@FTPHIS as sysdba\'  directory=DPUMP  dumpfile=DPUMP:TXTB_HISTORY_201801.dmp logfile=DPUMP:TXTB_HISTORY_201801.import.log table_exists_action=append;
=========== masking impdp a Thinh 
nohup impdp \' / as sysdba\'  directory=DMP  dumpfile=DMP:ACCOUNT_MASK_SUMMARY_MASK_MA.dmp logfile=DMP:ACCOUNT_MASK_SUMMARY_MASK_MA.import.log REMAP_TABLE=CRM1.ACCOUNT_MASK_SUMMARY_MASK_MA:ACCOUNT_MASK_SUMMARY_MASK_MA_MASK REMAP_DATA=CRM1.ACCOUNT_MASK_SUMMARY_MASK_MA.tenkh:CRM1.remap_data_masking.mask_name &
nohup impdp \' / as sysdba\'  directory=DMP  dumpfile=DMP:ACCOUNT_MASK.dmp logfile=DMP:ACCOUNT_MASK.import.log REMAP_TABLE=CRM1.ACCOUNT_MASK:ACCOUNT_MASK_MASK REMAP_DATA=CRM1.ACCOUNT_MASK.name:CRM1.remap_data_masking.mask_name  &

nohup impdp \' / as sysdba\'   directory=DPUMP  dumpfile=DPUMP:crm.dmp logfile=DPUMP:crm.import.log content=data_only table_exists_action=append &

-------------
CREATE OR REPLACE PACKAGE CRM1.remap_data_masking
IS
   -- masking function for import with remap_data parameter
   -- 2020-02-21 thinhdd
   FUNCTION mask_name (col_data IN VARCHAR2)
      RETURN VARCHAR2;
END;
/
CREATE OR REPLACE PACKAGE BODY CRM1.remap_data_masking
IS
   FUNCTION mask_name (col_data IN VARCHAR2)
      RETURN VARCHAR2
   IS
      space_cnt     NUMBER;
      KQ   VARCHAR2 (32767);
      avg_len       NUMBER;
   BEGIN
      space_cnt :=
         REGEXP_COUNT (REGEXP_REPLACE (TRIM (col_data), ' +', ' '), ' ');


      IF LENGTH (col_data) > 0
      THEN
         KQ := UPPER (col_data);
         KQ := REPLACE (KQ, 'A', 'Z');
         KQ := REPLACE (KQ, 'E', 'Y');
         KQ := REPLACE (KQ, 'U', 'X');
         KQ := REPLACE (KQ, 'I', 'R');
         KQ := REPLACE (KQ, 'O', 'S');

         KQ := REPLACE (KQ, '1', '4');
         KQ := REPLACE (KQ, '3', '6');
         KQ := REPLACE (KQ, '5', '8');
         KQ := REPLACE (KQ, '7', '0');
         KQ := REPLACE (KQ, '9', '2');
      ELSE
         KQ := NULL;
      END IF;

      RETURN SUBSTR (TRIM (KQ), 1, LENGTH (col_data));
   END;
END;
/
----------------
REMAP_DATA=CRM1.CUSTOMER_MASTER.CM_NAME1:CRM1.remap_data_masking.mask_name
REMAP_DATA=CRM1.CUSTOMER_MASTER.CM_EMAIL_ID:CRM1.remap_data_masking.mask_email
REMAP_DATA=CRM1.CUSTOMER_MASTER.CM_MOBILE_NO:CRM1.remap_data_masking.mask_phone


impdp "'/ as sysdba'" parfile=exclude.par schemas=KMTD4 JOB_NAME=IMPORT_KMTD4_2 directory=TEST_DIR dumpfile=KMTD4_SCHEMA_20131220.dmp logfile=import_schema.log remap_tablespace=KMTD_DATA:KMTD3_DATA,KMTD_INDEX:KMTD3_INDEX remap_schema=KMTD4:TEST

impdp "'/ as sysdba'" JOB_NAME=IMPORT_KMTD4_2 directory=TEST_DIR dumpfile=KMTD4_DATA_20131220.dmp logfile=import_data.log remap_tablespace=KMTD_DATA:KMTD3_DATA,KMTD_INDEX:KMTD3_INDEX remap_schema=KMTD4:TEST content=DATA_ONLY
===========
impdp system full= yes "EXCLUDE=SCHEMA:\"IN('ADBM','DBSNMP','PERFSTAT','UPDOWN','ORACLE_OCM','OUTLN','SYS','SYSTEM')\"" network_link=old_MYDB directory=acinu_imp logfile=AcinupImport.log parallel=2 job_name=MYDB_DMP_FULL
impdp user/pass directory=my_dp_dir remap_schema=src_schema:dest_schema REMAP_TABLESPACE=src_ts:dest_ts REMAP_TABLE=src_schema.A:x,src_schema.B:y,src_schema.C:z dumpfile=dump_file.dmp logfile=impdp.log
B1: tao 1 directory, trong do' se copy cac file dump va file .par vao
SQL> create directory DUMP as '/acfs01/dump';

B2: 
tao file exclude.par ( bo qua cac object nay - vi ko co data, de gay loi)
exclude=constraint
exclude=statistics
exclude=procedure
exclude=view
exclude=job
exclude=trigger

- tao user:
select DBMS_METADATA.GET_DDL('USER','WILIAM') from dual;
CREATE USER c##chungtc IDENTIFIED BY Rich1234 CONTAINER=ALL;
GRANT CREATE SESSION TO c##chungtc CONTAINER=ALL;
grant dba to c##chungtc container=all;
grant CDB_DBA to c##chungtc container=all;


CREATE USER c##chungtc IDENTIFIED BY Rich1234 password expire CONTAINER=ALL;
GRANT CREATE SESSION TO c##chungtc CONTAINER=ALL;
grant sysdba to c##chungtc container=all;

create user chungtc identified by Rich1234;
grant connect  to chungtc;
Grant SELECT ANY DICTIONARY to chungtc;
GRANT CREATE SESSION TO chungtc;
alter user chungtc profile APPUSER;

SELECT PROFILE, LIMIT FROM DBA_PROFILES WHERE RESOURCE_NAME = 'IDLE_TIME';
SELECT PROFILE FROM DBA_USERS WHERE USERNAME = 'CHUNGTC';


Rich1234

ALTER USER thienlt ACCOUNT UNLOCK;

SQL> create user test identified by Abcd321;
User created.
SQL> grant connect,resource to test;
Grant succeeded.
- xoa user 
B2:
impdp "'/ as sysdba'" parfile=exclude.par schemas=KMTD4 JOB_NAME=IMPORT_KMTD4_2 directory=TEST_DIR dumpfile=KMTD4_SCHEMA_20131220.dmp logfile=import_schema.log remap_tablespace=KMTD_DATA:KMTD3_DATA,KMTD_INDEX:KMTD3_INDEX remap_schema=KMTD4:TEST


=============== chungtc chu y impdp song song
+ 1 bang basicfile ko partition export song song 32 luong ==> impdp ok song song 32 luong vao 1 bang ko partition tao san securefile.
Tuy nhien de y neu tren oem ko fai song song + other wait qua nhieu thi thuc ra chi la noi tiep. ( tuc la action =PX Deq: Execute Reply chu ko fai CPU)
Cach dung la convert securefile -> export song song -> import song song
co dang nay moi chuan /*+ APPEND ENABLE_PARALLEL_DML PARALLEL("ACFBNK_STMT022_TAFC_1",50)+*/
nohup  impdp  dumpuser/dumpuser123  TABLES=T24CORE.ACFBNK_AC_C001 directory=DUMP dumpfile=ACFBNK_AC_C001.%U.dmp remap_tablespace=T24DATA:T24TAFJ,T24DATANEW:T24TAFJ,T24INDEX:T24TAFJ,T24INDEXNEW:T24TAFJ remap_table=ACFBNK_AC_C001:ACFBNK_AC_C001_REP logfile=DUMP:ACFBNK_AC_C001.import.log PARALLEL=32 cluster=N exclude=statistics,index,constraint,trigger table_exists_action=append &
INSERT /*+ APPEND PARALLEL("ACFBNK_ACCO018_REP",32)+*/ INTO RELATIONAL("T24CORE"."ACFBNK_ACCO018_REP" NOT XMLTYPE) ("RECID", "XMLRECORD") 
   SELECT "RECID", SYS.XMLTYPE.CREATEXML("XMLRECORD")
    FROM "ET$0304D2030001" KU$ 
+ 1 so th bang xmltype basicfile ko partition expdp chay gan nhu hang, --> convert securefile expdp duoc song song
+ 1 bang basic file chia 32 partition export song song 32 luong ==> impdp ok song song vao db dich, ko tao table truoc
nohup  expdp  dumpuser/dumpuser123  TABLES=T24CORE.ICFBNK_STMT009 directory=DUMP dumpfile=ICFBNK_STMT009.%U.dmp logfile=DUMP:ICFBNK_STMT009.log FILESIZE=30G compression=all  PARALLEL=32 cluster=N  &
nohup  impdp  dumpuser/dumpuser123  TABLES=T24CORE.ICFBNK_STMT009 directory=DUMP dumpfile=ICFBNK_STMT009.%U.dmp remap_tablespace=T24DATA:T24TAFJ,T24DATANEW:T24TAFJ,T24INDEX:T24TAFJ,T24INDEXNEW:T24TAFJ remap_table=ICFBNK_STMT009:ICFBNK_STMT009_REP logfile=DUMP:ICFBNK_STMT009.import.log PARALLEL=16 cluster=N exclude=statistics,index,constraint,trigger &

+ bang secure file chia 32 partition, export song song 32 paralllel; nhung neu tao bang truoc, thi import van chi 1 luong
+ bang secure file chia 32 partition, export song song 32 paralllel; nhung neu KO tao bang truoc, thi import se song song duoc 32 luong
INSERT /*+ APPEND ENABLE_PARALLEL_DML PARALLEL("ACFBNK_ACCT027_REP",1)+*/ INTO RELATIONAL("T24CORE"."ACFBNK_ACCT027_REP" NOT XMLTYPE) PARTITION ( "SYS_P250614" ) ("RECID", "XMLRECORD") 
   SELECT "RECID", SYS.XMLTYPE.CREATEXML("XMLRECORD")
    FROM "DUMPUSER"."ET$0E1054080001" KU$ 
+ Bang basicfile da chia partition, export duoc song song, nhung neu tao bang partition truoc se ko import song song duoc	
--------ktra job dump dang chay: 
SELECT owner_name, job_name, operation, job_mode,
state, attached_sessions
FROM dba_datapump_jobs
WHERE job_name NOT LIKE 'BIN$%'
ORDER BY 1,2;
kill job dump dang chay
SET serveroutput on
SET lines 100
DECLARE
   h1 NUMBER;
BEGIN
  -- Format: DBMS_DATAPUMP.ATTACH('[job_name]','[owner_name]');
   h1 := DBMS_DATAPUMP.ATTACH('','T24CORE');
   DBMS_DATAPUMP.STOP_JOB (h1,1,0);
END;
/ 

-- hoac
 expdp system/Tiennhieudelamgi#2018@ccs attach=SYS_EXPORT_TABLE_03

 KILL_JOB
 
 [Ctrl-c]
Export> KILL_JOB
..or..
Export> STOP_JOB=IMMEDIATE
Are you sure you wish to stop this job ([yes]/no): yes


----------kiem tra status job dump
 impdp "'/ as sysdba'"  attach=SYS_IMPORT_TABLE_03
 impdp dumpuser/dumpuser123 attach=SYS_IMPORT_TABLE_03

 ================= select time format ===================
alter session set nls_date_format = 'DD-MON-YYYY HH24:MI:SS';
select open_time from v$thread ;

OPEN_TIME
--------------------
23-AUG-2019 09:18:17
========== chungtc phan chia truong KMTD=================
-- bảng tạm f chỉ gồm string, ngăn cách bởi dấu ,
with f as (
select head_number from    i_in_msisdn_range
 where in_name='HN1')
Select Regexp_Substr(head_number
                     ,'[^,]+'
                     ,1
                     ,Level) Emp_Name 
from f                    
Connect By Regexp_Substr(head_number
                         ,'[^,]+'
                         ,1
                         ,Level) Is Not Null;
============= chungtc , chia truong theo dau , ======================
#4092837,452019142262233,905125556,10,TSBS,07/04/2019 16:44:36,92,0,0,443935208110,200,29/10/2012#
SELECT  REGEXP_SUBSTR (message, '[^,]+', 1, 3)    AS part_1
,       REGEXP_SUBSTR (message, '[^,]+', 1, 6)    AS part_2
,       REGEXP_SUBSTR (message, '[^,]+', 1, 11)    AS part_3
FROM    c_fastpay_message_logs;
========= chungtc sqlnet.log
ORACLE_HOME=/db/oracle/11.2.0/dbhome_1
/db/oracle/11.2.0/dbhome_1/network/log/sqlnet.log
--- rename index partition
ALTER INDEX RPTTB_LN_CLFN_BRANCH_CODE_IDX RENAME PARTITION  RPTTB_LN_CLASSIFICATION_NEW TO RPTTB_LN_CLASSIFICATION_052020;
------------ Hung MB add column for goldengate
RAW(32)                           DEFAULT sys_guid(),
------------Change column table----------------------------
   ALTER TABLE chungtc_prepaid 
   modify  STT varchar2(100)
      
alter table CHUNGTC_PREPAID rename column STT to result;

ALTER TABLE supplier  --- add column
  ADD supplier_name varchar2(50);
  
============ chungtc create partition interval 
alter table APPS.MB_VN_LICHTRAGOC_his set interval(NUMTOYMINTERVAL(1, 'MONTH'));
INTERVAL( NUMTODSINTERVAL(1, 'DAY'))

PARTITION BY RANGE (TRANS_DATE)
INTERVAL( NUMTODSINTERVAL(1, 'DAY'))
(  
  PARTITION PART_201701 VALUES LESS THAN (TO_DATE(' 2017-02-01 00:00:00', 'SYYYY-MM-DD HH24:MI:SS', 'NLS_CALENDAR=GREGORIAN'))
)  

PARTITION BY RANGE (TRANSACTION_DATE)
INTERVAL( NUMTOYMINTERVAL(1, 'MONTH'))
(  
  PARTITION PART_base VALUES LESS THAN (TO_DATE(' 2016-04-01 00:00:00', 'SYYYY-MM-DD HH24:MI:SS', 'NLS_CALENDAR=GREGORIAN'))
) 
============ chungtc create partition by list===========================
CREATE TABLE chungtc_test
      (deptno number, 
       deptname varchar2(20)
       
       )
   PARTITION BY LIST (deptno)
      (PARTITION P_1 VALUES (1),
      PARTITION P_2 VALUES (2),
       PARTITION P_1000 VALUES (1000)
       );
ALTER TABLE chungtc_test ADD PARTITION  P_3 VALUES  (3);

drop table chungtc_test purge;
=============drop tempfile =================
alter database tempfile '+DATA/msbstb/tempfile/temp3.316.1009462989' drop including datafiles;

--------------
 ALTER DATABASE  datafile 770 AUTOEXTEND ON NEXT 1G   MAXSIZE UNLIMITED;
==============chungtc create partitiion ============
ALTER TABLE  gw_orequest  ADD PARTITION DATA20180924 VALUES LESS THAN (TO_DATE(' 2018-09-25 00:00:00', 'SYYYY-MM-DD HH24:MI:SS', 'NLS_CALENDAR=GREGORIAN')) TABLESPACE GW_LOGGING
ALTER TABLE  gw_orequest  ADD PARTITION DATA20180925 VALUES LESS THAN (TO_DATE(' 2018-09-26 00:00:00', 'SYYYY-MM-DD HH24:MI:SS', 'NLS_CALENDAR=GREGORIAN')) TABLESPACE GW_LOGGING

================== sun cluster =============================================
scstat -p    Check the status of cluster components. 
cluster status Check the status of cluster components
================================PURPOSE OF CHECKPOINTS==================================
mọi thay đổi được ghi vào redobuffer 0 thuộc db buffer cache, khi commit thì thay đổi này sẽ được LGWR được ghi xuống redolog files 
Bởi vì LGWR ghi 1 cách đồng bộ và chỉ ghi theo dạng vector thay đổi nên rất nhanh.
các thay đổi này sẽ DBWR được ghi vào datafile khi xảy ra checkpoint trigger.
Có rất nhiều dạng check point: có thể xảy ra khi logswitch giữa các redologfile, 
khi chạy lệnh alter system checkpoint, alter database close, sau khi recovery database-tbs...

Checkpoints occur whether or not filled online redo log files are archived. If archiving is disabled, a checkpoint affecting an online redo log file must complete before the online redo log file can be reused by LGWR. If archiving is enabled, a checkpoint must complete and the filled online redo log file must be archived before it can be reused by LGWR.

Checkpoints can occur for all datafiles of the database (called database checkpoints) or can occur for only specific datafiles. The following list explains when checkpoints occur and what type happens in each situation:

A database checkpoint automatically starts at every log switch. If a previous database checkpoint is currently in progress, a checkpoint forced by a log switch overrides the current checkpoint.
An initialization parameter, LOG_CHECKPOINT_INTERVAL, can be set to force a database checkpoint when a predetermined number of redo log blocks have been written to disk relative to the last database checkpoint. You can set another parameter, LOG_CHECKPOINT_TIMEOUT, to force a database checkpoint a specific number of seconds after the previous database checkpoint started. These parameters are useful when extremely large redo log files are used and additional checkpoints are desired between log switches. Database checkpoints signaled to start by these initialization parameters are not performed until the previous checkpoint has completed.
When the beginning of an online tablespace backup is indicated, a checkpoint is forced only on the datafiles that constitute the tablespace being backed up. A checkpoint at this time overrides any previous checkpoint still in progress. Also, since this type of checkpoint only affects the datafiles being backed up, it does not reduce the amount of redo that would be needed for instance recovery.
If the administrator takes a tablespace offline with normal or temporary priority, a checkpoint is forced only on the online datafiles of that tablespace.
If the database administrator shuts down an instance (NORMAL or IMMEDIATE shutdown transaction), Oracle forces a database checkpoint to complete before the instance is shut down. A database checkpoint forced by instance shutdown overrides any previously running checkpoint.
The database administrator can force a database checkpoint to happen on demand. A checkpoint forced on demand overrides any previously running checkpoint.

===========================-----------TIMESTEN CHUNGTC VASP================================ -----------------
/app/TimesTenHA/TimesTen/TT_VASP/bin/ttIsql "dsn=TT_VASP;uid=vasp4_owner;pwd=vasp";
ttIsql "DSN=repcluster;UID=cacheuser;PWD=mypsswrd;OraclePWD=mypsswrd"
call ttconfiguration;
CALL TTCONFIGURATION ('PermSize'); xem cau hinh cua timesten datastore hien tai
ttSchema <DSN>: cho ta thay all DDL cua database timesten
>monitor;  xem thong tin thong ke cua timesten
./ttversion -- check version
thong thuong trong /app/TimesTen/tt1122/info/ se luu file sys.odbc.ini chua cac tham so cache.. cua timesten
 /app/TimesTen/tt1122/info/ttendaemon.options cung se luu thong tin server port, TNS cua timesten
../bin/ttstatus -- xem duoc port cua Timesten server, cac tham so khac
ttAdmin -query cachedbtestdr  -- xem duoc ram policy cua timesten database cachedbtestdr
ttIsql "DSN=cachedbtestdr;UID=cacheuser;PWD=mypsswrd;OraclePWD=mypsswrd"
ALTER CACHE GROUP CACHEUSER.center SET AUTOREFRESH INTERVAL 5 SECONDS;
ALTER CACHE GROUP CACHEUSER.center SET AUTOREFRESH STATE PAUSEd/ON;
LOAD CACHE GROUP CACHEUSER.center COMMIT EVERY 256 ROWS; : sẽ load các bản ghi từ oracle mà chưa có lên timesten, những bản ghi mà có sẵn trên timesten sẽ ko được update/delete gì mặc dù dưới oracle đã bị update/delete rồi.
FLUSH CACHE GROUP	Propagate committed updates on the TimesTen cache tables to the cached Oracle Database tables. Only applicable for user managed cache groups.
REFRESH CACHE GROUP CACHEUSER.center COMMIT EVERY 256 ROWS; : sẽ là thực hiện update các thay đổi từ oracle lên timesten.
UNLOAD CACHE GROUP CACHEUSER.center ;
DROP CACHE GROUP cacheuser.REGIONS;

describe HR.REGIONS;
dssize ; -- ktra dung luong tren mem cua database timesten

-- vi du tao 1 bang tren timesten
CREATE TABLE "CACHEUSER"."JOBS" ( 
"JOB_ID" varchar2(10 byte),
"JOB_TITLE" varchar2(35 byte) NOT NULL,
"MIN_SALARY" number(6,0),
"MAX_SALARY" number(6,0)
 )
---------------------KMTD ----------------------------
export ORACLE_SID=kmtd
export ORACLE_HOME=/u02/oracle/102
export PATH=$PATH:$ORACLE_HOME/bin
/u02/oracle/102/dbs/init.ora
++++++++++++++++++ RMAN tuning ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
FILESPERSET 64  => so file trong 1 backupset ( backupset la khai niem logical, backuppiece la file physical sinh ra thuoc ve backupset)
MAXOPENFILES 8 => so file duoc read dong thoi trong 1 channel backup
=> Level of multiplexing = so file duoc doc dong thoi roi ghi vao 1 file backup
= minimum ( maxopenfiles va number of file in each backup piece ( min fileperset va number of files read by each channel)

---8388608	9  : filesperset=4

--so file INPUT = channel x min(filesperset, maxopenfiles )
select type, status, filename, buffer_size, buffer_count
    from v$backup_async_io
    where type <> 'AGGREGATE'
  and status = 'IN PROGRESS'
  and type='INPUT'
  
/* Formatted on 9/6/2020 8:33:07 PM (QP5 v5.287) */
  SELECT io_count,
         ready,
         short_waits,
         long_waits,
         long_waits / io_count,
         filename
    FROM v$backup_async_io
ORDER BY long_waits / io_count DESC;
--elapsed_time: theo 1/100 giay
  SELECT device_type "Device",
         TYPE,
         filename,
         TO_CHAR (open_time, 'mm/dd/yyyy hh24:mi:ss') open,
         TO_CHAR (close_time, 'mm/dd/yyyy hh24:mi:ss') close,
         elapsed_time ET,
         effective_bytes_per_second EPS
    FROM v$backup_async_io
ORDER BY close_time DESC;

----xem backup rman sap xong chua 
SELECT SID, SERIAL#, CONTEXT, SOFAR, TOTALWORK,
       ROUND(SOFAR/TOTALWORK*100,2) "%_COMPLETE"
FROM V$SESSION_LONGOPS
WHERE OPNAME LIKE 'RMAN%'
  AND OPNAME NOT LIKE '%aggregate%'
  AND TOTALWORK != 0
  AND SOFAR <> TOTALWORK
;  

/* Formatted on 9/6/2022 4:30:09 PM (QP5 v5.287) */
COLUMN ch FORMAT a30;

COLUMN sofar FORMAT a20;

COLUMN totalwork FORMAT a20;

COLUMN TIME_REMAINING FORMAT a20;

COLUMN ELAPSED_SECONDS FORMAT a20;

SET LINESIZE 32767;



  SELECT s.inst_id,
         o.sid,
         CLIENT_INFO ch,
         context,
         TO_CHAR (sofar) sofar,
         TO_CHAR (totalwork) totalwork,
         ROUND (sofar / totalwork * 100, 2) "% Complete",
         CASE
            WHEN o.TIME_REMAINING > 3600
            THEN
               ROUND (o.TIME_REMAINING / (3600), 2) || ' H'
            WHEN o.TIME_REMAINING BETWEEN 60 AND 3600
            THEN
               ROUND (o.TIME_REMAINING / (60), 2) || ' M'
            ELSE
               o.TIME_REMAINING || ' S'
         END
            TIME_REMAINING,
         CASE
            WHEN o.ELAPSED_SECONDS > 3600
            THEN
               ROUND (o.ELAPSED_SECONDS / (3600), 2) || ' H'
            WHEN o.ELAPSED_SECONDS BETWEEN 60 AND 3600
            THEN
               ROUND (o.ELAPSED_SECONDS / (60), 2) || ' M'
            ELSE
               o.ELAPSED_SECONDS || ' S'
         END
            ELAPSED_SECONDS
    FROM gv$session_longops o, gv$session s
   WHERE     opname LIKE 'RMAN%'
         AND o.sid = s.sid
         AND totalwork != 0
         AND sofar <> totalwork
ORDER BY 7 DESC;
============ detach grid home ==================
grid#/u01/app/11.2.0/crs/deinstall/deinstall
hoac lam tren tung node
grid#/app/newrac/grid12_1_0_2/deinstall/deinstall -local

-- oracle 12c
perl /db/soft/122/crs/install/rootcrs.pl -verbose -deconfig -force

If you get errors for some files that they could not be deleted then you can remove it manually after the above script finishes.
============chungtc check table growth
select   obj.owner, obj.object_name, 
         to_char(sn.BEGIN_INTERVAL_TIME,'RRRR-MON-DD') start_day,
         sum(a.SPACE_USED_DELTA)/1024/1024 block_increase_mbytes
from     dba_hist_seg_stat a,
         dba_hist_snapshot sn,
         dba_objects obj
where    sn.snap_id = a.snap_id
and      obj.object_id = a.obj#
and      obj.owner not in ('SYS','SYSTEM')
and      end_interval_time between to_timestamp('01-JUL-2019','DD-MON-RRRR') 
         and to_timestamp('30-JUL-2019','DD-MON-RRRR')
         and object_name='BC_TRANSFER_HISTORY'
group by obj.owner, obj.object_name, 
         to_char(sn.BEGIN_INTERVAL_TIME,'RRRR-MON-DD')
order by START_DAY
/

select * from
(SELECT o.OWNER , o.OBJECT_NAME , o.SUBOBJECT_NAME , o.OBJECT_TYPE ,
    t.NAME "Tablespace", s.growth/(1024*1024) "Growth in MB",
    (SELECT sum(bytes)/(1024*1024*1024)
    FROM dba_segments
    WHERE segment_name=o.object_name) "Total Size(GB)"
FROM DBA_OBJECTS o,
    ( SELECT TS#,OBJ#,
        SUM(SPACE_USED_DELTA) growth
   FROM DBA_HIST_SEG_STAT
    GROUP BY TS#,OBJ#
    HAVING SUM(SPACE_USED_DELTA) > 0
    ORDER BY 2 DESC ) s,
    v$tablespace t
WHERE s.OBJ# = o.OBJECT_ID
AND s.TS#=t.TS# and o.owner='T24' and o.object_type='TABLE'
ORDER BY 6 DESC) where rownum<20;
=================== object growth trend
select *  from
 DBMS_SPACE.OBJECT_GROWTH_TREND (object_owner=>'ATMLOG',
    object_name=>'CARD_TRANS_HIS',
    object_type=>'TABLE');
=================== segment advisor

SET SERVEROUTPUT ON SIZE 1000000
SET LINESIZE 200
SET VERIFY OFF

DECLARE
  l_object_id     NUMBER;
  l_task_name     VARCHAR2(32767) := 'SEGMENT_ADVISOR_TASK';
  l_object_type   VARCHAR2(32767) := UPPER('TABLE');  -- INDEX
  l_attr1         VARCHAR2(32767) := UPPER('CRM_CUSTOMER');	-- SCHEMANAME
  l_attr2         VARCHAR2(32767) := UPPER('PRODUCT_DETAIL'); --TABLENAME
BEGIN
  IF l_attr2 = 'NULL' THEN
    l_attr2 := NULL;
  END IF;

  DBMS_ADVISOR.create_task (
    advisor_name      => 'Segment Advisor',
    task_name         => l_task_name);

  DBMS_ADVISOR.create_object (
    task_name   => l_task_name,
    object_type => l_object_type,
    attr1       => l_attr1,
    attr2       => l_attr2,
    attr3       => NULL,
    attr4       => 'null',
    attr5       => NULL,
    object_id   => l_object_id);

  DBMS_ADVISOR.set_task_parameter (
    task_name => l_task_name,
    parameter => 'RECOMMEND_ALL',
    value     => 'TRUE');

  DBMS_ADVISOR.execute_task(task_name => l_task_name);


  FOR cur_rec IN (SELECT f.impact,
                         o.type,
                         o.attr1,
                         o.attr2,
                         f.message,
                         f.more_info
                  FROM   dba_advisor_findings f
                         JOIN dba_advisor_objects o ON f.object_id = o.object_id AND f.task_name = o.task_name
                  WHERE  f.task_name = l_task_name
                  ORDER BY f.impact DESC)
  LOOP
    DBMS_OUTPUT.put_line('..');
    DBMS_OUTPUT.put_line('Type             : ' || cur_rec.type);
    DBMS_OUTPUT.put_line('Attr1            : ' || cur_rec.attr1);
    DBMS_OUTPUT.put_line('Attr2            : ' || cur_rec.attr2);
    DBMS_OUTPUT.put_line('Message          : ' || cur_rec.message);
    DBMS_OUTPUT.put_line('More info        : ' || cur_rec.more_info);
  END LOOP;

  DBMS_ADVISOR.delete_task(task_name => l_task_name);
EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.put_line('Error            : ' || DBMS_UTILITY.format_error_backtrace);
    DBMS_ADVISOR.delete_task(task_name => l_task_name);
END;
/

=================== run tuning advisor
DECLARE job BINARY_INTEGER := :job;  next_date TIMESTAMP WITH TIME ZONE := :mydate;  broken BOOLEAN := FALSE;  job_name VARCHAR2(30) := :job_name;  job_subname VARCHAR2(30) := :job_subname;  job_owner VARCHAR2(30) := :job_owner;  job_start TIMESTAMP WITH TIME ZONE := :job_start;  job_scheduled_start TIMESTAMP WITH TIME ZONE := :job_scheduled_start;  window_start TIMESTAMP WITH TIME ZONE := :window_start;  window_end TIMESTAMP WITH TIME ZONE := :window_end;  chain_id VARCHAR2(14) :=  :chainid;  credential_owner varchar2(30) := :credown;  credential_name  varchar2(30) := :crednam;  destination_owner varchar2(30) := :destown;  destination_name varchar2(30) := :destnam;  job_dest_id varchar2(14) := :jdestid;  log_id number := :log_id;  BEGIN  DECLARE
         ename             VARCHAR2(30);
         exec_task         BOOLEAN;
       BEGIN
         -- check if tuning pack is enabled
         exec_task := prvt_advisor.is_pack_enabled(
                        dbms_management_packs.TUNING_PACK);

         -- check if we are in a pdb,
         -- since auto sqltune is not run in a pdb
         IF (exec_task AND -- tuning pack enabled
         sys_context('userenv', 'con_id') <> 0 AND -- not in non-cdb
         sys_context('userenv', 'con_id') <> 1  ) THEN -- not in root
           exec_task := FALSE;
         END IF;

         -- execute auto sql tuning task
         IF (exec_task) THEN
           ename := dbms_sqltune.execute_tuning_task(
                      'SYS_AUTO_SQL_TUNING_TASK');
         END IF;

         -- check whether we are in non-CDB or a PDB
         -- auto SPM evolve only runs in a non-CDB or a PDB, not the root.
         IF (sys_context('userenv', 'con_id') = 0 OR
             sys_context('userenv', 'con_id') > 2) THEN
           exec_task := TRUE;
         ELSE
           exec_task := FALSE;
         END IF;

         -- execute auto SPM evolve task
         IF (exec_task) THEN
           ename := dbms_spm.execute_evolve_task('SYS_AUTO_SPM_EVOLVE_TASK');
         END IF;
       END;  :mydate := next_date; IF broken THEN :b := 1; ELSE :b := 0; END IF; END;
++++++++++ a Hoc ATNA check uptime db/grid +++++++++++
--- check uptime db
select 
   'Hostname : ' || host_name
   ,'Instance Name : ' || instance_name
   ,'Started At : ' || to_char(startup_time,'DD-MON-YYYY HH24:MI:SS') stime
   ,'Uptime : ' || floor(sysdate - startup_time) || ' days(s) ' ||
   trunc( 24*((sysdate-startup_time) - 
   trunc(sysdate-startup_time))) || ' hour(s) ' ||
   mod(trunc(1440*((sysdate-startup_time) - 
   trunc(sysdate-startup_time))), 60) ||' minute(s) ' ||
   mod(trunc(86400*((sysdate-startup_time) - 
   trunc(sysdate-startup_time))), 60) ||' seconds' uptime
from 
   sys.v_$instance; 
--- check uptime asm
select 
   'Hostname : ' || host_name
   ,'Instance Name : ' || instance_name
   ,'Started At : ' || to_char(startup_time,'DD-MON-YYYY HH24:MI:SS') stime
   ,'Uptime : ' || floor(sysdate - startup_time) || ' days(s) ' ||
   trunc( 24*((sysdate-startup_time) - 
   trunc(sysdate-startup_time))) || ' hour(s) ' ||
   mod(trunc(1440*((sysdate-startup_time) - 
   trunc(sysdate-startup_time))), 60) ||' minute(s) ' ||
   mod(trunc(86400*((sysdate-startup_time) - 
   trunc(sysdate-startup_time))), 60) ||' seconds' uptime
from 
   v$instance;
=================== bitmap vs b-tree index ===========================
- bitmap index tot cho query AND OR XOR
- Voi query co truong null, bitmap co loi hon   
====================cluster factor index =============================
===ly thuyet cluster factor:
- la 1 thong so the hien thu tu tren index co dong nhat voi thu tu tren table hay ko?
- index exelence la index co CF/numrow < 5%  hoac: CF cua index tuong duong voi number blocks of table.
- Tham so CF lien quan toi index range scan: voi cac leaf value cua index, cang it block cua rowid tren table duoc doc -> loi ve IO. Neu cao qua Oracle se chon FullScan
=== check cluster factor
select count(1) clustering_factor
from
(
select dbms_rowid.rowid_block_number(rowid) block_no,
STATUS,IS_BATCH,
count(1) num_rows,
LAG(dbms_rowid.rowid_block_number(rowid))
over (order by STATUS,IS_BATCH) prev_block
from ibs.test2_history
group by dbms_rowid.rowid_block_number(rowid),
STATUS,IS_BATCH 
order by STATUS,IS_BATCH
)
where block_no<>prev_block or prev_block is null

 ======================= chungtc monitor index ====================
 SELECT index_name,
       table_name,
       monitoring,
       used,
       start_monitoring,
       end_monitoring
FROM   v$object_usage
WHERE  index_name = 'IDX$$_37FB0001'
ORDER BY index_name;

SELECT index_name,
       table_name,
       monitoring,
       used,
       start_monitoring,
       end_monitoring
FROM   dba_object_usage;

ALTER INDEX IBS.IDX$$_37FB0001 MONITORING USAGE;

ALTER INDEX IBS.IDX$$_37FB0001 NOMONITORING USAGE;

select 
do.owner,
t.name table_name, io.name index_name,
decode(bitand(i.flags, 65536), 0, 'NO', 'YES') monitoring,
decode(bitand(ou.flags, 1), 0, 'NO', 'YES') used,
ou.start_monitoring,
ou.end_monitoring 
from 
sys.obj$ io, 
sys.obj$ t, 
sys.ind$ i, 
sys.object_usage ou,
dba_objects do 
where i.obj# = ou.obj# 
and io.obj# = ou.obj# 
and t.obj# = i.bo#
and i.obj# = do.object_id
order by 1, 2, 3;

select module,parsing_schema_name,a.sql_id,object_name,a.sql_text,options,projection,a.last_Active_time 
from v$sqlarea a, v$sql_plan b where object_name='BC_TRANSFER_HIST_IDX'
and a.sql_id=b.sql_id 
and a.plan_hash_value=b.plan_hash_value;

======================== chungtc check sql_id all ====================================================
  select query_runs.*,
                round ( (end_time - start_time) * 24, 2) as duration_hrs
           from (  select u.username,
                          ash.program,
                          ash.sql_id,
                          ash.sql_plan_hash_value as plan_hash_value,
                          ash.session_id as sess#,
                          ash.session_serial# as sess_ser,
                          cast (min (ash.sample_time) as date) as start_time,
                          cast (max (ash.sample_time) as date) as end_time
                     from dba_hist_active_sess_history ash, dba_users u
                    where u.user_id = ash.user_id and ash.sql_id = lower(trim('2w2k41kxrscf0'))
                 group by u.username,
                          ash.program,
                          ash.sql_id,
                          ash.sql_plan_hash_value,
                          ash.session_id,
                          ash.session_serial#) query_runs
order by sql_id, start_time; 


select a.instance_number inst_id, a.snap_id,a.plan_hash_value, to_char(begin_interval_time,'dd-mon-yy hh24:mi') btime, abs(extract(minute from (end_interval_time-begin_interval_time)) + extract(hour from (end_interval_time-begin_interval_time))*60 + extract(day from (end_interval_time-begin_interval_time))*24*60) minutes,
executions_delta executions, round(ELAPSED_TIME_delta/1000000/greatest(executions_delta,1),4) "avg duration (sec)" from dba_hist_SQLSTAT a, dba_hist_snapshot b
where sql_id='2w2k41kxrscf0' and a.snap_id=b.snap_id
and a.instance_number=b.instance_number
order by snap_id desc, a.instance_number;  


select * from v$sqltext where sql_id ='8gbut3njp6kgw';
SELECT * FROM DBA_HIST_SQLTEXT WHERE SQL_ID='djcdscsg1tqgk';  
 SELECT 
  sql_id,
  t.sql_text sql_text,  
  b.name bind_name,
  b.value_string bind_value 
FROM
  v$sql t 
JOIN
  v$sql_bind_capture b  using (sql_id)
WHERE
  b.value_string is not null  
AND
  sql_id='bn6fmhv4j9bkq';
  
  select program,module,machine,b.username,c.sql_text,a.* from DBA_HIST_ACTIVE_SESS_HISTORY a ,DBA_USERS b , DBA_HIST_SQLTEXT c 
where a.sql_id='2w2k41kxrscf0'  
and a.user_id =b.user_id and a.sql_id = c.sql_id order by a.sample_time desc;

select * from gv$session where sql_id='	0dxgg64fvm43w' ;
select * from gV$ACTIVE_SESSION_HISTORY where sql_id='	0dxgg64fvm43w' ;
select * from gV$SESSION_CONNECT_INFO where sid=805;



select * from DBA_HIST_ACTIVE_SESS_HISTORY where   sql_id='	0dxgg64fvm43w' order by sample_time desc;
SELECT * from gV$SQL WHERE SQL_ID='	0dxgg64fvm43w';

===============================================================================================
================chungtc check sql_id con cua sql_id cha con================
select * from DBA_HIST_ACTIVE_SESS_HISTORY where session_id ='395' and session_serial#='25199' and top_level_sql_id ='5kr25b25ga907';
select * from gv$ACTIVE_SESSion_HISTORY where top_level_sql_id ='a279wsnummrr1';

================= check sql time chay xong
---
select query_runs.*,
                round ( (end_time - start_time) * 24, 2) as duration_hrs
           from (  select u.username,
                          ash.program,
                          ash.sql_id,
                          ash.sql_plan_hash_value as plan_hash_value,
                          ash.session_id as sess#,
                          ash.session_serial# as sess_ser,
                          cast (min (ash.sample_time) as date) as start_time,
                          cast (max (ash.sample_time) as date) as end_time
                     from dba_hist_active_sess_history ash, dba_users u
                    where u.user_id = ash.user_id and ash.sql_id = lower(trim('ghhxht6xdn9ku'))
                 group by u.username,
                          ash.program,
                          ash.sql_id,
                          ash.sql_plan_hash_value,
                          ash.session_id,
                          ash.session_serial#) query_runs
order by sql_id, start_time; 


select a.instance_number inst_id, a.snap_id,a.plan_hash_value, to_char(begin_interval_time,'dd-mon-yy hh24:mi') btime, abs(extract(minute from (end_interval_time-begin_interval_time)) + extract(hour from (end_interval_time-begin_interval_time))*60 + extract(day from (end_interval_time-begin_interval_time))*24*60) minutes,
executions_delta executions, round(ELAPSED_TIME_delta/1000000/greatest(executions_delta,1),4) "avg duration (sec)" from dba_hist_SQLSTAT a, dba_hist_snapshot b
where sql_id='332usn0dg9fw5' and a.snap_id=b.snap_id
and a.instance_number=b.instance_number
order by snap_id desc, a.instance_number;    

select executions_total,executions_delta,rows_processed_total,rows_processed_delta,elapsed_time_total,elapsed_time_delta from dba_hist_sqlstat where sql_id ='bn6fmhv4j9bkq' and snap_id=142824;
 WITH snaps
     AS (SELECT instance_number, snap_id
           FROM dba_hist_snapshot
          WHERE begin_interval_time > SYSDATE - 30)
  SELECT                                                  
        rs.*,
         SUM (executions_delta)
         OVER (PARTITION BY TRUNC (TO_DATE (snap_time, 'dd-mon-rr hh24:mi')))
            AS execs_this_day,
         SUM (buffer_gets_delta)
         OVER (PARTITION BY TRUNC (TO_DATE (snap_time, 'dd-mon-rr hh24:mi')))
            AS gets_this_day
    FROM (SELECT snap_id,
                 (SELECT TO_CHAR (MIN (begin_interval_time),
                                  'dd-mon-rr hh24:mi')
                    FROM dba_hist_snapshot
                   WHERE     snap_id = s.snap_id
                         AND instance_number = s.instance_number)
                    snap_time,
                 instance_number inst_id,
                 parsing_schema_name schema,
                 sql_id,
                 sql_profile,
                 plan_hash_value plan_hash,
                 rows_processed_delta rows_delta,
                 buffer_gets_delta,
                 executions_delta,
                 ROUND (
                      elapsed_time_delta
                    / 1000000
                    / DECODE (executions_delta, 0, 1, executions_delta),
                    2)
                    secs_per_exec,
                 ROUND (
                      buffer_gets_delta
                    / DECODE (executions_delta, 0, 1, executions_delta))
                    gets_per_exec
            FROM dba_hist_sqlstat s
           WHERE     sql_id = '9a55m3svakhpq'---------------------------------------------
                 AND (instance_number, snap_id) IN (SELECT /*+no_unnest*/
                                                          instance_number,
                                                           snap_id
                                                      FROM snaps)) rs
ORDER BY TO_DATE (snap_time, 'dd-mon-rr hh24:mi') DESC

SELECT sql_patch,plan_hash_value, sql_profile,last_load_time,SQL_ID,EXECUTIONS,ELAPSED_TIME/1000/1000,CPU_TIME,ELAPSED_TIME/1000/1000/EXECUTIONS average_time FROM
gV$SQL WHERE SQL_ID='f7tp3s5w1xuzn';
=== chungtc find sql_text
select sql_text from gv$sqlarea where sql_id='cb87am2xpdvq4';

select sql_text from dba_hist_sqltext where sql_id='cb87am2xpdvq4';

========== find sql not use bind variable
select * from gv$sqlarea where sql_text like 'select TRACE_NUMBER from SML_TRANSFER%' order by last_load_time desc;

	Select * 
from (
With subs as
(SELECT /*+ materialize */
m.sql_id, k.*, m.SQL_TEXT, m.SQL_FULLTEXT
FROM (SELECT inst_id,
parsing_schema_name AS user_name,
module,
plan_hash_value,
COUNT(0) copies,
SUM(executions) executions,
SUM(round(sharable_mem / (1024 * 1024), 2)) sharable_mem_mb
FROM gv$sqlarea
WHERE executions < 5
AND kept_versions = 0
GROUP BY inst_id, parsing_schema_name, module, plan_hash_value
HAVING COUNT(0) > 10
ORDER BY COUNT(0) DESC) k
LEFT JOIN gv$sqlarea m
ON k.plan_hash_value = m.plan_hash_value
WHERE k.plan_hash_value > 0)
select distinct ki.inst_id,
t.sql_id,
ki.sql_text,
t.plsql_procedure,
ki.user_name,
sum(ki.copies) copies,
sum(ki.executions) executions,
sum(ki.sharable_mem_mb) sharable_mem_mb
from (select sql_id,
program_id,
program_line#,
action,
module,
service,
parsing_schema_name,
round(buffer_gets / decode(executions, 0, 1, executions)) buffer_per_Exec,
row_number() over(partition by sql_id order by program_id desc, program_line#) sira,
decode(program_id,
0,
null,
owner || '.' || object_name || '(' || program_line# || ')') plsql_procedure
from gv$sql a, dba_objects b
where a.program_id = b.object_id(+)) t,
subs ki
where ki.sql_id = t.sql_id
and t.sira = 1
and sql_text like 'select TRACE_NUMBER from SML_TRANSFER%'
group by ki.inst_id,
t.sql_id,
ki.sql_text,
t.plsql_procedure,
ki.user_name
order by sum(ki.executions) desc
)
where rownum < 5100;



===================  
 -- find bind variable
 SELECT 
  sql_id,
  t.sql_text sql_text,  
  b.name bind_name,
  b.value_string bind_value 
FROM
  v$sql t 
JOIN
  v$sql_bind_capture b  using (sql_id)
WHERE
  b.value_string is not null  
AND
  sql_id='854jjtn8ymq4v';
  
 SELECT 
  sql_id,
  t.sql_text sql_text,  
  b.name bind_name,
  b.value_string bind_value 
FROM
  dba_hist_sqltext t 
JOIN
  DBA_HIST_SQLBIND b  using (sql_id)
WHERE
  b.value_string is not null  
AND
  sql_id='5p7sjq6fmk67h';  
 ======================= chungtc monitor sql =========================
 https://oracle-base.com/articles/11g/real-time-sql-monitoring-11gr1
 https://www.oracle.com/technetwork/database/manageability/sql-detail-099420.html
 
 select sql_id,a.* from gv$session a where username='AMLGLBL' AND status ='ACTIVE';
select sql_id,a.* from gv$session a where sid='841' and serial#='338';
select distinct(sql_id) from gv$active_session_history where session_id='231' and session_serial#='34971';

 select sql_id,first_refresh_time,last_refresh_time,sid,sql_text,sql_plan_hash_value from v$sql_monitor where sql_id ='649c90gn3uzhk' and is_full_sqltext is not null;
 select * from V$SQL_PLAN_MONITOR where sql_id ='649c90gn3uzhk';
 
 WITH    active_sess AS (SELECT service_name,s.inst_id i#, s.username, s.sid, s.command, s.SID || ',' || s.serial# || ',@' || s.inst_id AS sid_ser#,  
DECODE (S.WAIT_TIME, 0, S.EVENT, 'CPU') ACTION, s.sql_id, CASE WHEN (SYSDATE - SQL_EXEC_START) * 86400 > 60 THEN TRIM (TO_CHAR (FLOOR ((SYSDATE - SQL_EXEC_START) * 86400 / 60))) || ':' 
|| TRIM (TO_CHAR (MOD ((SYSDATE - SQL_EXEC_START) * 86400, 60), '00')) ELSE TO_CHAR (ROUND ((SYSDATE - SQL_EXEC_START) * 86400)) END sql_ela, 
CASE WHEN last_call_et > 60 THEN TRIM (TO_CHAR (FLOOR (last_call_et / 60))) || ':' || TRIM (TO_CHAR (MOD (last_call_et, 60), '00')) ELSE TO_CHAR (last_call_et) END elapse, 
s.SQL_HASH_VALUE plan_hash, s.module, s.osuser, s.machine, blocking_session || '@' || blocking_instance blk_sid, S.STATUS, PLSQL_ENTRY_OBJECT_ID, PLSQL_ENTRY_SUBPROGRAM_ID, CLIENT_INFO||'-'||CLIENT_IDENTIFIER client_id_info, s.p1text, S.P1, s.p2text, S.P2, s.p3text, S.P3 FROM GV$SESSION S 
WHERE S.STATUS NOT IN ('INACTIVE', 'SNIPED') AND (s.TYPE <> 'BACKGROUND' or s.username IS NOT NULL) and (program NOT LIKE '%(O0%' or program is  null) and ( not (PROGRAM like '%(J0%' and event like 'jobq slave wait')) ) 
SELECT service_name,sid_ser#,USERNAME, s.ACTION, SQL_ELA, ELAPSE, s.SQL_ID, SUBSTR (DECODE (SS.SQL_TEXT, NULL, AA.NAME, SS.SQL_TEXT), 1, 100) SQLTEXT, MODULE, OSUSER, MACHINE, BLK_SID, STATUS, 
PLAN_HASH, PLSQL_ENTRY_OBJECT_ID, PLSQL_ENTRY_SUBPROGRAM_ID, client_id_info, P1TEXT, P1, P2TEXT, P2, P3TEXT, P3, 'alter system kill session ''' || SID_SER# || ''' immediate;' kill_sess FROM active_sess s, V$SQLSTATS /* GV$SQLSTATS is quite slow, so we'll use V$ instead FIXED TABLE FIXED INDEX | X$KKSSQLSTAT (ind:1) */ ss, AUDIT_ACTIONS AA WHERE 1 = 1 /*s.i#=ss.inst_id*/ AND AA.ACTION(+) = S.COMMAND AND ss.sql_id(+) = s.sql_id AND i# || '#' || sid NOT IN (SELECT i# || '#' || sid FROM active_sess WHERE sql_id = (SELECT sql_id FROM active_sess WHERE i# || '#' || sid = SYS_CONTEXT ('USERENV', 'INSTANCE') || '#' || SYS_CONTEXT ('USERENV', 'SID'))) ORDER BY username, sqltext, sql_id, machine, i#;

 SELECT /* SQL monitor */ dbms_sqltune.report_sql_monitor (sql_id=>'b8r6pvn20qu6h', event_detail=>'YES', report_level=>'ALL') from dual; 
 
 -report list sql
 SET LONG 1000000
SET LONGCHUNKSIZE 1000000
SET LINESIZE 1000
SET PAGESIZE 0
SET TRIM ON
SET TRIMSPOOL ON
SET ECHO OFF
SET FEEDBACK OFF

SPOOL  report_sql_monitor_list.htm
SELECT DBMS_SQLTUNE.report_sql_monitor_list(
  type         => 'HTML',
  report_level => 'ALL') AS report
FROM dual;
SPOOL OFF

-report activity of a sql_id

set trimspool on trim on
set pages 0 linesize 1000
set long 1000000 longchunksize 1000000
spool 1bbbjhpqkcfbg.html
select dbms_sqltune.report_sql_detail('1bbbjhpqkcfbg',start_time=>to_date('2021-08-17 15:50:00','yyyy-mm-dd hh24:mi:ss'), duration=>3600) from dual;
	spool off

select dbms_sqltune.report_sql_detail('1bbbjhpqkcfbg') from dual;
select dbms_sqltune.report_sql_detail('95040',start_time=>to_date('2020-05-12 09:00:00','yyyy-mm-dd hh24:mi:ss'), duration=>7200) from dual;

SELECT DBMS_SQLTUNE.report_sql_detail(
  sql_id       => '1bbbjhpqkcfbg',
  type         => 'ACTIVE',  
  report_level => 'ALL') AS report
FROM dual;
 -- -----------12c   https://sqlmaria.com/2017/08/01/getting-the-most-out-of-oracle-sql-monitor/
 SELECT report_id,
       EXTRACTVALUE(XMLType(report_summary),'/report_repository_summary/sql/@sql_id') sql_id,
       EXTRACTVALUE(XMLType(report_summary),'/report_repository_summary/sql/@sql_exec_id') sql_exec_id,
       EXTRACTVALUE(XMLType(report_summary),'/report_repository_summary/sql/@sql_exec_start') sql_exec_start
  FROM dba_hist_reports
 WHERE component_name = 'sqlmonitor';
 
 - selelct ra report id cua 1 sql_id trong 1 khoang thoi gian
 SELECT report_id
FROM dba_hist_reports
WHERE component_name = 'sqlmonitor'
AND report_name = 'main'
AND period_start_time BETWEEN
To_date('07/07/2020 00:00:01','DD/MM/YYYY HH24:MI:SS')
AND
To_date('07/07/2020 23:15:00','DD/MM/YYYY HH24:MI:SS')
AND key1 = '1bbbjhpqkcfbg';
 
 set long 10000000 longchunksize 10000000 pages 0
SELECT DBMS_AUTO_REPORT.REPORT_REPOSITORY_DETAIL(RID => 154122, TYPE => 'text')        FROM dual;

- get report of report_id tu cau lenh tren
SET echo ON
SET trimspool ON
SET TRIM ON
SET pages 0
SET linesize 32767
SET LONG 10000000
SET longchunksize 1000000
spool 04a4spsszkyas_13.html
 
SELECT dbms_auto_report.Report_repository_detail(rid=>1820213, TYPE=>'active')  FROM dual;

spool OFF

SELECT report_id, key1 sql_id, key2 sql_exec_id, key3 sql_exec_start   FROM dba_hist_reports WHERE component_name = 'sqlmonitor'

---------ADRCI
 show home
 adrci exec="set home diag/rdbms/dbg5new/DBG51; purge -age 2"

==========================
adrci>SHOW INCIDENT
adrci>IPS CREATE PACKAGE INCIDENT <incident_number>
Created package 4 based on incident id 240385, correlation level typical

adrci>IPS ADD INCIDENT <incident_number> PACKAGE <package_number> ----> Only if you want to package multiple incidents
adrci>IPS GENERATE PACKAGE 4 IN /oracle/app/oracle

Ref: ADR Different Methods to Create IPS Package ( Doc ID 411.1 )

For multiple ADR Homes:
=======================



adrci> SHOW HOMEPATH

diag\clients\user_oracle\host_1956732839_11
diag\clients\user_system\host_1956732839_11
diag\clients\user_unknown\host_1956732839_11
diag\rdbms\orcl11g\orcl11g
diag\tnslsnr\oracle-eg\listener

adrci> SET HOMEPATH diag/rdbms/t24vn/T24COB1

------generate SQL Monitor reports for all of the SQL statements monitored during a given period of time  -- chungtc 
$ORACLE_HOME/rdbms/admin/perfhubrpt.sql

 ===================chungtc monitor sql_id  io read================
 select s.sid||','||s.serial# str, s.username, s.machine, s.osuser, t.sql_id,
       x.opname, --x.sofar, x.totalwork, 
       case when x.totalwork = 0 then 0 else round(x.sofar/x.totalwork*100,2) end complete,
       t.sql_fulltext, 'alter system kill session ''' || s.sid||','||s.serial# || ''';'
  from gv$sqlarea t,gv$session s, gv$session_longops x
 where t.address =s.sql_address
   and t.hash_value = s.sql_hash_value
   and s.status = 'ACTIVE'
   and s.sid = x.sid(+)
   and s.serial# = x.serial#(+)
   --AND s.machine NOT like 'WORKGROUP\DR-ODS-COGNOS01%'
  -- AND s.machine like 'dc-bdm-iis%'
   --and s.username ='SOR'
   and (x.sofar<>x.totalwork or x.sofar is null or x.totalwork is null)
   --AND sql_fulltext LIKE '%PST_ENTR%'
   --AND sql_fulltext LIKE '%Core_Dat_ODTIER%'
order by s.username, t.sql_id;

 select count(*), sql_id from  (
select * from gV$SQL_MONITOR
where physical_read_bytes/1024/1024/1024>5)
group by sql_id
order by count(*) desc;

select sum(physical_read_bytes/1024/1024/1024),sql_id, sql_exec_id, SQL_EXEC_START from gV$SQL_MONITOR a
where sql_id ='4tnw80pc1bttb'
group by sql_id, sql_exec_id, SQL_EXEC_START
order by SQL_EXEC_START desc;


select physical_read_bytes/1024/1024/1024,sql_id, a.* from gV$SQL_MONITOR a
where status not like 'DONE%'
order by physical_read_bytes/1024/1024/1024 desc;

 select physical_read_bytes,sql_id,PHYSICAL_READ_REQUESTS,SQL_EXEC_START, SQL_ID,  SQL_EXEC_ID,first_Refresh_time,last_Refresh_Time
,inst_id
,sql_text from GV$SQL_MONITOR a where sql_id='ah6047gkqqqn5' 
order by SQL_EXEC_START desc;

-- check sql history
select * from DBA_HIST_SQLSTAT where sql_id ='cf6zz182vquys' order by snap_id;
select * from dba_hist_snapshot;
select * from dba_hist_sqltext where sql_id ='0az7czjdw8z7j'




col c1 heading 'Begin|Interval|time'    format a8
col c2 heading 'SQL|ID'                 format a13
col c3 heading 'Exec|Delta'             format 9,999
col c4 heading 'Buffer|Gets|Delta'      format 9,999
col c5 heading 'Disk|Reads|Delta'       format 9,999
col c6 heading 'IO Wait|Delta'          format 9,999
col c7 heading 'Application|Wait|Delta' format 9,999
col c8 heading 'Concurrency|Wait|Delta' format 9,999
 break on c1
 select
  to_char(s.begin_interval_time,'mm-dd hh24')  c1,
  sql.sql_id                     c2,   
  sql.executions_delta     c3,
  sql.buffer_gets_delta    c4,
  sql.disk_reads_delta     c5,
  sql.iowait_delta            c6,
  sql.apwait_delta           c7,
  sql.ccwait_delta           c8
from
   dba_hist_sqlstat        sql,
   dba_hist_snapshot         s
where
   s.snap_id = sql.snap_id;

--
col c1 heading 'Begin|Interval|time'    format a8
col c2 heading 'Exec|Delta'             format 999,999
col c3 heading 'Buffer|Gets|Delta'      format 999,999
col c4 heading 'Disk|Reads|Delta'       format 9,999
col c5 heading 'IO Wait|Delta'          format 9,999
col c6 heading 'App|Wait|Delta'         format 9,999
col c7 heading 'Cncr|Wait|Delta'        format 9,999
col c8 heading 'CPU|Time|Delta'         format 999,999
col c9 heading 'Elpsd|Time|Delta'       format 999,999
 
accept sqlid prompt 'Enter SQL ID: '
 
ttitle 'time series execution for|&sqlid'
 
break on c1
 
select
  to_char(s.begin_interval_time,'mm-dd hh24')  c1,
  sql.executions_delta     c2,
  sql.buffer_gets_delta    c3,
  sql.disk_reads_delta     c4,
  sql.iowait_delta         c5,
  sql.apwait_delta         c6,
  sql.ccwait_delta         c7,
  sql.cpu_time_delta       c8,
  sql.elapsed_time_delta   c9
from
   dba_hist_sqlstat        sql,
   dba_hist_snapshot         s
where
   s.snap_id = sql.snap_id
and
   sql_id = '&sqlid'
order by
   c1;
-- check duoc find machine chay sql_id
select program,module,machine,b.username,c.sql_text,a.* from DBA_HIST_ACTIVE_SESS_HISTORY a ,DBA_USERS b , DBA_HIST_SQLTEXT c 
where a.sql_id='4kpnj4a2dmkjh'  
and a.user_id =b.user_id and a.sql_id = c.sql_id order by a.sample_time desc;
	
and a.user_id =b.user_id order by sample_time desc;
select port,a.* from v$session where sql_id='4xmaqx0hw5p99' ;
select * from V$ACTIVE_SESSION_HISTORY where sql_id='4xmaqx0hw5p99' ;
select * from V$SESSION_CONNECT_INFO where sid=805;

==================
++++++++++++++ kiem tra session running long time ago +++++++++++++++++++++++++++++++++
--original + pid
 SELECT  substr(a.spid,1,9) pid,                                                                                      
 sid||','||ses.serial# sid_ser,                                                                                      
        status,                                                                                                      
                                                                                                                     
     schemaname||'@'||service_name  from_where,                                                                      
     machine,                                                                                                        
        osuser,                                                                                                      
        ses.program,                                                                                                 
     NVL((select DISTINCT sql_id||','||sql_text from v$sql sql where sql.sql_id = ses.sql_id),'NOTHING GOING ON') sql_text,
     blocking_session,                                                                                               
     TO_CHAR(logon_time,'dd/mm/yyyy HH24:MM:SS AM') as from_when                                                     
   FROM v$session ses,v$process a                                                                                    
  WHERE type = 'USER' and status <>'INACTIVE'                                                                        
  and status='ACTIVE'                                                                                                
  and type <>'BACKGROUND'                                                                                            
  and ses.paddr = a.addr                                                                                             
  and last_call_et> 60                                                                                               
ORDER BY status,osuser,program;

--original
 SELECT sid||','||serial# sid_ser,
        status,
     schemaname||'@'||service_name  from_where, 
        osuser,
        program,
     NVL((select DISTINCT sql_text from v$sql sql where sql.sql_id = ses.sql_id),'NOTHING GOING ON') sql_text,
     blocking_session,
     TO_CHAR(logon_time,'dd/mm/yyyy HH24:MM:SS AM') as from_when
   FROM gv$session ses
  WHERE type = 'USER' and status <>'INACTIVE'
  and status='ACTIVE'
  and type <>'BACKGROUND'
  and last_call_et> 60
ORDER BY status,osuser,program;

----- all session
select
       substr(a.spid,1,9) pid,
       substr(b.sid,1,5) sid,
       substr(b.serial#,1,5) ser#,
       substr(b.machine,1,6) box,
       substr(b.username,1,10) username,
--       b.server,
       substr(b.osuser,1,8) os_user,
       substr(b.program,1,30) program,
            NVL((select DISTINCT sql_text from v$sql sql where sql.sql_id = b.sql_id),'NOTHING GOING ON') sql_text

from v$session b, v$process a
where
b.paddr = a.addr
and type='USER'
order by spid; 
======================= check long duration =============================================
Recipe #1 - Get details about long running operations

Run the following query and you'll get most information you need:

SELECT osuser,
       sl.sql_id,
       sl.sql_hash_value,
       opname,
       target,
       elapsed_seconds,
       time_remaining
  FROM v$session_longops sl
inner join v$session s ON sl.SID = s.SID AND sl.SERIAL# = s.SERIAL#
WHERE time_remaining > 0

Recipe #2 - Show long running SQL Statements

If you also want to see the SQL query causing the long running operation, just join v$sql like show below:

SELECT s.username,
       sl.sid,
       sq.executions,
       sl.last_update_time,
       sl.sql_id,
       sl.sql_hash_value,
       opname,
       target,
       elapsed_seconds,
       time_remaining,
       sq.sql_fulltext
  FROM v$session_longops sl
 INNER JOIN v$sql sq ON sq.sql_id = sl.sql_id
 INNER JOIN v$session s ON sl.SID = s.SID AND sl.serial# = s.serial#
 WHERE time_remaining > 0

=============== chungtc check wait 
 select  wait_class,
        event,
        total_waits AS bg_total_waits,
        time_waited_micro / 1000.0 AS time_waited_ms,
        average_wait * 10 AS average_wait_ms ,
        total_waits_fg AS fg_total_waits ,
        time_waited_micro_fg / 1000.0 AS fg_time_waited_ms ,
        average_wait_fg * 10 AS fg_average_wait_ms
from    v$system_event
where   event in ('log file parallel write','log file sync')
order by time_waited_micro desc ;

select  TIME_WAITED mywaite,wait_time, a.*
from 
   dba_hist_active_sess_history a
where
sample_time > sysdate -1
and SESSION_STATE='WAITING'
and event in ('log file parallel write','log file sync')
and blocking_Session_status  <> 'VALID'
order by mywaite desc;


select * from v$event_histogram where event in ('log file parallel write','log file sync'); 
======================chungtc performance tuning script======================
https://www.dba-scripts.com/scripts/diagnostic-and-tuning/oracle-active-session-history-ash/top-10-sessions-from-active_session_history/
----- tuning delete
DELETE A FROM (SELECT TOP (5000) * FROM A WHERE C = '123') A;
WITH CTE AS (SELECT TOP (5000) *FROM A WHERE C = '123') DELETE FROM CTE ;
DoItAgain:
DELETE TOP (1000) FROM A WHERE C = '123' IF @@ROWCOUNT > 0 
GOTO DoItAgain;

SELECT 1 WHILE @@ROWCOUNT > 0 BEGIN DELETE TOP (1000) FROM A WHERE C = '123' END


--Top Recent Wait Events
		col EVENT format a60 

		select * from (
		select active_session_history.event,
		sum(active_session_history.wait_time +
		active_session_history.time_waited) ttl_wait_time
		from v$active_session_history active_session_history
		where active_session_history.event is not null
		group by active_session_history.event
		order by 2 desc)
		where rownum < 6
		/
--Top Wait Events Since Instance Startup
		col event format a60

		select event, total_waits, time_waited
		from v$system_event e, v$event_name n
		where n.event_id = e.event_id
		and n.wait_class !='Idle'
		and n.wait_class = (select wait_class from v$session_wait_class
		 where wait_class !='Idle'
		 group by wait_class having
		sum(time_waited) = (select max(sum(time_waited)) from v$session_wait_class
		where wait_class !='Idle'
		group by (wait_class)))
		order by 3;
--------- top active session history "Top Activity" ====================================================
SELECT inst_id ,sysmetric_history.sample_time,
  cpu/60 AS cpu,
  bcpu/60 AS bcpu,
  DECODE(SIGN((cpu+bcpu)/60-cpu_ora_consumed), -1, 0, ((cpu+bcpu)/60-cpu_ora_consumed)) AS cpu_ora_wait,
  scheduler/60 AS scheduler,
  uio/60 AS uio,
  sio/60 AS sio,
  concurrency/60 AS concurrency,
  application/60 AS application,
  COMMIT/60 AS COMMIT,
  configuration/60 AS configuration,
  administrative/60 AS administrative,
  network/60 AS network,
  queueing/60 AS queueing,
  clust/60 AS clust,
  other/60 AS other
FROM
  (SELECT inst_id,
     TRUNC(sample_time,'MI') AS sample_time,
     DECODE(session_state,'ON CPU',DECODE(session_type,'BACKGROUND','BCPU','ON CPU'), wait_class) AS wait_class
   FROM gv$active_session_history
   WHERE sample_time>sysdate-INTERVAL '1' HOUR
   AND sample_time<=TRUNC(SYSDATE,'MI')) ash
   PIVOT (COUNT(*) FOR wait_class IN ('ON CPU' AS cpu,'BCPU' AS bcpu,'Scheduler' AS scheduler,'User I/O' AS uio,'System I/O' AS sio,
   'Concurrency' AS concurrency,'Application' AS application,'Commit' AS COMMIT,'Configuration' AS configuration,
   'Administrative' AS administrative,'Network' AS network,'Queueing' AS queueing,'Cluster' AS clust,'Other' AS other)) ash,
   (SELECT
      TRUNC(begin_time,'MI') AS sample_time,
      VALUE/100 AS cpu_ora_consumed
    FROM gv$sysmetric_history
    WHERE GROUP_ID=2
    AND metric_name='CPU Usage Per Sec') sysmetric_history
WHERE ash.sample_time (+)=sysmetric_history.sample_time
ORDER BY sample_time desc;	

===================== cum active session history
select wait_class_id, wait_class, count(*) cnt
from gv$active_session_history
where
sample_time between
                       to_timestamp('2021-06-30 16:06:00','YYYY-MM-DD HH24:MI:SS') and
                        to_timestamp('2021-06-30 16:08:00','YYYY-MM-DD HH24:MI:SS')
group by wait_class_id, wait_class
order by 3;

select event_id, event, count(*) cnt  from gv$active_session_history
where
sample_time between
                       to_timestamp('2021-06-30 16:06:00','YYYY-MM-DD HH24:MI:SS') and
                        to_timestamp('2021-06-30 16:08:00','YYYY-MM-DD HH24:MI:SS') and wait_class_id=3871361733
group by event_id, event
order by 3;

select sql_id, count(*) cnt  from gv$active_session_history
where
sample_time between
                       to_timestamp('2021-06-30 16:06:00','YYYY-MM-DD HH24:MI:SS') and
                        to_timestamp('2021-06-30 16:08:00','YYYY-MM-DD HH24:MI:SS')
and event_id in (111015833,
737661873,
1912606394,
2277737081)
group by sql_id
having count(*)>1000
order by 2;

select sql_text from dba_hist_sqltext where sql_id='9r865g1bcvmm8';

select count(distinct(current_obj#)) from gv$active_session_history
where
sample_time between
                       to_timestamp('2021-06-30 16:06:00','YYYY-MM-DD HH24:MI:SS') and
                        to_timestamp('2021-06-30 16:08:00','YYYY-MM-DD HH24:MI:SS')
and event_id in (111015833,
737661873,
1912606394,
2277737081) and sql_id='9r865g1bcvmm8';

select current_obj#, count(*) cnt from gv$active_session_history
where
sample_time between
                       to_timestamp('2021-06-30 16:06:00','YYYY-MM-DD HH24:MI:SS') and
                        to_timestamp('2021-06-30 16:08:00','YYYY-MM-DD HH24:MI:SS')
and event_id in (111015833,
737661873,
1912606394,
2277737081) and sql_id='9r865g1bcvmm8'
group by current_obj#
order by 2;

select object_id, owner, object_name, subobject_name, object_type from dba_objects
where
 object_id in (5201603);
====================================================	
-- top query from v$active_session_history  =================================================================================
select  a.*, b.user_id,b.top_level_sql_id,b.sql_opname,b.program,b.module,b.machine,b.port from (
select * from (
    select
         SQL_ID ,
         sum(decode(session_state,'ON CPU',1,0)) as CPU,
         sum(decode(session_state,'WAITING',1,0)) - sum(decode(session_state,'WAITING', decode(wait_class, 'User I/O',1,0),0)) as WAIT,
         sum(decode(session_state,'WAITING', decode(wait_class, 'User I/O',1,0),0)) as IO,
         sum(decode(session_state,'ON CPU',1,1)) as TOTAL
    from gv$active_session_history
    where SQL_ID is not NULL
    and sample_time >= sysdate-5/24/60   -------------------------------------------
    group by sql_id
    order by sum(decode(session_state,'ON CPU',1,1))   desc
    ) 
where rownum <11	
) a, gv$active_session_history b
where a.sql_id =b.sql_id;

SELECT sql_id,COUNT(*),ROUND(COUNT(*)/SUM(COUNT(*)) OVER(), 2) PCTLOAD
FROM gv$active_session_history
WHERE sample_time > SYSDATE - 1/24
AND session_type = 'BACKGROUND'
GROUP BY sql_id
ORDER BY COUNT(*) DESC;
SELECT sql_id,COUNT(*),ROUND(COUNT(*)/SUM(COUNT(*)) OVER(), 2) PCTLOAD
FROM gv$active_session_history
WHERE sample_time > SYSDATE - 5/24/60
AND session_type = 'FOREGROUND'
GROUP BY sql_id
ORDER BY COUNT(*) DESC;

----- top session ===================================================================================================
select * from (
select user_id,
     session_id,
	 session_serial#,
     program,
	 module,
	 action,
     sum(decode(session_state,'WAITING',0,1)) "CPU",
     sum(decode(session_state,'WAITING',1,0)) - sum(decode(session_state,'WAITING',decode(wait_class,'User I/O',1,0),0)) "WAITING" ,
     sum(decode(session_state,'WAITING',decode(wait_class,'User I/O',1,0),0)) "IO" ,
     sum(decode(session_state,'WAITING',1,1)) "TOTAL"
from gv$active_session_history 
where session_type='FOREGROUND'
and sample_time > SYSDATE - 5/24/60
group by user_id,session_id,session_serial#,module,action,program
order by sum(decode(session_state,'WAITING',1,1)) desc)
where rownum <11;
--List Of Users Currently Waiting
		col username format a12
		col sid format 9999
		col state format a15
		col event format a50
		col wait_time format 99999999
		set pagesize 100
		set linesize 120

		select s.sid, s.username, se.event, se.state, se.wait_time
		from v$session s, v$session_wait se
		where s.sid=se.sid
		and se.event not like 'SQL*Net%'
		and se.event not like '%rdbms%'
		and s.username is not null
		order by se.wait_time;
--Find The Main Database Wait Events In A Particular Time Interval
		First determine the snapshot id values for the period in question.

		In this example we need to find the SNAP_ID for the period 10 PM to 11 PM on the 14th of November, 2012.

		select snap_id,begin_interval_time,end_interval_time
		from dba_hist_snapshot
		where to_char(begin_interval_time,'DD-MON-YYYY')='14-NOV-2012'
		and EXTRACT(HOUR FROM begin_interval_time) between 22 and 23;
		
		set verify off
		select * from (
		select active_session_history.event,
		sum(active_session_history.wait_time +
		active_session_history.time_waited) ttl_wait_time
		from dba_hist_active_sess_history active_session_history
		where event is not null
		and SNAP_ID between &ssnapid and &esnapid
		group by active_session_history.event
		order by 2 desc)
		where rownum

--Top CPU Consuming SQL During A Certain Time Period
Note – in this case we are finding the Top 5 CPU intensive SQL statements executed between 9.00 AM and 11.00 AM

		select * from (
		select
		SQL_ID,
		 sum(CPU_TIME_DELTA),
		sum(DISK_READS_DELTA),
		count(*)
		from
		DBA_HIST_SQLSTAT a, dba_hist_snapshot s
		where
		s.snap_id = a.snap_id
		and s.begin_interval_time > sysdate -1
		and EXTRACT(HOUR FROM S.END_INTERVAL_TIME) between 9 and 11
		group by
		SQL_ID
		order by
		sum(CPU_TIME_DELTA) desc)
--Which Database Objects Experienced the Most Number of Waits in the Past One Hour
		set linesize 120
		col event format a40
		col object_name format a40

		select * from 
		(
		  select dba_objects.object_name,
		 dba_objects.object_type,
		active_session_history.event,
		 sum(active_session_history.wait_time +
		  active_session_history.time_waited) ttl_wait_time
		from v$active_session_history active_session_history,
			dba_objects
		 where 
		active_session_history.sample_time between sysdate - 1/24 and sysdate
		and active_session_history.current_obj# = dba_objects.object_id
		 group by dba_objects.object_name, dba_objects.object_type, active_session_history.event
		 order by 4 desc)
		where rownum < 6;
--Top Segments ordered by Physical Reads
		col segment_name format a20
		col owner format a10 
		select segment_name,object_type,total_physical_reads
		 from ( select owner||'.'||object_name as segment_name,object_type,
		value as total_physical_reads
		from v$segment_statistics
		 where statistic_name in ('physical reads')
		 order by total_physical_reads desc)

--Top 5 SQL statements in the past one hour
		select * from (
		select active_session_history.sql_id,
		 dba_users.username,
		 sqlarea.sql_text,
		sum(active_session_history.wait_time +
		active_session_history.time_waited) ttl_wait_time
		from v$active_session_history active_session_history,
		v$sqlarea sqlarea,
		 dba_users
		where 
		active_session_history.sample_time between sysdate -  1/24  and sysdate
		  and active_session_history.sql_id = sqlarea.sql_id
		and active_session_history.user_id = dba_users.user_id
		 group by active_session_history.sql_id,sqlarea.sql_text, dba_users.username
		 order by 4 desc )
		where rownum
--SQL with the highest I/O in the past one day
		select * from 
		(
		SELECT /*+LEADING(x h) USE_NL(h)*/ 
			   h.sql_id
		,      SUM(10) ash_secs
		FROM   dba_hist_snapshot x
		,      dba_hist_active_sess_history h
		WHERE   x.begin_interval_time > sysdate -1
		AND    h.SNAP_id = X.SNAP_id
		AND    h.dbid = x.dbid
		AND    h.instance_number = x.instance_number
		AND    h.event in  ('db file sequential read','db file scattered read')
		GROUP BY h.sql_id
		ORDER BY ash_secs desc )
		where rownum
--Top CPU consuming queries since past one day
		select * from (
		select 
			SQL_ID, 
			sum(CPU_TIME_DELTA), 
			sum(DISK_READS_DELTA),
			count(*)
		from 
			DBA_HIST_SQLSTAT a, dba_hist_snapshot s
		where
		 s.snap_id = a.snap_id
		 and s.begin_interval_time > sysdate -1
			group by 
			SQL_ID
		order by 
			sum(CPU_TIME_DELTA) desc)
		where rownum
--Find what the top SQL was at a particular reported time of day
First determine the snapshot id values for the period in question.

In thos example we need to find the SNAP_ID for the period 10 PM to 11 PM on the 14th of November, 2012.

		select snap_id,begin_interval_time,end_interval_time
		from dba_hist_snapshot
		where to_char(begin_interval_time,'DD-MON-YYYY')='14-NOV-2012'
		and EXTRACT(HOUR FROM begin_interval_time) between 22 and 23;
		
		select * from
		 (
		select
		 sql.sql_id c1,
		sql.buffer_gets_delta c2,
		sql.disk_reads_delta c3,
		sql.iowait_delta c4
		 from
		dba_hist_sqlstat sql,
		dba_hist_snapshot s
		 where
		 s.snap_id = sql.snap_id
		and
		 s.snap_id= &snapid
		 order by
		 c3 desc)
		 where rownum < 6 
		/
--Analyse a particular SQL ID and see the trends for the past day
		select
 s.snap_id,
 to_char(s.begin_interval_time,'HH24:MI'),
 sql.executions_delta ,
 sql.buffer_gets_delta ,
 sql.disk_reads_delta ,
 sql.iowait_delta ,
sql.cpu_time_delta ,
 sql.elapsed_time_delta 
 from
 dba_hist_sqlstat sql,
 dba_hist_snapshot s
 where
 s.snap_id = sql.snap_id
 and s.begin_interval_time > sysdate -10
 and
sql.sql_id='grux3tczwaaqf'
 order by to_char(s.begin_interval_time,'HH24:MI')
 /
--Do we have multiple plan hash values for the same SQL ID – in that case may be changed plan is causing bad performance
		select 
		  SQL_ID 
		, PLAN_HASH_VALUE 
		, sum(EXECUTIONS_DELTA) EXECUTIONS
		, sum(ROWS_PROCESSED_DELTA) CROWS
		, trunc(sum(CPU_TIME_DELTA)/1000000/60) CPU_MINS
		, trunc(sum(ELAPSED_TIME_DELTA)/1000000/60)  ELA_MINS
		from DBA_HIST_SQLSTAT 
		where SQL_ID in (
		'2w6u8r8ama4ut') 
		group by SQL_ID , PLAN_HASH_VALUE
		order by SQL_ID, CPU_MINS;
--Top 5 Queries for past week based on ADDM recommendations
/*
Top 10 SQL_ID's for the last 7 days as identified by ADDM
from DBA_ADVISOR_RECOMMENDATIONS and dba_advisor_log
*/

		col SQL_ID form a16
		col Benefit form 9999999999999
		select * from (
		select b.ATTR1 as SQL_ID, max(a.BENEFIT) as "Benefit" 
		from DBA_ADVISOR_RECOMMENDATIONS a, DBA_ADVISOR_OBJECTS b 
		where a.REC_ID = b.OBJECT_ID
		and a.TASK_ID = b.TASK_ID
		and a.TASK_ID in (select distinct b.task_id
		from dba_hist_snapshot a, dba_advisor_tasks b, dba_advisor_log l
		where a.begin_interval_time > sysdate - 7 
		and  a.dbid = (select dbid from v$database) 
		and a.INSTANCE_NUMBER = (select INSTANCE_NUMBER from v$instance) 
		and to_char(a.begin_interval_time, 'yyyymmddHH24') = to_char(b.created, 'yyyymmddHH24') 
		and b.advisor_name = 'ADDM' 
		and b.task_id = l.task_id 
		and l.status = 'COMPLETED') 
		and length(b.ATTR4) > 1 group by b.ATTR1
		order by max(a.BENEFIT) desc) where rownum < 6;
		


 ============== estimate row and actual row
  SELECT /*+ GATHER_PLAN_STATISTICS */ employee_id, last_name, job_id
 FROM employees
  WHERE job_id='AD_VP';
  variable my_rept CLOB;
execute :SYS_B_0 :='J';
SELECT plan_table_output
FROM table(DBMS_XPLAN.DISPLAY_CURSOR (FORMAT=>'ALLSTATS LAST'));
============= generate sql monitoring report
variable my_rept CLOB;
execute :SYS_B_0 :='J';
BEGIN
 :my_rept :=DBMS_SQLTUNE.REPORT_SQL_MONITOR();
END;
/ 

====================== dbmonitor cdb =======================
alter user C##dbmonitor set container_data=all for sys.v_$pdbs container = current;
alter user C##dbmonitor set container_data=all for cdb_data_files container = current;
alter user C##dbmonitor set container_data=all for v_$containers container = current;
alter user C##dbmonitor set container_data=all for cdb_segments container = current;
alter user C##dbmonitor set container_data=all for cdb_free_space container = current;
alter user C##dbmonitor set container_data=all for cdb_temp_files container = current;


=================================== trigger catch error============= dung user sys
https://www.youtube.com/watch?v=CU9HXX7RR9w
https://dba.stackexchange.com/questions/40318/is-it-possible-in-oracle-to-trace-sql-statements-that-result-in-errors

CREATE TABLE QUERY_LOG (ID              NUMBER,ORA_ERR         VARCHAR2(10),EXE_DATE        DATE,QRY_LOG         NCLOB);

CREATE SEQUENCE QUERY_LOG_ID NOCACHE;

CREATE OR REPLACE TRIGGER Failed_To_Extend_Temp
AFTER SERVERERROR ON DATABASE
DECLARE
    l_sql_text ora_name_list_t;
    l_n        NUMBER;
    t1         NCLOB;
BEGIN
    --IF (is_servererror(942) ) THEN
    l_n := ora_sql_txt(l_sql_text );

    FOR I IN 1 .. l_n
    LOOP
        t1 := t1||l_sql_text(i);
    END LOOP;

    INSERT INTO QUERY_LOG (Id , Ora_Err , EXE_DATE , QRY_LOG)
    VALUES (QUERY_LOG_ID.Nextval, ora_server_error(1), Sysdate,t1 );
--END IF;
END;
/


--------- trigger nay bat duoc client id
--drop trigger log_errors_trig;
--drop table   log_errors_tab;

create table log_errors_tab (
 error     varchar2(4000),
 timestamp date,
 username  varchar2(4000),
        osuser    varchar2(4000),
        machine   varchar2(4000),
 process   varchar2(4000),
 program   varchar2(4000));

create or replace trigger log_errors_trig 
 after servererror on database
declare
 var_user     varchar2(4000);
 var_osuser   varchar2(4000);
 var_machine  varchar2(4000);
 var_process  varchar2(4000);
 var_program  varchar2(4000);
begin
 select username, osuser, machine, process, program
 into   var_user, var_osuser, var_machine, var_process, var_program
 from   sys.v_$session
 where  audsid = userenv('sessionid');

 insert into log_errors_tab
   values(dbms_standard.server_error(1),sysdate,var_user,
          var_osuser,var_machine,var_process,var_program);
end;
/
===================trigger logon alter session===================================
CREATE OR REPLACE TRIGGER SYS.LOGON_TRIG
    /* 2020-03-10 thinhdd
       Trigger to alter parameters
    */
    AFTER LOGON
    ON DATABASE
    DISABLE
DECLARE
    lc_proc_name   CONSTANT VARCHAR2 (255) := 'SYS.LOGON_TRIG';
    l_database_role         VARCHAR2 (255);
    l_username              VARCHAR2 (255) := SYS_CONTEXT ('USERENV', 'SESSION_USER');
    l_ipaddress             VARCHAR2 (255) := SYS_CONTEXT ('USERENV', 'IP_ADDRESS');
    l_module                VARCHAR2 (255) := SYS_CONTEXT ('USERENV', 'MODULE');
BEGIN
    IF l_username NOT IN ('THINHDD',
                          'DBMONITOR',
                          'ANONYMOUS',
                          'APPQOSSYS',
                          'CTXSYS',
                          'DIP',
                          'EXFSYS',
                          'MDDATA',
                          'MDSYS',
                          'MGMT_VIEW',
                          'OLAPSYS',
                          'ORACLE_OCM',
                          'ORDDATA',
                          'ORDPLUGINS',
                          'ORDSYS',
                          'OUTLN',
                          'SI_INFORMTN_SCHEMA',
                          'SPATIAL_CSW_ADMIN_USR',
                          'SPATIAL_WFS_ADMIN_USR',
                          'WMSYS',
                          'SYS',
                          'SYSTEM',
                          'XDB',
                          'XS$NULL')
    THEN
        EXECUTE IMMEDIATE 'alter session set "_b_tree_bitmap_plans"=false';

        EXECUTE IMMEDIATE 'alter session set "_first_spare_parameter"=10';

        EXECUTE IMMEDIATE 'alter session set "_gby_hash_aggregation_enabled"=false';

        EXECUTE IMMEDIATE 'alter session set "_hash_join_enabled"=false';

        EXECUTE IMMEDIATE 'alter session set "_optim_peek_user_binds"=false';

        EXECUTE IMMEDIATE 'alter session set "_optimizer_skip_scan_enabled"=false';

        EXECUTE IMMEDIATE 'alter session set "_optimizer_sortmerge_join_enabled"=false';
    ELSE
        EXECUTE IMMEDIATE 'alter session set "_b_tree_bitmap_plans"=true';

        EXECUTE IMMEDIATE 'alter session set "_gby_hash_aggregation_enabled"=true';

        EXECUTE IMMEDIATE 'alter session set "_hash_join_enabled"=true';

        EXECUTE IMMEDIATE 'alter session set "_optim_peek_user_binds"=true';
    END IF;
END;
/

========= trigger mine =======================
/* Formatted on 6/16/2020 5:23:45 PM (QP5 v5.287) */
CREATE OR REPLACE TRIGGER SYS.LOGON_TRIG
   AFTER LOGON
   ON DATABASE
DECLARE
   lc_proc_name   CONSTANT VARCHAR2 (255) := 'SYS.LOGON_TRIG';
   l_database_role         VARCHAR2 (255);
   l_username              VARCHAR2 (255)
                              := SYS_CONTEXT ('USERENV', 'SESSION_USER');
   l_ipaddress             VARCHAR2 (255)
                              := SYS_CONTEXT ('USERENV', 'IP_ADDRESS');
   l_module                VARCHAR2 (255)
                              := SYS_CONTEXT ('USERENV', 'MODULE');
BEGIN
   SELECT COUNT (*)
     INTO v_count
     FROM dba_users
    WHERE     ACCOUNT_MASK_status = 'OPEN'
          AND profile NOT IN ('APPUSER', 'SYSTEMUSER', 'ADMINUSER')
          AND UPPER (username) = UPPER (l_username);

   IF v_count > 0
   THEN
      EXECUTE IMMEDIATE 'alter session set parallel_degree_policy=MANUAL';
   END IF;
END;
/
=================trigger trace =========================================
CREATE OR REPLACE TRIGGER sys.session_trace_on
-- to be created by sys user
AFTER LOGON ON database
DECLARE
v_machinename VARCHAR2(64);
v_ora_username VARCHAR2(30) DEFAULT NULL;
v_os_username VARCHAR2(30);
v_sid NUMBER;
v_serial NUMBER;
v_program VARCHAR2(48);
v_numuser NUMBER;
CURSOR c1 IS
SELECT sid, serial#, osuser, machine, program
FROM v$session
WHERE sid = userenv('sid')
and username = 'CHUNGTC';--------------
BEGIN
OPEN c1;
FETCH c1 INTO v_sid, v_serial, v_os_username, v_machinename, v_program;
IF c1%FOUND THEN
-- DBMS_SESSION.set_sql_trace (TRUE);
v_machinename := replace(replace(v_machinename, '\', '_'), '/', '_');
v_os_username := replace(replace(v_os_username, '\', '_'), '/', '_');
EXECUTE IMMEDIATE 'alter session set tracefile_identifier=''' || trim(v_os_username) || '''';
EXECUTE IMMEDIATE 'alter session set events ''10046 trace name context forever, level 12''';
END IF;
CLOSE c1;
END;
/


=============================10053 trace =================================
"resp" cost =  "response time" cost
"resc" cost is the "resource cost"
Calculate the CPU to I/O ratio used by the CBO:
	Combined Resc Cost = (RSC_CPU cost / _cpu_to_io) + RSC_IO Cost
				Solve for _cpu_to_io:
				_cpu_to_io = RSC_CPU Cost / (Combined Cost - RSC_IO Cost)
						   = 2865229980   / (55630 - 52693)
						   = 975563.49 CPU cycles per IO
D)  Calculate the multiblock read divisor
	MBdivisor = Num Blocks / tsc cost ( mumber of blocks/ tablescan cost )

• If the number is close to the number of blocks in the table, the index
order closely matches the order of the table.
• If the number is close to the number of rows in the table, oracle thinks
the index order does not match the order of the table.					   
					   
https://oracleyogi.wordpress.com/2015/12/26/10053-trace-demystified/
--hoac
alter session set timed_statistics = true;
alter session set statistics_level=all;

alter session set max_dump_file_size = unlimited;
ALTER SESSION SET EVENTS '10053 trace name context forever, level 1';
ALTER SESSION SET TRACEFILE_IDENTIFIER = "chungtc_2";
select  count(*) from AMLMCOB.PRESULT a0 where
INSTITUTSNR='MCOB' AND HISTBIS='9999' and ANWEND_KZ='P'  AND STATUS='inconspic'  
;
set autotrace off;
ALTER SESSION SET EVENTS '10053 trace name context off';

conn / as sysdba
oradebug setmypid  -- current session
ORADEBUG SETOSPID 126375  -- other session
		SELECT p.spid FROM v$session s, v$process p
		WHERE s.paddr = p.addr
		AND s.sid = 1705;

oradebug unlimit
oradebug event 10053 trace name context forever, level 1
oradebug event 10046 trace name context forever, level 12
oradebug tracefile_name 

…SQL Statement…
oradebug event 10046 trace name context off

If you want to generate trace for a SQL statement that is part of PL/SQL Package or Stored PROC

ALTER SESSION SET EVENTS ‘ trace[rdbms.SQL_Optimizer.*][sql:<sql_id>]’;

ALTER SESSION SET EVENTS ”trace [SQL_Optimizer.*] off’;

As I mentioned at the start of blog  – 10053 trace will be triggered after a hard parse. So, if the sql is already in the shared pool we have to –

1. Either wait until the statement is hard parsed again  OR
2. Flush the sql from the shared pool to ensure hard parse.
Below script  can be used  flush SQL from shared pool.

var name varchar2(50)
accept sql_id prompt ‘Enter value for sql_id: ‘
BEGIN
select address||’,’||hash_value into :name
from v$sqlarea
where sql_id like ‘&&sql_id’;
dbms_shared_pool.purge(:name,’C’,1);
END;
/

Starting  11gR2 you can use DBMS_SQLDIAG.DUMP_TRACE as it doesn’t require you to re-execute the statement to get the trace  It will automatically trigger a hard parse.  Please refer to MOS 225598.1 for more details.

BEGIN
DBMS_SQLDIAG.DUMP_TRACE
(
p_sql_id=>’sql_id’,
p_child_number=>0,
p_component=>’Compiler’,
p_file_id=>’ MY_10053_TRACE’
);
END;
/

-- cuoi cung dung Oracle 10053 Trace Viewer de view trace file
http://oraclewizard.com/Oraclewizard/2014/04/oracle-10053-trace-viewer/
QUERY BLOCK TEXT
BASE STATISTICAL INFORMATION
SINGLE TABLE ACCESS PATH
Join order[21]    Best so far             ; Best join order  ; Final cost for query block
Current SQL Statement for this session
Plan Table
Content of other_xml column

PARAMETERS USED BY THE OPTIMIZER
PARAMETERS WITH ALTERED VALUES
PARAMETERS WITH DEFAULT VALUES
PARAMETERS IN OPT_PARAM HINT
====================== partition exchange 
noi chung de chuyen du lieu tu  bang ngoai vao bang partition hoac nguoc lai thi:
 - 2 bang fai giong het nhau tu index, pk
 - bang partition ma co index global thi bat buoc fai dung option UPDATE GLOBAL INDEXES. Neu ko global index nay se bi invalid
	 ALTER TABLE call
	  EXCHANGE PARTITION call_temp_created_date
	  WITH TABLE call_temp
	  WITHOUT VALIDATION
	  UPDATE GLOBAL INDEXES;
	  
	 ALTER TABLE CALL
	EXCHANGE PARTITION call_partition WITH TABLE call_temp
	INCLUDING INDEXES
	WITHOUT VALIDATION;
  
 - Khi co global index thi exchange ra hay exchange vao deu mat thoi gian ca
 
====================== chungtc SQL_TRACE ==================================
https://oracle-base.com/articles/misc/sql-trace-10046-trcsess-and-tkprof
https://dba.stackexchange.com/questions/166607/how-to-capture-all-users-query-on-oracle-database
---------------TRACE CURRENT SESSION
alter session set timed_statistics = true;
alter session set statistics_level=all;
alter session set max_dump_file_size = unlimited;
ALTER SESSION SET TRACEFILE_IDENTIFIER = "chungtc_20210118";
execute dbms_monitor.session_trace_enable(binds => TRUE, plan_stat => 'ALL_EXECUTIONS')

alter session set tracefile_identifier='moca';
variable id number;
EXECUTE :id := 10;
SELECT count(pad) FROM t WHERE id < :id;

alter session set events 'sql_trace off';
execute dbms_monitor.session_trace_disable



-- hoac

alter session set timed_statistics = true;
alter session set statistics_level=all;
alter session set max_dump_file_size = unlimited;
ALTER SESSION SET EVENTS '10046 trace name context forever, level 12';

set autotrace traceonly
chay cau lenh can trace
ALTER SESSION SET EVENTS '10046 trace name context off';
------------------TRACE SQL_ID TREN MOI SESSION day la trace 10046 cho thay duoc thoi gian xu ly lenh
https://support.oracle.com/epmos/faces/DocumentDisplay?_afrLoop=329120767794114&id=39817.1&_adf.ctrl-state=wanfthxbv_52
alter system set events 'sql_trace[sql: f56h3p8k1qa44] level 12';
ALTER SYSTEM SET EVENTS 'sql_trace [sql:1bbbjhpqkcfbg] bind=true, wait=true'
ALTER SYSTEM SET EVENTS 'sql_trace [sql:&&sql_id] bind=true, wait=true';

alter system set events 'sql_trace[sql: f56h3p8k1qa44] off';

------------------TRACE SESSION_ID KHAC
8698,37614,@2
alter system kill session '92,64540,@2' immediate;
10422,12531,@1 5814,47104,@1
4175,57729,@2
2252,53378,@1
EXEC DBMS_MONITOR.session_trace_enable(session_id =>2252, serial_num=>53378, waits=>TRUE, binds=>TRUE);


EXEC DBMS_MONITOR.session_trace_enable(session_id =>2693, serial_num=>26045, waits=>TRUE, binds=>TRUE);
EXEC DBMS_MONITOR.session_trace_enable(session_id =>8325, serial_num=>16795, waits=>TRUE, binds=>TRUE);
EXEC DBMS_MONITOR.session_trace_enable(session_id =>14604, serial_num=>29975, waits=>TRUE, binds=>TRUE);
EXEC DBMS_MONITOR.session_trace_enable(session_id =>14292, serial_num=>53087, waits=>TRUE, binds=>TRUE);
EXEC DBMS_MONITOR.session_trace_enable(session_id =>13352, serial_num=>53843, waits=>TRUE, binds=>TRUE);

EXEC DBMS_MONITOR.session_trace_disable(session_id=>8636, serial_num=>17624);
9392,56296,@1
-------------- TIM TRACE FILE  453,33361,@1
SELECT value
    FROM v$diag_info
    WHERE name = 'Default Trace File';  -- dung trong th trace current_session
	
	
SELECT p.tracefile
FROM   v$session s
       JOIN v$process p ON s.paddr = p.addr
WHERE  s.sid = 2252 ;  --SID cua session bi trace hoac sid cua sql bi trace

------------------	CACH DOC THONG TIN FILE TRACE
trcsess output=output.out service=basel *trc
trcsess output=output.out session=
tkprof test_ora_130319.trc test_ora_130319.txt
CREATE or replace DIRECTORY TRACE AS '/u01/app/oracle/diag/rdbms/ewallet/ewallet1/trace';
-- thong ke cac sql_id trong file trace
SELECT sql_id,
           sum(elapsed_time) AS elapsed_time,
           sum(executions) AS executions,
           round(sum(elapsed_time)/sum(executions)) AS elapsed_time_per_execution
    FROM table(dbms_sqltune.select_sql_trace(
                 directory => 'TRACE',
                 file_name => 'ewallet1_ora_115986.trc',
                 select_mode => 2 -- all executions
              )) t
  -- WHERE parsing_schema_name = 'MBW'
  GROUP BY sql_id
   ORDER BY elapsed_time DESC;
-- select sql text cua sql_id trong file trace
SELECT sql_text
    FROM table(dbms_sqltune.select_sql_trace(
                 directory => 'TRACE',
                 file_name => 'test_ora_130319.trc',
                 select_mode => 1 -- only first execution
              )) t
    WHERE sql_id = 'asth1mx10aygn';
-- select statistic cua sql_id trong file trace	
SELECT plan_hash_value, executions, fetches, elapsed_time, cpu_time, disk_reads, buffer_gets, rows_processed
    FROM table(dbms_sqltune.select_sql_trace(
                 directory => 'TRACE',
                 file_name => 'ewallet1_ora_115986.trc',
                 select_mode => 2 -- all executions
              )) t
    WHERE sql_id = 'f56h3p8k1qa44'
    ORDER BY elapsed_time DESC;
-- select bind variable cua sql_id trong file trace	
SELECT elapsed_time,
           value(b).gettypename() AS type,
           value(b).accessnumber() AS value
    FROM table(dbms_sqltune.select_sql_trace(
                 directory => 'TRACE',
                 file_name => 'ewallet1_ora_115986.trc',
                 select_mode => 2 -- all executions
              )) t,
         table(bind_list) b
   WHERE sql_id = 'f56h3p8k1qa44'
   ORDER BY elapsed_time DESC;
-- select ra plan cua sql_id trong file trace	
DECLARE
      c sys_refcursor;
    BEGIN
      dbms_sqltune.create_sqlset('TEST');
      OPEN c FOR
        SELECT value(t)
        FROM table(dbms_sqltune.select_sql_trace(
                 directory => 'TRACE',
                 file_name => 'test_ora_130319.trc',
                select_mode => 2 -- all executions
                 )) t;
     dbms_sqltune.load_sqlset('TEST', c);
     CLOSE c;
   END;
   /
	
SELECT *
    FROM table(dbms_xplan.display_sqlset(
                 sqlset_name => 'TEST',
                 sql_id => '4gc64454ax64x'
              ));
====================== SQL_TRACE ==================================


================== auto trace ================  SET AUTOT TRACE EXP STAT

gerardnico@orcl>SELECT log_mode FROM v$database;
 
LOG_MODE
------------
ARCHIVELOG
 
gerardnico@orcl>ALTER TABLE big_table nologging;
 
TABLE altered.
 
gerardnico@orcl>SET autotrace ON statistics;
> SET AUTOT TRACE EXP STAT    -- xin hon
gerardnico@orcl>INSERT INTO big_table SELECT * FROM all_objects;
gerardnico@orcl>INSERT /*+ APPEND NOLOGGING*/ INTO big_table SELECT * FROM all_objects;

   ========================= CHUNGTC MANUAL CREATE SQL PROFILE =========================================
--CHAY CAU LENH TEST CO HIT DE SINH RA PROFILE TOT
-- SELECT RA SQL_ID CUA CAU LENH TOT
select sql_id, child_number, plan_hash_value plan_hash, executions execs,
  (elapsed_time/1000000)/decode(nvl(executions,0),0,1,executions) avg_etime,
  buffer_gets/decode(nvl(executions,0),0,1,executions) avg_lio,
  sql_text
  from v$sql s
  where (sql_text) like '%new test 5w5ntqhgmcnp0%';
  
  --c2cffkq1uvv9y
  --SELECT PROFILE CUA SQL_ID TOT TREN
  select  CHR(9)||''''
        ||regexp_replace(extractvalue(value(d),'/hint'),'''','''''')
        || ''','
from    xmltable('/*/outline_data/hint'
                passing (select     xmltype(other_xml) as xmlval
                        from        v$sql_plan
                        where       sql_id = '2jz1fwtv9rxyt'
                        and         CHILD_NUMBER = &CHILD_NO
                        and         other_xml is not null)) d;
						
						
---- DUNG PROFILE DA LAY O TREN, TAO 1 PROFILE MOI GAN VAO SQL_ID KEM
declare
    ar_profile_hints sys.sqlprof_attr;
begin
    ar_profile_hints := sys.sqlprof_attr(
    'BEGIN_OUTLINE_DATA',
				'IGNORE_OPTIM_EMBEDDED_HINTS',
				'OPTIMIZER_FEATURES_ENABLE(''8.1.7'')',
				'DB_VERSION(''12.1.0.2'')',
				'OPT_PARAM(''optimizer_dynamic_sampling'' 2)',
				'OUTLINE_LEAF(@"SEL$CDDF04A7")',
				'OUTER_JOIN_TO_INNER(@"SEL$58A6D7F6")',
				'OUTLINE_LEAF(@"SEL$6A1B73E7")',
				'MERGE(@"SEL$37633EB5")',
				'OUTLINE(@"SEL$58A6D7F6")',
				'MERGE(@"SEL$1")',
				'OUTLINE(@"SEL$5")',
				'OUTLINE(@"SEL$37633EB5")',
				'MERGE(@"SEL$3")',
				'OUTLINE(@"SEL$2")',
				'OUTLINE(@"SEL$1")',
				'OUTLINE(@"SEL$4")',
				'OUTLINE(@"SEL$3")',
				'NO_ACCESS(@"SEL$6A1B73E7" "from$_subquery$_003"@"SEL$4")',
				'INDEX_RS_ASC(@"SEL$6A1B73E7" "A2"@"SEL$3" ("KYCCUST"."INSTITUTSNR" "KYCCUST"."KUNDNR" "KYCCUST"."HISTBIS"))',
				'LEADING(@"SEL$6A1B73E7" "from$_subquery$_003"@"SEL$4" "A2"@"SEL$3")',
				'USE_NL(@"SEL$6A1B73E7" "A2"@"SEL$3")',
				'INDEX(@"SEL$CDDF04A7" "A0"@"SEL$2" ("PRESULT"."ANWEND_KZ" "PRESULT"."HISTBIS" "PRESULT"."STATUS" "PRESULT"."INSTITUTSNR" "PRESULT"."KUNDNR"))',
				'INDEX_RS_ASC(@"SEL$CDDF04A7" "A1"@"SEL$1" ("GWGKUNDE"."INSTITUTSNR" "GWGKUNDE"."KUNDNR" "GWGKUNDE"."HISTBIS"))',
				'LEADING(@"SEL$CDDF04A7" "A0"@"SEL$2" "A1"@"SEL$1")',
				'USE_NL(@"SEL$CDDF04A7" "A1"@"SEL$1")',
        'END_OUTLINE_DATA');
    for sql_rec in (
    select t.sql_id, t.sql_text
    from dba_hist_sqltext t, dba_hist_sql_plan p
    where t.sql_id = p.sql_id
    and p.sql_id = '&SQL_ID_TO_FIX'
    and p.plan_hash_value = &BAD_PLAN_HASH_VALUE
    and p.parent_id is null
)
loop
        DBMS_SQLTUNE.IMPORT_SQL_PROFILE(
    sql_text    => sql_rec.sql_text,
    profile     => ar_profile_hints,
	force_match => true,
    name        => 'PROFILE4_9u4c8b7upk5wu');
end loop;
end;
/			

-------------read sql profile
select * from dba_sql_profiles;

SELECT CREATED, PROFILE_NAME, SQL_TEXT, 
  XMLtransform(XMLTYPE(h.comp_data), '<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
<xsl:template match="*">
<xsl:for-each select="/outline_data/hint">
<xsl:value-of select="."/>
<xsl:text>&#xa;</xsl:text>
</xsl:for-each>
</xsl:template>
</xsl:stylesheet>').getStringVal()
FROM DBMSHSXP_SQL_PROFILE_ATTR h, DBA_SQL_PROFILES p
WHERE p.name = h.profile_name
 and p.name='9dgxuraby4j72_profile';



set serveroutput on echo off
declare
  -- input variables
  input_task_owner dba_advisor_tasks.owner%type:='SYS';
  input_task_name dba_advisor_tasks.task_name%type:='9dgxuraby4j72';----------------------------name of tuning task
  input_show_outline boolean:=false;
  -- local variables
  task_id  dba_advisor_tasks.task_id%type;
  outline_data xmltype;
  benefit number;
begin
  for o in ( select * from dba_advisor_objects where owner=input_task_owner and task_name=input_task_name and type='SQL')
  loop
          -- get the profile hints (opt_estimate)
          dbms_output.put_line('--- PROFILE HINTS from '||o.task_name||' ('||o.object_id||') statement '||o.attr1||':');
          dbms_output.put_line('/*+');
          for r in (
            select hint,benefit from (
             select case when attr5 like 'OPT_ESTIMATE%' then cast(attr5 as varchar2(4000)) when attr1 like 'OPT_ESTIMATE%' then attr1 end hint,benefit
             from dba_advisor_recommendations t join dba_advisor_rationale r using (task_id,rec_id)
             where t.owner=o.owner and t.task_name = o.task_name and r.object_id=o.object_id and t.type='SQL PROFILE'
             --and r.message='This attribute adjusts optimizer estimates.'
            ) order by to_number(regexp_replace(hint,'^.*=([0-9.]+)[^0-9].*$','\1'))
          ) loop
           dbms_output.put_line('   '||r.hint); benefit:=to_number(r.benefit)/100;
          end loop;
          dbms_output.put_line('*/');
          -- get the outline hints
          begin
          select outline_data into outline_data from (
              select case when other_xml is not null then extract(xmltype(other_xml),'/*/outline_data/hint') end outline_data
              from dba_advisor_tasks t join dba_sqltune_plans p using (task_id)
              where t.owner=o.owner and t.task_name = o.task_name and p.object_id=o.object_id  and t.advisor_name='SQL Tuning Advisor' --11gonly-- and execution_type='TUNE SQL'
              and p.attribute='Using SQL profile'
          ) where outline_data is not null;
          exception when no_data_found then null;
          end;
          exit when not input_show_outline;
          dbms_output.put_line('--- OUTLINE HINTS from '||o.task_name||' ('||o.object_id||') statement '||o.attr1||':');
          dbms_output.put_line('/*+');
          for r in (
              select (extractvalue(value(d), '/hint')) hint from table(xmlsequence(extract( outline_data , '/'))) d
          ) loop
           dbms_output.put_line('   '||r.hint);
          end loop;
          dbms_output.put_line('*/');
          dbms_output.put_line('--- Benefit: '||to_char(to_number(benefit),'FM99.99')||'%');
  end loop;
  dbms_output.put_line('');
end;
/
--11g
SELECT so.name,extractvalue(VALUE(h), '.') AS hint
FROM sys.sqlobj$data od,
     sys.sqlobj$ so,
     TABLE(xmlsequence(extract(xmltype(od.comp_data), '/outline_data/hint'))) h
WHERE so.name IN (SELECT name FROM DBA_SQL_PROFILES)
AND so.signature = od.signature
AND so.category = od.category
AND so.obj_type = od.obj_type
AND so.plan_id = od.plan_id
and name ='SYS_SQLPROF_0178ed5a0a0f0000';	
 ---------disable sql profile
BEGIN
DBMS_SQLTUNE.ALTER_SQL_PROFILE(
name => 'PROFILE4_crtpafjsdxdt2',
attribute_name => 'STATUS',l
END;
--drop sql profile
BEGIN
  DBMS_SQLTUNE.DROP_SQL_PROFILE ( 
    name => 'FBNK_CUSTOMER_20160826_02' 
);
END;
/
   ===========================================================================================
============= explain plan ===================
https://www.red-gate.com/simple-talk/sql/oracle/understanding-sql-query-parsing-part-2-parent-and-child-cursors/
SELECT sql_id,child_number,sql_text FROM v$sql WHERE sql_text LIKE 'select /* Yannick */%';
SELECT sql_id,child_number,use_feedback_stats,reason FROM V$SQL_SHARED_CURSOR WHERE sql_id IN (SELECT sql_id FROM v$sql WHERE sql_text LIKE 'select /* Yannick */%');

exec for c in (select address,hash_value,users_executing,sql_text from v$sqlarea where sql_id='6dfghrkb1qgb6') loop sys.dbms_shared_pool.purge(c.address||','||c.hash_value,'...'); end loop;

EXPLAIN PLAN  SET STATEMENT_ID = 'N1' into plan_table  FOR  _sql_text_; 
SELECT * FROM table(DBMS_XPLAN.DISPLAY('plan_table', 'N1','ALL'));

EXPLAIN PLAN FOR select count(*) from ibs.bk_interface_message where log_time <= trunc(sysdate)-6*30;
select plan_table_output from table(dbms_xplan.display('plan_table',null,'ALLSTATS LAST +cost +bytes'));

SET LINESIZE 200 PAGESIZE 100
SELECT * FROM TABLE(DBMS_XPLAN.display_cursor(format=>'ALLSTATS LAST +cost +bytes')); 
SELECT * FROM TABLE(DBMS_XPLAN.display_cursor(format=>'ADVANCED +OUTLINE')); 

SELECT * FROM TABLE(f_XPLAN.display_cursor(sql_id=>'f93njdyd2vpjm', format=>'ALLSTATS LAST +cost +bytes +OUTLINE +NOTE')); 
SELECT * FROM TABLE(DBMS_XPLAN.display_cursor(sql_id=>'gc6zvs4wwjz2k', format=>'ADVANCED +OUTLINE +NOTE')); 

SELECT * FROM TABLE(DBMS_XPLAN.display_cursor(sql_id=>'30y69hz5555f8',format => 'adaptive'));
SELECT * FROM TABLE(DBMS_XPLAN.display_cursor(sql_id=>'bv094ahf8xgzt',format => 'adaptive allstats last'));

SELECT * FROM TABLE(dbms_xplan.display_cursor(sql_id=>'f93njdyd2vpjm', cursor_child_no=>'0', format=> 'all allstats'));
select * from table(dbms_xplan.display_awr('4phb2bfhmc3rk','2868752829','','ADVANCED +OUTLINE +NOTE'));

SELECT * FROM table(DBMS_XPLAN.DISPLAY, format=>'ADVANCED');
+ explain plan cua history
select * from TABLE(dbms_xplan.display_awr('63fdtntgnk7qv'));
    select * from TABLE(dbms_xplan.display_awr('f6jfmck5rduur', null, null, 'ALL'));

+
EXPLAIN PLAN SET STATEMENT_ID='TSH' FOR
SELECT *
FROM   C_NEIF_MESSAGE_HISTORY where message_id ='902297333';

SELECT * 
FROM   TABLE(DBMS_XPLAN.DISPLAY('PLAN_TABLE','TSH','ALL'));

-- explain plan from sql_id
set pagesize 9999;
set linesize 500;
select * from table(dbms_xplan.display_awr('cpn8j0q3w7qxp',null,null,'ALL'));


===================chungtc sql plan directive ==========================
select 'exec dbms_spd.alter_sql_plan_directive('||directive_id||',''ENABLED'',''NO'');' from DBA_SQL_PLAN_DIRECTIVES where directive_id in
(
select directive_id from dba_sql_plan_dir_objects where owner = 'AMLMCOB' and object_name in( 'GWGKUNDE','PRESULT','KYCCUST')
)

and enabled='YES';


select * from DBA_SQL_PLAN_DIRECTIVES where directive_id in
(
select directive_id from dba_sql_plan_dir_objects where owner = 'AMLMCOB' and object_name in( 'GWGKUNDE','PRESULT','KYCCUST')
)
and enabled='YES';

--------------display  SPD
SET LINESIZE 200
COLUMN dir_id FORMAT A20
COLUMN owner FORMAT A10
COLUMN object_name FORMAT A10
COLUMN col_name FORMAT A10
SELECT TO_CHAR(d.directive_id) dir_id, o.owner, o.object_name, 
       o.subobject_name col_name, o.object_type, d.type, d.state, d.reason
FROM   dba_sql_plan_directives d, dba_sql_plan_dir_objects o
WHERE  d.directive_id=o.directive_id
AND    o.owner = 'TEST'
ORDER BY 1,2,3,4,5;
---------------flush SPD
EXEC DBMS_SPD.flush_sql_plan_directive;

----------tao xoa extended histogram
EXEC dbms_stats.gather_table_stats('T24CORE', 'STF_MB_IC_C006_CV_1', estimate_percent=>DBMS_STATS.AUTO_SAMPLE_SIZE, method_opt => 'FOR ALL COLUMNS SIZE skewonly', degree=>64, cascade=>true,no_invalidate => false);
select  dbms_stats.create_extended_stats('AMLMCOB','TEST', '(INSTITUTSNR, HISTBIS,ANWEND_KZ,STATUS)') from dual;  --chua co teo histogram nao
exec dbms_stats.gather_table_stats('AMLMCOB','TEST',method_opt=>'FOR COLUMNS SIZE 254 (INSTITUTSNR, HISTBIS,ANWEND_KZ,STATUS)');  --fai gather nhu nay moi xuat hien histogram

BEGIN
   dbms_stats.delete_column_stats(
         ownname=>'AMLMCOB', tabname=>'TEST', colname=>'SYS_STUYJAZCFMUKX#LJ#ZIV1K91II',
                                  col_stat_type=>'HISTOGRAM');
END;

BEGIN
  DBMS_STATS.DROP_EXTENDED_STATS( 'AMLMCOB', 'TEST', 
                                  '(INSTITUTSNR, HISTBIS,ANWEND_KZ,STATUS)' );
END;
/
-------------- show statistic and extended statistic , histogram
SELECT column_id,
       column_name,
       histogram
FROM   dba_tab_columns
WHERE  table_name = 'TAB1'
and owner ='APPS'
ORDER BY column_id;

COLUMN extension FORMAT A30
SELECT extension_name, extension
FROM   dba_stat_extensions;

column col_group format a30
select e.extension col_group,
       t.num_distinct,
       t.histogram
from   dba_stat_extensions e
       join dba_tab_col_statistics t on e.extension_name=t.column_name
and    t.table_name = 'EMP';


SET LONG 100000
SET LINES 120
SET PAGES 50
SELECT DBMS_STATS.report_col_usage('TEST', 'TAB1') FROM   dual;


SELECT column_name, num_distinct, num_nulls, histogram,sample_size
FROM   DBA_tab_col_statistics
WHERE  table_name = 'ENTRY'
ORDER BY column_name;

SELECT endpoint_value,
       endpoint_number,
       endpoint_number - LAG(endpoint_number, 1, 0) OVER (ORDER BY endpoint_value) AS frequency
FROM   DBA_tab_histograms
WHERE  table_name  = 'TEST2_HISTORY'
AND    column_name = 'IS_BATCH'
ORDER BY endpoint_value;

COLUMN range FORMAT A20

SELECT '<=' || endpoint_value AS range,
       endpoint_value - (LAG(endpoint_value, 1, -1) OVER (ORDER BY endpoint_value)+1) + 1 AS vals_in_range,
       endpoint_number - LAG(endpoint_number, 1, 0) OVER (ORDER BY endpoint_value) AS frequency
FROM   DBA_tab_histograms
WHERE  table_name  = 'TEST2_HISTORY'
AND    column_name = 'TC_CODE'
ORDER BY endpoint_value;
-----------------remark SPD: su dung cau lenh misestimate -> xuat hien usage_col nhung chua co statistic 
----------------- misestimate + co persit SPD thi lan gather tiep theo se sinh extend statistic
-- lan dau chay cau misestimate 
SELECT /*+ GATHER_PLAN_STATISTICS */ *FROM   tab1 WHERE  gender = 'F' AND    y_chromosome = 'N' AND    beard = 'N';
- basic usage of column is detected but there are no filter predicate
- Luc nay, cau sql se bi mark la is_reoptimizable
SELECT sql_text, is_reoptimizable
FROM   v$sql
WHERE  sql_id = '577pbb7hm1j8x';
- Luc nay cung flush SPD -> co SPD nhung ko co extended statistic, ko co filter trong column usage.

-- Sau khi da flush SPD, thuc thi lai cau query
- Ket qua van su dung statistic feedback statistics feedback used for this statement, nhung cau query is no longer reoptimizable
- luc nay DBMS_STATS.REPORT_COL_USAGE function again, finally we can see the FILTER predicate in the report.
- Nhung van chua co extended statistic
-- Chi sau khi gather default statistic
- thi xuat hien extendex statistic
===================================================================chungtc metric history
SELECT name,interval_size FROM v$metricgroup ORDER BY interval_size;
select * from V$METRICNAME where metric_unit like '%Parse%' ;

select * from V$METRIC_HISTORY where metric_name='Soft Parse Ratio' ;
select * from v$metric where metric_name='Hard Parse Count (Session)' ;

select * from DBA_HIST_SYSMETRIC_HISTORY
where metric_name like 'Average Active Sessions'
order by begin_time desc;

sELECT name, wait_class FROM V$EVENT_NAME where name ='Total Time Waited (Foreground)' ORDER BY name;
sELECT * FROM V$system_event where event ='Total Time Waited (Foreground)' ORDER BY event;


===============chungtc sql_id=====================================
======Running queries with performance metrics
		SELECT
		  S.SQL_ID,
		  S.MODULE, 
		  S.SQL_TEXT, 
		  U.USERNAME, 
		  ROUND((S.DISK_READS/DECODE(S.EXECUTIONS,0,1, S.EXECUTIONS)),2) DISK_READS_PER_EXEC, 
		  S.DISK_READS, 
		  S.BUFFER_GETS, 
		  S.PARSE_CALLS, 
		  S.SORTS, 
		  S.EXECUTIONS, 
		  S.ROWS_PROCESSED, 
		  100 - ROUND(100 *  S.DISK_READS/GREATEST(S.BUFFER_GETS,1),2) HIT_RATIO, 
		  S.FIRST_LOAD_TIME, 
		  S.SHARABLE_MEM, 
		  S.PERSISTENT_MEM, 
		  S.RUNTIME_MEM, 
		  S.CPU_TIME, 
		  S.ELAPSED_TIME
		FROM
		  SYS.V_$SQL S, 
		  SYS.ALL_USERS U 
		WHERE
		  S.PARSING_USER_ID=U.USER_ID 
		AND 
		  UPPER(U.USERNAME) NOT IN ('SYS','SYSTEM') 
		ORDER BY 
		  5 DESC
====SQL query in pieces
	SELECT
	  *
	FROM
	  SYS.V_$SQLTEXT
	WHERE
	  SQL_ID = 'bttkf91h91sj8'
	ORDER BY 
	  SQL_ID, PIECE;
===========SQL query concatenated
	SELECT 
	  SQL_ID, LISTAGG(SQL_TEXT, '') WITHIN GROUP (ORDER BY PIECE)
	FROM 
	  SYS.V_$SQLTEXT
	WHERE
	  SQL_ID = '43v6ndsyydmak'
	GROUP BY 
	  SQL_ID;
	  
		SELECT 
	   'switch datafile '||LISTAGG(file#, ',') WITHIN GROUP (ORDER BY file#)|| ' to copy;'
	FROM 
	  V$DATAFILE 
	  where  name  like '%AICTRPT%';
=================Bind variables
	SELECT 
	  * 
	FROM
	  V$SQL_BIND_CAPTURE B 
	WHERE
	  SQL_ID = '43v6ndsyydmak';
=================	  Bind variables in procedure
CREATE OR REPLACE PROCEDURE raise_emp_salary (column_value NUMBER, 
                             emp_column VARCHAR2, amount NUMBER) IS
   v_column VARCHAR2(30);
   sql_stmt  VARCHAR2(200);
BEGIN
-- determine if a valid column name has been given as input
  SELECT COLUMN_NAME INTO v_column FROM USER_TAB_COLS 
    WHERE TABLE_NAME = 'EMPLOYEES' AND COLUMN_NAME = emp_column;
  sql_stmt := 'UPDATE employees SET salary = salary + :1 WHERE ' 
               || v_column || ' = :2';

 =============== select procedure co doan text nao do
	  select *from all_source
	where upper(text) like '%SELECT TRAN.ROWID TRAN_ROWID%'
	
===================== chungtc avg duration of sql_id theo session connect
select query_runs.*,
                round ( (end_time - start_time) * 24, 2) as duration_hrs
           from (  select u.username,
                          ash.program,
                          ash.sql_id,
                          ash.sql_plan_hash_value as plan_hash_value,
                          ash.session_id as sess#,
                          ash.session_serial# as sess_ser,
                          cast (min (ash.sample_time) as date) as start_time,
                          cast (max (ash.sample_time) as date) as end_time
                     from dba_hist_active_sess_history ash, dba_users u
                    where u.user_id = ash.user_id and ash.sql_id = lower(trim('2agu9vt8h0vk8'))
                 group by u.username,
                          ash.program,
                          ash.sql_id,
                          ash.sql_plan_hash_value,
                          ash.session_id,
                          ash.session_serial#) query_runs
order by sql_id, start_time;	

select a.instance_number inst_id, a.snap_id,a.plan_hash_value, to_char(begin_interval_time,'dd-mon-yy hh24:mi') btime, abs(extract(minute from (end_interval_time-begin_interval_time)) + extract(hour from (end_interval_time-begin_interval_time))*60 + extract(day from (end_interval_time-begin_interval_time))*24*60) minutes,
executions_delta executions, round(ELAPSED_TIME_delta/1000000/greatest(executions_delta,1),4) "avg duration (sec)" from dba_hist_SQLSTAT a, dba_hist_snapshot b
where sql_id='	fcu29ch055902' and a.snap_id=b.snap_id
and a.instance_number=b.instance_number
order by snap_id desc, a.instance_number;
=============sql patch ===================
------11. Vs 11 thi hint nhu trong outline moi an
-Vi du use_hash(A,B) thi fai hint nhu duoi
 select sql_text from dba_hist_sqltext where sql_id='2hgzp3ty8w2ng';
  declare
    v_sql CLOB;
 begin
    select sql_text into v_sql from dba_hist_sqltext where sql_id='2hgzp3ty8w2ng';
    sys.dbms_sqldiag_internal.i_create_patch(
       sql_text  => v_sql,
       hint_text => '      LEADING(@"SEL$46229992" "A"@"SEL$1" "B"@"SEL$1")
                            USE_HASH(@"SEL$46229992" "B"@"SEL$1")',
       name      => '26hxk4dnzpkd6_use_hash');
 end;
 /
-> la ket qua cua chay thu vs hint use_hash(A,B), sau do explain plan,  lay ra doan outline su dung hash join.

 declare
   v_sql CLOB;
begin
   select sql_text into v_sql from dba_hist_sqltext where sql_id='237dj3wr5ggpt';
   sys.dbms_sqldiag_internal.i_create_patch(
      sql_text  => v_sql,
      hint_text => '     OPT_PARAM(''_optim_peek_user_binds'' ''false'' ) DYNAMIC_SAMPLING(3) OPTIMIZER_FEATURES_ENABLE(''12.1.0.2'')  ',
      name      => '237dj3wr5ggpt_sqlpatch');
end;

    declare
   v_sql CLOB;
begin
   select sql_text into v_sql from dba_hist_sqltext where sql_id='2hgzp3ty8w2ng';
   sys.dbms_sqldiag_internal.i_create_patch(
      sql_text  => v_sql,
      hint_text => ' OPTIMIZER_FEATURES_ENABLE(''12.1.0.2'')  ',
      name      => '4fr344zscg1p5_sqlpatch');
end;
------12.2 
DECLARE
  l_patch_name  VARCHAR2(32767);
BEGIN
  l_patch_name := SYS.DBMS_SQLDIAG.create_sql_patch(
    sql_id    => 'angjwnm1wckgt',
    hint_text => 'OPT_PARAM(''optimizer_index_cost_adj'' 10)',
    name      => '1bbbjhpqkcfbg_MONITOR');
END;
/

DECLARE
  l_patch_name  VARCHAR2(32767);
BEGIN
  l_patch_name := SYS.DBMS_SQLDIAG.create_sql_patch(
    sql_id    => 'angjwnm1wckgt',
    hint_text => 'PARALLEL(TAB$,4)',
    name      => 'angjwnm1wckgt_SYS_GEN0');
END;
/
exec dbms_sqldiag.drop_sql_patch(name => 'angjwnm1wckgt_SYS_GEN0');

-- create by xml 11.2.0.3
SET SERVEROUTPUT ON
DECLARE
  l_sql_text        CLOB      ;
  l_sql_id          VARCHAR2(30) :='7a1dd4z42gw7t';
  l_sql_patch_hints VARCHAR2(500):=q'[INDEX(@"SEL$1" "EMP"@"SEL$1") OPT_PARAM('optimizer_dynamic_sampling' 0)]';
  l_sqlpro_attr SYS.SQLPROF_ATTR :=SYS.SQLPROF_ATTR(l_sql_patch_hints);
  l_sql_patch_name  VARCHAR2(30) :='my_sql_patch';
  l_sql_patch_desc  VARCHAR2(500):=l_sql_patch_name || 'my_sql_patch_description';
  l_output   varchar2(100);
BEGIN
    SELECT sql_fulltext INTO l_sql_text FROM dba_hist_sqltext where sql_id='237dj3wr5ggpt' AND ROWNUM < 2;
  l_output := SYS.DBMS_SQLTUNE_INTERNAL.I_CREATE_SQL_PROFILE(
    SQL_TEXT    => l_sql_text,
    PROFILE_XML => DBMS_SMB_INTERNAL.VARR_TO_HINTS_XML(l_sqlpro_attr),
    NAME        => l_sql_patch_name,
    DESCRIPTION => l_sql_patch_desc,
    CATEGORY    => 'DEFAULT',
    CREATOR     => 'SYS',
    VALIDATE    => TRUE,
    TYPE        => 'PATCH',
    FORCE_MATCH => TRUE,
    IS_PATCH    => TRUE);
    DBMS_OUTPUT.PUT_LINE(l_output);
END;
/
--- tao sql patch dung cho ca 19c ma cung ko loi
SET SERVEROUTPUT ON
DECLARE
  l_sql_text        CLOB      ;
  l_sql_id          VARCHAR2(30) :='angjwnm1wckgt';
  l_sql_patch_hints VARCHAR2(500):=q'[parallel(4) index_ffs(t)]';
  l_sqlpro_attr SYS.SQLPROF_ATTR :=SYS.SQLPROF_ATTR(l_sql_patch_hints);
  l_sql_patch_name  VARCHAR2(30) :='angjwnm1wckgt';
  l_sql_patch_desc  VARCHAR2(500):=l_sql_patch_name || 'chungtc_hint_parallel';
  l_output   varchar2(100);
BEGIN
    SELECT sql_fulltext INTO l_sql_text FROM gv$sql where sql_id='angjwnm1wckgt' AND ROWNUM < 2;
  l_output := SYS.DBMS_SQLTUNE_INTERNAL.I_CREATE_SQL_PROFILE(
    SQL_TEXT    => l_sql_text,
    PROFILE_XML => DBMS_SMB_INTERNAL.VARR_TO_HINTS_XML(l_sqlpro_attr),
    NAME        => l_sql_patch_name,
    DESCRIPTION => l_sql_patch_desc,
    CATEGORY    => 'DEFAULT',
    CREATOR     => 'SYS',
    VALIDATE    => TRUE,
    TYPE        => 'PATCH',
    FORCE_MATCH => TRUE,
    IS_PATCH    => TRUE);
    DBMS_OUTPUT.PUT_LINE(l_output);
END;
/
'full(@SEL$1 test_dba_tables)'    -- select  * from test_dba_tables
-- drop sql patch
exec dbms_sqldiag.drop_sql_patch(name => '2vnagwh5ngwxm_ffs8');

-- read sql patch
select to_char(signature) from dba_sql_patches where name='angjwnm1wckgt_SYS_GEN0';

select to_char(EXACT_MATCHING_SIGNATURE) from v$sql where sql_id = '5hqb8hx0achjb';
select cast(extractvalue(value(x), '/hint') as varchar2(500)) as outline_hints
    from   xmltable('/outline_data/hint'
          passing (select xmltype(comp_data) xml
                  from   sys.sqlobj$data
                   where  signature = 5633991273058209347)) x;
=============  ADDM ============= 
@$ORACLE_HOME/rdbms/admin/addmrpt.sql
================ sqlT SQLHC https://support.oracle.com/epmos/faces/DocumentDisplay?_afrLoop=839173540215425&id=1366133.1&_afrWindowMode=0&_adf.ctrl-state=6azdf5n5n_70
down ban zip Download the SQLHC Script Here (.zip archive).
 sqlplus / as sysdba
SQL> START sqlhc.sql "T" djkbyr8vkc64h
=====Run SQL Tuning Advisor For A Sql_id=================== 
https://dbaclass.com/article/how-to-run-sql-tuning-advisor-for-a-sql_id/
== find the begin snap and end snap of the sql_id.
select a.instance_number inst_id, a.snap_id,a.plan_hash_value, to_char(begin_interval_time,'dd-mon-yy hh24:mi') btime, abs(extract(minute from (end_interval_time-begin_interval_time)) + extract(hour from (end_interval_time-begin_interval_time))*60 + extract(day from (end_interval_time-begin_interval_time))*24*60) minutes,
executions_delta executions, round(ELAPSED_TIME_delta/1000000/greatest(executions_delta,1),4) "avg duration (sec)" from dba_hist_SQLSTAT a, dba_hist_snapshot b
where sql_id='2akzrv8q4darg' and a.snap_id=b.snap_id
and a.instance_number=b.instance_number
order by snap_id desc, a.instance_number;
 
 EXEC :stmt_task := DBMS_SQLTUNE.CREATE_TUNING_TASK( -
  sql_text => 'SELECT quantity_sold FROM sales s, times t WHERE s.time_id = t.time_id AND s.time_id = TO_DATE(''24-NOV-00'')');
  
 DECLARE
  l_sql_tune_task_id  VARCHAR2(100);
BEGIN
  l_sql_tune_task_id := DBMS_SQLTUNE.create_tuning_task (
                          begin_snap  => 8717,
                          end_snap    => 8718,
                          sql_id      => '4wb56udspcc0f',
                          scope       => DBMS_SQLTUNE.scope_comprehensive,
                          time_limit  => 10000,
                          task_name   => '4wb56udspcc0f',
                          description => 'Tuning task for statement 4wb56udspcc0f ');
  DBMS_OUTPUT.put_line('l_sql_tune_task_id: ' || l_sql_tune_task_id);
END;
/

== create tuning task neu ko quan tam toi snap id
DECLARE
  l_sql_tune_task_id  VARCHAR2(100);
BEGIN
  l_sql_tune_task_id := DBMS_SQLTUNE.create_tuning_task (
                          sql_id      => '59n105zvt7w8j',
                          scope       => DBMS_SQLTUNE.scope_comprehensive,
                          time_limit  => 12600,
                          task_name   => '59n105zvt7w8j',
                          description => 'Tuning task1 for statement 59n105zvt7w8j');
  DBMS_OUTPUT.put_line('l_sql_tune_task_id: ' || l_sql_tune_task_id);
END;
/

== excute tuning task
EXEC DBMS_SQLTUNE.execute_tuning_task(task_name => '4wb56udspcc0f'); 
EXEC DBMS_SQLTUNE.execute_tuning_task(task_name => '9dgxuraby4j72'); 

execute dbms_sqltune.accept_sql_profile(task_name => '759ny7m2bu0uz',task_owner => 'SYS', name =>'759ny7m2bu0uz_profile',force_match=> true,replace => TRUE);

== get tuning report
SET LONG 1000000
SET PAGESIZE 500
SET LINESIZE 500
SET PAGESIZE 240
select dbms_sqltune.report_tuning_task('4wb56udspcc0f') from dual;

== get list of tuning task on datbase
SELECT TASK_NAME, STATUS FROM DBA_ADVISOR_LOG WHERE TASK_NAME ='dgud5f3z6a7wy';

==-	Có thể generate 1 script để running advisor của task này
SELECT DBMS_SQLTUNE.SCRIPT_TUNING_TASK(TASK_NAME=>'5hpathm78v2nn',REC_TYPE=>'ALL') script FROM DUAL;

== flush cache cua 1 sql_id
exec for c in (select address,hash_value,users_executing,sql_text from v$sqlarea where sql_id='angjwnm1wckgt') loop sys.dbms_shared_pool.purge(c.address||','||c.hash_value,'...'); end loop;
f-- flush xong kiem tra lai se co ket qua dang SQL_ID: 3sc3wa7zhw2vn, child number: 0 cannot be found 
SELECT * FROM TABLE(DBMS_XPLAN.display_cursor(sql_id=>'5w5ntqhgmcnp0', format=>'ALLSTATS LAST +cost +bytes')); 

== drop a tuning task
execute dbms_sqltune.drop_tuning_task('5hpathm78v2nn');

############################################# fix plan other ############################ https://sites.google.com/site/santoshyandhe/force-baseline-for-different-sql-id
display plan of a sql_id
	SELECT t.* FROM v$sql s, table(DBMS_XPLAN.DISPLAY_CURSOR(s.sql_id, s.child_number)) t WHERE sql_id ='gbkxg1a00k9t3';
	SELECT * FROM table(DBMS_XPLAN.DISPLAY_CURSOR('gbkxg1a00k9t3',0));

To display the execution plan for the SQL statement associated with SQL ID 'gbkxg1a00k9t3' and PLAN HASH 3693697075 in 
the SQL Tuning Set called 'OLTP_optimization_0405":
	SELECT * FROM table (
	   DBMS_XPLAN.DISPLAY_SQLSET(
		   'fxcgshnn0b45t_plan','gbkxg1a00k9t3', 379868110));

Create baseline for SQL which is having good plan 
	var res number ;
	exec :res := dbms_spm.load_plans_from_cursor_cache(sql_id => 'gbkxg1a00k9t3', plan_hash_value => '379868110' );

Check basline with below commands 
	select sql_text, sql_handle, plan_name, enabled, accepted from dba_sql_plan_baselines order by created desc;

Now force this newly created baseline to bad sql which is not performing well
	var res number
	exec :res := dbms_spm.load_plans_from_cursor_cache( -
	sql_id => '<SQL_performing_badly>', -
	plan_hash_value => '<plan_hash_value_of_sql_performing_poorly>', -
	sql_handle => '<SQL_Handle_Of_query_performing_good>');

Drop baseline of good SQL_id (Provide SQL_Handle and Plan_name of good SQL from dab_sql_plan_baselines)
	exec :res :=DBMS_SPM.DROP_SQL_PLAN_BASELINE ('&original_sql_handle','&original_plan_name');
##############################################FIX PLAN#########################################################################
-- tao 1 sql tuning set

exec dbms_sqltune.create_sqlset(sqlset_name => '5ghf614285m9w',description => 'sqlset descriptions for report 5ghf614285m9w');
-- load tu  cursor cache
DECLARE
  cur DBMS_SQLTUNE.SQLSET_CURSOR;
BEGIN
  OPEN cur FOR
    SELECT VALUE(P)
      FROM table(
        DBMS_SQLTUNE.SELECT_CURSOR_CACHE(
          'parsing_schema_name <> ''SYS'' AND elapsed_time > 5000000',
           NULL, NULL, NULL, NULL, 1, NULL,
          'ALL')) P;
 
  DBMS_SQLTUNE.LOAD_SQLSET(sqlset_name => '5ghf614285m9w', populate_cursor => cur);
END;
/
DECLARE
  l_cursor  DBMS_SQLTUNE.sqlset_cursor;
BEGIN
  OPEN l_cursor FOR
     SELECT VALUE(a)
     FROM   TABLE(
              DBMS_SQLTUNE.select_cursor_cache(
                basic_filter   => 'sql_text LIKE ''%SELECT DISTINCT (CASE WHEN :B3 IS NULL THEN NVL%'' and parsing_schema_name = ''APPS''',
                attribute_list => 'ALL')
            ) a;
                                               
 
  DBMS_SQLTUNE.load_sqlset(sqlset_name     => 'c3hzh6svd4x72',
                           populate_cursor => l_cursor);
END;
/
exec :res := dbms_spm.load_plans_from_cursor_cache(sql_id => '53ghpfkptnfwb', plan_hash_value => '610373883' );
-- load tu awr
declare
baseline_ref_cur DBMS_SQLTUNE.SQLSET_CURSOR;
begin
open baseline_ref_cur for
select VALUE(p) from table(
DBMS_SQLTUNE.SELECT_WORKLOAD_REPOSITORY(&begin_snap_id, &end_snap_id,'sql_id='||CHR(39)||'&sql_id'||CHR(39)||'',NULL,NULL,NULL,NULL,NULL,NULL,'ALL')) p;
DBMS_SQLTUNE.LOAD_SQLSET('06kuyd93cucaa', baseline_ref_cur);
end;
/
-- kiem tra lai
SELECT NAME,OWNER,CREATED,STATEMENT_COUNT FROM DBA_SQLSET where name='06kuyd93cucaa';
-- check lai xem co dung plan minh can khong
select * from table(dbms_xplan.display_sqlset('06kuyd93cucaa','06kuyd93cucaa'));

SELECT
  first_load_time          ,
  executions as execs              ,
  parsing_schema_name      ,
  elapsed_time  / 1000000 as elapsed_time_secs  ,
  cpu_time / 1000000 as cpu_time_secs           ,
  buffer_gets              ,
  disk_reads               ,
  direct_writes            ,
  rows_processed           ,
  fetches                  ,
  optimizer_cost           ,
  sql_plan                ,
  plan_hash_value          ,
  sql_id                   ,
  sql_text
   FROM TABLE(DBMS_SQLTUNE.SELECT_SQLSET(sqlset_name => '06kuyd93cucaa')
             );

Neu ko fai thi drop di
BEGIN
  DBMS_SQLTUNE.DROP_SQLSET( sqlset_name => '3b524r5hrvqb7' );
END;
/			 
-- load sqlset vao spm
set serveroutput on
declare
my_int pls_integer;
begin
my_int := dbms_spm.load_plans_from_sqlset (
sqlset_name => '06kuyd93cucaa',
basic_filter=>'plan_hash_value = ''6414713''',
sqlset_owner => 'SYS',
fixed => 'YES',
enabled => 'YES');
DBMS_OUTPUT.PUT_line(my_int);
end;
/
hoac 
execute dbms_sqltune.create_sql_plan_baseline(task_name =>'6kxp0ztha0spd', owner_name => 'SYS', plan_hash_value => '1262498426');
-- kiem tra lai sql_plan_baseine vua duoc load: 1 sql_handle co the co nhieu sql_plan_baseline
select * from dba_sql_plan_baselines where origin not in 'AUTO-CAPTURE';
SELECT SQL_HANDLE, PLAN_NAME, ORIGIN, ENABLED, ACCEPTED, FIXED, MODULE FROM   DBA_SQL_PLAN_BASELINES;
SELECT * FROM   dba_sql_plan_baselines WHERE  sql_handle = 'SQL_532fb8672881fc9c';
-- kiem tra lai  thong so cua sql plan baseline
select t2.*
    from dba_sql_plan_baselines t1,
     table( dbms_xplan.display_sql_plan_baseline(t1.sql_handle,t1.plan_name) ) t2 ;
    
SELECT PLAN_TABLE_OUTPUT
FROM   V$SQL s, DBA_SQL_PLAN_BASELINES b, 
       TABLE(
         DBMS_XPLAN.DISPLAY_SQL_PLAN_BASELINE(b.sql_handle,b.plan_name,'basic') 
       ) t
WHERE  s.EXACT_MATCHING_SIGNATURE=b.SIGNATURE
AND    b.PLAN_NAME=s.SQL_PLAN_BASELINE
AND    s.SQL_ID='dr08qbz3ch75f';

SELECT t.*  FROM TABLE(DBMS_XPLAN.DISPLAY_SQL_PLAN_BASELINE('SQL_532fb8672881fc9c')) t;
-- 1 sql_handle co the co nhieu sql_plan_baseline, ta co the fix baseline cho 1 sql_handle
DECLARE
my_plans pls_integer;
BEGIN
my_plans := DBMS_SPM.ALTER_SQL_PLAN_BASELINE (
sql_handle  => NULL,
plan_name   => 'SQL_3a43571d38e9406f',
attribute_name => 'fixed',
attribute_value => 'YES');
END;
/
--flush cache cua sql_id de no load lai plan
exec for c in (select address,hash_value,users_executing,sql_text from v$sqlarea where sql_id='06kuyd93cucaa') loop sys.dbms_shared_pool.purge(c.address||','||c.hash_value,'...'); end loop;

--KHI THUC HIEN LAI CAU LENH, KIEM TRA CO AN THEO PLAN HAY KO
select sql_id,plan_hash_value,sum(executions),sql_plan_baseline,id,object_name from v$sql join v$sql_plan using(sql_id,plan_hash_value,child_number) where sql_id='a5f62hfxgm8j2' and id=1 group by sql_id,plan_hash_value,sql_plan_baseline,id,object_name order by 3; 

   - SQL plan baseline SQL_PLAN_8bfbaxdc46zfh8c58cc1b used for this statement
-- co the enable trace cho sql_plan base line trong /trace/
alter session set events 'trace [SQL_Plan_Management.*]';

-- xoa bot sql plan baseline
declare drop_result pls_integer; begin 
drop_result := DBMS_SPM.DROP_SQL_PLAN_BASELINE( sql_handle => 'SQL_9865e65bc82d59a9', plan_name => 'SQL_PLAN_9htg6bg42uqd9035f9809'); 
dbms_output.put_line(drop_result); end; 
==================================SQL PLAN BASELINE FROM CURSOR CACHE ===============================================
(1) tao sql plan baseline cho cau lenh xau tu cursor
SELECT * FROM TABLE(DBMS_XPLAN.display_cursor(sql_id=>'crtpafjsdxdt2', format=>'ADVANCED')); 

var v_num number;
exec :v_num:=dbms_spm.load_plans_from_cursor_cache(sql_id => 'crtpafjsdxdt2',plan_hash_value => 2814850033 );

(2) chay cau lenh version tot, va tao 1 sql plan baseline cua version tot nay
var v_num number;
exec :v_num:=dbms_spm.load_plans_from_cursor_cache(sql_id => '0ajawn4vq15td',plan_hash_value => 2129261894 );

(3) Kiem tra lai sql plan baseline de xem 2 sql plan baseline vua tao ra
select sql_text, sql_handle, plan_name, enabled, accepted from dba_sql_plan_baselines;
 SELECT t.*  FROM TABLE(DBMS_XPLAN.DISPLAY_SQL_PLAN_BASELINE('SQL_3511fe431a564a34')) t;
	
(4) chay lai cau lenh version tot	, lay sql_id + plan_hash_value cua cau lenh tot
SELECT * FROM TABLE(DBMS_XPLAN.display_cursor(sql_id=>'0ajawn4vq15td', format=>'ADVANCED')); 
0ajawn4vq15td 2129261894

(5) Load sql_id+plan_hash_Value nay vao sql plan baseline cua cau lenh xau da tao o buoc 1
SET SERVEROUTPUT ON
DECLARE
  l_plans_loaded  PLS_INTEGER;
BEGIN
dbms_spm.configure('spm_tracing',1);
  l_plans_loaded := DBMS_SPM.load_plans_from_cursor_cache(
    sql_id => '0ajawn4vq15td',
    plan_hash_value => 2129261894,
    sql_handle => 'SQL_3511fe431a564a34');
  DBMS_OUTPUT.put_line('Plans Loaded: ' || l_plans_loaded);
   dbms_spm.configure('spm_tracing',0);

END;
/

Plans Loaded: 1

PL/SQL procedure successfully completed.
(6) flush cache cua cau lenh xau de nhan plan moi		
exec for c in (select address,hash_value,users_executing,sql_text from v$sqlarea where sql_id='92vsp5v5jqs3k') loop sys.dbms_shared_pool.purge(c.address||','||c.hash_value,'...'); end loop;

SELECT SQL_HANDLE, PLAN_NAME, ORIGIN, ENABLED, ACCEPTED, FIXED, MODULE FROM   DBA_SQL_PLAN_BASELINES where accepted='YES';
SET SERVEROUTPUT ON
DECLARE
  l_plans_altered  PLS_INTEGER;
BEGIN
  l_plans_altered := DBMS_SPM.alter_sql_plan_baseline(
    sql_handle      => 'SQL_3511fe431a564a34',
    plan_name       => 'SQL_PLAN_3a4gy8cd5ckjna7c733f1',
    attribute_name  => 'ENABLED',
    attribute_value => 'NO');

  DBMS_OUTPUT.put_line('Plans Altered: ' || l_plans_altered);
END;
/
	 
SELECT * FROM TABLE(DBMS_XPLAN.display_cursor(sql_id=>'ak9df30dv9uj7', format=>'ADVANCED')); 


====================================================================================================================
==========ASH report 
@ORACLE_HOME/rdbms/admin/ashrpt.sql
#########================ create STS of a sql_id from awr=====================================
-- tao STS
begin
 DBMS_SQLTUNE.CREATE_SQLSET(SQLSET_NAME => 'g0pq037056tw6', DESCRIPTION => 'TEST SQL TUNE SET');
 END;
 /
 
 -- VERIFY SQL MONITORING IS ENABLED FOR SQL STATEMENTS 
SELECT DBMS_SQLTUNE.report_sql_monitor(type => 'TEXT', report_level=>'ALL', SQL_ID=>'g0pq037056tw6') AS REPORT FROM DUAL;

-- check snap_id co chua sql_id minh can cho vao STS
select a.instance_number inst_id, a.snap_id,a.plan_hash_value, to_char(begin_interval_time,'dd-mon-yy hh24:mi') btime, abs(extract(minute from (end_interval_time-begin_interval_time)) + extract(hour from (end_interval_time-begin_interval_time))*60 + extract(day from (end_interval_time-begin_interval_time))*24*60) minutes,
executions_delta executions, round(ELAPSED_TIME_delta/1000000/greatest(executions_delta,1),4) "avg duration (sec)" from dba_hist_SQLSTAT a, dba_hist_snapshot b
where sql_id='g0pq037056tw6' and a.snap_id=b.snap_id
and a.instance_number=b.instance_number
order by snap_id desc, a.instance_number;

-- POPULATE ‘SQL TUNING SET’ 
DECLARE
 CUR SYS_REFCURSOR;
 BEGIN
 OPEN CUR FOR
 SELECT VALUE(P) FROM TABLE ( DBMS_SQLTUNE.SELECT_WORKLOAD_REPOSITORY(BEGIN_SNAP=>5622, END_SNAP=>5624, BASIC_FILTER=> 'sql_id = ''g0pq037056tw6''', ATTRIBUTE_LIST=>'ALL' )) p;
 DBMS_SQLTUNE.LOAD_SQLSET(SQLSET_NAME=> 'g0pq037056tw6', POPULATE_CURSOR=>CUR);
 CLOSE CUR;
 END;
 /

 -- kiem tra lai STS co nhung sql nao
 SELECT * FROM TABLE(DBMS_SQLTUNE.SELECT_SQLSET(SQLSET_NAME => 'g0pq037056tw6'));
  
 set linesize 180
col SQL_ID format a13
col SCHEMA format a5
col COMMAND_TYPE format 99
col PRIORITY format 9
col SQL_TEXT format a50
SELECT SQL_ID, PARSING_SCHEMA_NAME SCHEMA, COMMAND_TYPE, PRIORITY ,
SUBSTR(SQL_TEXT,1,50) SQL_TEXT
FROM TABLE( DBMS_SQLTUNE.SELECT_SQLSET( 'g0pq037056tw6' ) );

---	Create a SQL Access Advisor task
VARIABLE V_TASK_NAME VARCHAR2(20)
exec :V_TASK_NAME := 'SAA_g0pq037056tw6';
VARIABLE TASK_ID VARCHAR2(50)
exec DBMS_ADVISOR.CREATE_TASK(ADVISOR_NAME=>'SQL Access Advisor',TASK_ID=>:TASK_ID, TASK_NAME=>:V_TASK_NAME, TASK_DESC=>'A task to test using the SQL Access Advisor')


--- display the SAA va value cua no
col PARAMETER_NAME format a22
col VALUE format a15
col DEF format a2
col DESCRIPTION format a50
VARIABLE V_TASK_NAME VARCHAR2(20)
exec :V_TASK_NAME := 'SAA_g0pq037056tw6';
SELECT PARAMETER_NAME , PARAMETER_VALUE VALUE, IS_DEFAULT DEF, DESCRIPTION
FROM USER_ADVISOR_PARAMETERS where TASK_NAME= :V_TASK_NAME;




---	Ta link link the SQL Access Advisor task với workload (STS) đã tạo 
exec DBMS_ADVISOR.ADD_STS_REF(:V_TASK_NAME, 'SYS', 'g0pq037056tw6')

--	Execute the SQL access Task
exec DBMS_ADVISOR.EXECUTE_TASK(:V_TASK_NAME)

--Có thể check progress của task
col TASK_ID FORMAT 9999
col TASK_NAME FORMAT a25
col STATUS_MESSAGE FORMAT a40
SELECT TASK_ID, TASK_NAME, STATUS, STATUS_MESSAGE
FROM USER_ADVISOR_LOG WHERE TASK_NAME=:v_task_name;

---	Run the script to view the recommendations of the SQL Access Advisor task:
@display_myrecommendations.sql

vi display_myrecommendations.sql

-- -------------Display attributes of the recommendations
CREATE OR REPLACE PROCEDURE show_recm (in_task_name IN VARCHAR2) IS
CURSOR curs IS
 SELECT DISTINCT ACTION_ID, COMMAND, ATTR1, ATTR2, ATTR3, ATTR4
 FROM USER_ADVISOR_ACTIONS
 WHERE TASK_NAME = in_task_name
 ORDER BY ACTION_ID;
v_action number;
v_command VARCHAR2(32);
v_attr1 VARCHAR2(4000);
v_attr2 VARCHAR2(4000);
v_attr3 VARCHAR2(4000);
v_attr4 VARCHAR2(4000);
v_attr5 VARCHAR2(4000);
BEGIN
OPEN curs;
DBMS_OUTPUT.PUT_LINE('=========================================');
DBMS_OUTPUT.PUT_LINE('Task_name = ' || in_task_name);
LOOP
FETCH curs INTO
v_action, v_command, v_attr1, v_attr2, v_attr3, v_attr4 ;
EXIT when curs%NOTFOUND;
DBMS_OUTPUT.PUT_LINE('Action ID: ' || v_action);
DBMS_OUTPUT.PUT_LINE('Command : ' || v_command);
DBMS_OUTPUT.PUT_LINE('Attr1 (name) : ' || SUBSTR(v_attr1,1,30));
DBMS_OUTPUT.PUT_LINE('Attr2 (tablespace): ' || SUBSTR(v_attr2,1,30));
DBMS_OUTPUT.PUT_LINE('Attr3 : ' || SUBSTR(v_attr3,1,30));
DBMS_OUTPUT.PUT_LINE('Attr4 : ' || v_attr4);
DBMS_OUTPUT.PUT_LINE('Attr5 : ' || v_attr5);
DBMS_OUTPUT.PUT_LINE( ' ----------------------------------------');
END LOOP;
CLOSE curs;
DBMS_OUTPUT.PUT_LINE('=========END RECOMMENDATIONS============');
END show_recm;
/
set serveroutput on size 99999
EXECUTE show_recm(:V_TASK_NAME);

-------------	The script displays the script that implements the advior recommendations.

vi display_task_script.sql
set long 100000
set pagesize 50000$file scattered read issues a scatter-read to read the data into multiple discontinuous memory locations. 
A scattered read is usually a multiblock read. It can occur for a fast full scan (of an index) in addition to a full table scan.
- enq: TX - row lock contention: can also be related to buffer busy waits, in conditions where multiple transaction attempt to update the same data blocks. 
TX enqueue is issued when a transaction makes its first change, and released when the transaction performs a COMMIT or ROLLBACK
- latch free wait event occurs when a session needs a latch, tries to get the latch, but fails because someone else has it
-read by other session: When a session waits on the “read by other session” event, it indicates a wait for another session to read the data from disk into the Oracle buffer cache. Xay ra khi nhieu ss cung muon read 1 du lieu
-cursor: pin S wait on X: There are three main causes to sessions waiting on this event.High hard parses ,A high number of versions of the SQL statement,Bugs
- Execute to parse ratio is a measure of how many times we execute a sql statement versus parse it
This 'ratio' will go towards 100 as the number of executes goes up and up, while the number of parses remains the same. 
It will go to zero as the number of parses and executes are equal 
It'll go negative if you parse more than you execute. 
- Soft Parse vs Hard Parse: Soft Parse tiet kiem duoc qua trinh load vao share pool: The SQL source code is loaded into RAM

-High waits for library cache mutex x can be due to: 
Not pinning hot PL/SQL with dbms_shared_pool.markhot.
A too-small value for shared_pool_size (memory_target).
Setting cursor_sharing=similar (which should be changed to exact or force).
Settings for session_cached_cursors.
_kgl_hot_object_copies la tham so chi thi so version duoc clone.

-- markhot cho procedure/package/package body
exec dbms_shared_pool.markhot('SYS','DBMS_LOCK',1);
exec dbms_shared_pool.markhot('SYS','DBMS_LOCK.REQUEST',1);
exec dbms_shared_pool.markhot('SYS','DBMS_LOCK.RELEASE',1);
--- markhot cho sql_id 8p8tuj548avg0, a279wsnummrr1,7w8hhhdstfxa6
select kglnahsv from v$sql, x$kglob
where kglhdadr=address
and sql_id = 'avw25s51n9hdu';
exec dbms_shared_pool.markhot('&KGLNAHSV', 0);

begin :1 :=dbms_lock.release(:2 ); end;
---- unmarkhot cho procedure/package/package body

exec dbms_shared_pool.markhot('T24CORE','T24_REQUEST_UNIQUE_LOCK',1);
exec dbms_shared_pool.markhot('T24CORE','T24_RELEASE_UNIQUE_LOCK',1);

-- kiem tra lai
select inst_id,kglnaown,kglnaobj,kglnahsh,kglnahsv from x$kglob where kglobprop='HOT';

select kglnahsh, kglnahsv from v$sql, x$kglob where kglhdadr=address and sql_id = '8p8tuj548avg0';

select inst_id, hash_value, namespace, child_latch, property, status, sum(executions) executions, name
from gv$db_object_cache where hash_value = 1216703968
group by inst_id, hash_value, name, namespace, child_latch, property, status order by hash_value;
    
 


-log file parallel write: lien quan toi qua trinh cua LGWR
- The log file sequential read Oracle metric indicates that the process is waiting for blocks to be read from the online redo log into memory. 
This primarily occurs at instance startup and when the ARCH process archives filled online redo logs.
- The db file parallel write event belongs only to the DBWR process
-Parse CPU to Parse Elapsd: thoi gian CPU su dung de parse, nen cao, neu thap la do fai doi resource nao do khi parse
-TX-Transaction (row lock contention) event often indicates an application level locking problem. 
The TX enqueue is the transaction enqueue (a.k.a. enq: TX - contention) and can also be related to buffer busy waits, in conditions where multiple transaction attempt to update the same data blocks. 
TX enqueue is issued when a transaction makes its first change, and released when the transaction performs a COMMIT or ROLLBACK.

- Av Rds/s : Number of physical reads per second
- Av Rd(ms) : Average read time of physical read
- 1-bk Rds/s : Number of single block reads per second
- Av 1-bk Rd(ms) : Average read time of single block read

- enq: JI - contention : lien quan toi lock tren Materialized View 
SELECT eq_name "Enqueue",
         ev.name "Enqueue Type",
         eq.req_description "Description"
    FROM v$enqueue_statistics eq, v$event_name ev
   WHERE eq.event# = ev.event# AND ev.name = 'enq: JI - contention'
ORDER BY ev.name; 
- TCP Socket (KGAS): A session is waiting for an external host to provide requested data over a network socket

-- check IO: https://www.oraclenext.com/2018/03/reading-and-understanding-awr-report_19.html
ioStat by function summary    Wait event histogram  	File io stats (Av Rd(ms) >30ms la cao )
db file sequential read – Random I/O , single row , mostly index IO
db file scattered Read – Sequential I/O , Full table scan, index fast full scan
direct path read – Sequential I/O , Full table scan , directly to the PGA
direct path read temp – Read I/O for sorts
direct path write temp – Write I/O for sorts
read by other session – sessions waiting  while another session is reading the same from the disk. 

+++++++++++++ a HOC ATNA tool awr ++++++++++++++++++++
SQL> @$ORACLE_HOME/rdbms/admin/awrrpt.sql
Enter value for num_days: 5 -- chon 5 ngay
Specify the Begin and End Snapshot Ids -- chon begin va end snapshot
Report written to awrrpt_2_15310_15311.html -- snapshot chay xong
SQL> exit

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Enter value for begin_snap: 15310
Begin Snapshot Id specified: 15310

Enter value for end_snap: 15311  
End   Snapshot Id specified: 15311


++++++++++++ a Hiep Hyper +++++++++++++++ dung tool awrrpt.sql +++++++++++++++++++++++++++
@?/rdbms/admin/awrrpt.sql      -- basic AWR report
@?/rdbms/admin/awrsqrpt.sql    -- Standard SQL statement Report
@?/rdbms/admin/awrddrpt.sql    -- Period diff on current instance
@?/rdbms/admin/awrrpti.sql     -- Workload Repository Report Instance (RAC)
@?/rdbms/admin/awrgrpt.sql     -- AWR Global Report (RAC)
@?/rdbms/admin/awrgdrpt.sql    -- AWR Global Diff Report (RAC)
@?/rdbms/admin/awrinfo.sql     -- Script to output general AWR information
-bash-3.2$ cd /u01/oracle/product/10.2/kmtd4/rdbms/admin/
-bash-3.2$ sqlplus / as sysdba
SQL> @awrrpt.sql
Enter value for num_days: 1

Specify the Report Name
~~~~~~~~~~~~~~~~~~~~~~~
The default report file name is awrrpt_1_22127_22128.html.  To use this name,
press <return> to continue, otherwise enter an alternative.

Enter value for report_name: /tmp/awrrpt_1_22127_22128.html

== control = lenh sau truoc khi test
exec dbms_workload_repository.create_snapshot();
= sau khi test thi thuc hien ket thuc
exec dbms_workload_repository.create_snapshot();
+++++++++++++++++++++++ select long querry ++++++++++++++++++++++
set linesize 9999;
select s.username,s.sid,s.serial#,s.last_call_et/60 mins_running,q.sql_text from v$session s 
join v$sqltext_with_newlines q
on s.sql_address = q.address
 where status='ACTIVE'
and type <>'BACKGROUND'
and last_call_et> 60
order by sid,serial#,q.piece;
-- dang nay la bi treo job  update sys.job$ set this_date=:1 where job=:2
+++++++++++++++ export env++++++++++++++
------- cac thu muc quan trong nhat cua grid -----------
dung cp -p de reserve moi dac tinh
cp -p /app/oracle/oraInventory/ContentsXML/inventory.xml /app/oracle/oraInventory/ContentsXML/inventory.xml.bk
cp -p /var/opt/oracle/oratab /var/opt/oracle/oratab.bk

cp -p /var/opt/oracle/oraInst.loc  /var/opt/oracle/oraInst.loc.bk  -- thu muc nay se duoc doc dau tien khi setup ; 
																																	-- khi attachhome cai oracle, file oraInst nay se duoc doc de tim ra oraInventory  - log se nam trong oraInventory/logs  			
																																			RAC1node$ /app/oracle/12.1/orahome/oui/bin/runInstaller -attachHome -noClusterEnabled ORACLE_HOME=/app/oracle/12.1/orahome ORACLE_HOME_NAME=OraDB12Home1 CLUSTER_NODES=evs-db01,evs-db02 -force "INVENTORY_LOCATION=/app/oraInventory" LOCAL_NODE=evs-db02		
                                                                      Starting Oracle Universal Installer...                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                          
                                                                      Checking swap space: must be greater than 500 MB.   Actual 55349 MB    Passed                                                                                                                                                                             
                                                                      The inventory pointer is located at /var/opt/oracle/oraInst.loc    
                                                                  -- update nodelist- log se nam trong oraInventory/logs
                                                                   		RAC1node$ /app/oracle/12.1/orahome/oui/bin/runInstaller -updateNodeList -setCustomNodelist -noClusterEnabled ORACLE_HOME=/app/oracle/12.1/orahome CLUSTER_NODES=evs-db01,evs-db02 "NODES_TO_SET={evs-db01,evs-db02}" CRS=false  "INVENTORY_LOCATION=/app/oraInventory" LOCAL_NODE=evs-db02                                                                                                                                                                                       

cp -p /var/opt/oracle/ocr.loc /var/opt/oracle/ocr.loc.bk --file chua thong tin ocr cho cluster
-- oratab file, thong tin ko con dung thi xoa di lien quan toi asm, grid, oracle
Linux/AIX/HP: /etc/oratab
Solaris: /var/opt/oracle/oratab
------ tao lai file oraInventory
no se doc trong file nay de tim toi oraInventory
/var/opt/oracle/oraInst.loc   hoac /etc/OraInst.loc vs AIX
				inventory_loc=/app/oraInventory   => co quyen 777/775 grid:oinstall la tot nhat
				inst_group=oinstall

-- thuc hien tao lai oraInventory cho grid
su - grid
cd $ORACLE_HOME/oui/bin
./runInstaller -silent -ignoreSysPrereqs -attachHome ORACLE_HOME="/app/grid/12.1/grid" ORACLE_HOME_NAME="grid12_1_home"

---- CHECK INVENTORY, cac patch da duoc install cua oracle hoac grid ,
WITH a AS (SELECT dbms_qopatch.get_opatch_bugs patch_output FROM DUAL)
SELECT x.*
  FROM a,
       XMLTABLE (
          'bugInfo/bugs/*'
          PASSING a.patch_output
          COLUMNS bug_id NUMBER PATH '@id',
                  description VARCHAR2 (160) PATH 'description') x;
				  
$ORACLE_HOME/OPatch/opatch lsinventory

-- For 12c and 18c 
set lin 1000
col action form a12
col version  form a40
col description form a85
col action_date form a20
select description, action, to_char(action_time,'DD/MM/RR HH24:MI:SS') action_date, ' ' version
from dba_registry_sqlpatch;

-- 11g version 
set lin 1000
col action form a12
col version  form a40
col comments form a70
col action_date form a20
select comments, action, to_char(action_time,'DD/MM/RR HH24:MI:SS') action_date, version
from registry$history
order by action_date

-- find oracle_home
ps -ef|grep smon
pwdx 1st
or find / -name init.ora
-- find sid in linux: cat /etc/oratab 
cat /var/opt/oracle/oratab
or cat $ORACLE_HOME/network/admin/tnsnames.ora
---- co the tim ca trong lsnrctl status
export ORACLE_SID=kmtd
export ORACLE_HOME=/u02/oracle/102
export PATH=$PATH:$ORACLE_HOME/bin

===================chungt attach lai orainventory
grid#$GRID_HOME/oui/bin/runInstaller -silent -ignoreSysPrereqs -attachHome ORACLE_HOME="/u01/app/11.2.0/grid" ORACLE_HOME_NAME="Ora11g_gridinfrahome1" LOCAL_NODE="dr-bdmdb01" CLUSTER_NODES="dr-bdmdb01,dr-bdmdb02" CRS=true
oracle#$ORACLE_HOME/oui/bin/runInstaller -silent -ignoreSysPrereqs -attachHome ORACLE_HOME="/u01/app/oracle/product/11.2.0/dbhome_1" ORACLE_HOME_NAME="OraDb11g_home1" LOCAL_NODE="dr-bdmdb01" CLUSTER_NODES="dr-bdmdb01,dr-bdmdb02"
============== TAO INDEX PARTITION LOCAL
CREATE BITMAP INDEX FTP.GLFT_MASTER_ETLDATE_IDX ON FTP.GLFT_MASTER(ETL_DATE) LOCAL PARALLEL NOLOGGING;
CREATE BITMAP INDEX amlmcob.TBQANSW$BRANCH ON amlmcob.TBQANSW(BRANCH) LOGGING TABLESPACE AMLTAB NOPARALLEL;

 DROP INDEX FTP.GLFT_MASTER_ETLDATE_IDX;
 alter index FTP.GLFT_MASTER_ETLDATE_IDX noparallel;
alter index B2CRISK.IDX_TBTR_TRANSACTION_PSTD rebuild partition TBTR_TRANSACTION_042020 ONLINE ;
alter index B2CRISK.IDX_TBTR_TRANSACTION_PSTD modify partition TBTR_TRANSACTION_042020 unusable;

select ' DROP INDEX FTP.'|| indx_name from
(
select distinct(index_name) indx_name from ftp.bitmap_index where partition_name is not null;
)

SELECT  'CREATE BITMAP INDEX FTP.'||INDEX_NAME|| ' ON FTP.'||TABLE_NAME||'('||LISTAGG(COLUMN_NAME, ',') WITHIN GROUP (ORDER BY COLUMN_NAME)||') LOCAL PARALLEL NOLOGGING;'
    FROM
    (
    SELECT DISTINCT INDEX_NAME,TABLE_NAME,COLUMN_NAME
    FROM ftp.bitmap_index where partition_name is not null
   --AND INDEX_NAME='PMFT_INSTR_BU_IDX'
    )
        GROUP BY INDEX_NAME,TABLE_NAME;
==================== oldest flashback
SELECT to_char(oldest_flashback_time, 'YYYY-MM-DD HH24:MI:SS') FROM v$flashback_database_log;
22:11

============================ transform physical standby to logical standby va nguoc lai
ALTER DATABASE RECOVER MANAGED STANDBY DATABASE CANCEL;


--Prepare the primary database for role transition by setting an additional archive log destination that is to be used only if the primary is in a logical standby role to archive its own archive logs received from the primary in contrast to archiving logs in primary role from transactions against the primary.
alter system set LOG_ARCHIVE_DEST_3='LOCATION=+DATA/ VALID_FOR=(STANDBY_LOGFILES,STANDBY_ROLE) DB_UNIQUE_NAME=RAC10G' scope=both sid='*';

alter system set LOG_ARCHIVE_DEST_STATE_3=ENABLE scope=both sid=’*’;

Build a dictionary by executing on the primary database the following command.
EXECUTE DBMS_LOGSTDBY.BUILD;
create restore point BEFORE_COB_220323 guarantee flashback database;

Convert the physical standby database to logical standby by issuing the following statement on the standby database. Before that make sure that CLUSTER_DATABASE=false.
-- chay tren standby database
create restore point rs_physical_standby guarantee flashback database;
alter system set CLUSTER_DATABASE=false scope=spfile sid='*';
srvctl stop database ewalletdr;
sqlplus / as sysdba
startup mount;
ALTER DATABASE RECOVER TO LOGICAL STANDBY Keep identity;  -- fai co dong sau NET  (PID:303284): Database role changed from PHYSICAL STANDBY to LOGICAL STANDBY
shutdown immediate;
startup ;
--- fai co gia tri 100 moi chay tiep dong bo
SELECT PERCENT_DONE, COMMAND
FROM V$LOGMNR_DICTIONARY_LOAD
WHERE SESSION_ID = (SELECT SESSION_ID FROM V$LOGSTDBY_STATE);

alter system set LOG_ARCHIVE_DEST_3='LOCATION=+DATA VALID_FOR=(STANDBY_LOGFILES,STANDBY_ROLE) DB_UNIQUE_NAME=testdr' scope=both sid='*';
alter system set LOG_ARCHIVE_DEST_STATE_3=ENABLE scope=both sid='*';


ALTER DATABASE OPEN 

alter database add standby logfile THREAD 1 group 211 ('+DATA','+ORALOG') SIZE 2G;
alter database add standby logfile THREAD 1 group 212 ('+DATA','+ORALOG') SIZE 2G;
alter database add standby logfile THREAD 1 group 213 ('+DATA','+ORALOG') SIZE 2G;
alter database add standby logfile THREAD 1 group 214 ('+DATA','+ORALOG') SIZE 2G;
alter database add standby logfile THREAD 1 group 215 ('+DATA','+ORALOG') SIZE 2G;
alter database add standby logfile THREAD 1 group 216 ('+DATA','+ORALOG') SIZE 2G;
alter database add standby logfile THREAD 1 group 217 ('+DATA','+ORALOG') SIZE 2G;
alter database add standby logfile THREAD 1 group 218 ('+DATA','+ORALOG') SIZE 2G;
alter database add standby logfile THREAD 2 group 221 ('+DATA','+ORALOG') SIZE 2G;
alter database add standby logfile THREAD 2 group 222 ('+DATA','+ORALOG') SIZE 2G;
alter database add standby logfile THREAD 2 group 223 ('+DATA','+ORALOG') SIZE 2G;
alter database add standby logfile THREAD 2 group 224 ('+DATA','+ORALOG') SIZE 2G;
alter database add standby logfile THREAD 2 group 225 ('+DATA','+ORALOG') SIZE 2G;
alter database add standby logfile THREAD 2 group 226 ('+DATA','+ORALOG') SIZE 2G;
alter database add standby logfile THREAD 2 group 227 ('+DATA','+ORALOG') SIZE 2G;
alter database add standby logfile THREAD 2 group 228 ('+DATA','+ORALOG') SIZE 2G;
--- fai co gia tri 100 moi chay tiep dong bo
SELECT PERCENT_DONE, COMMAND
FROM V$LOGMNR_DICTIONARY_LOAD
WHERE SESSION_ID = (SELECT SESSION_ID FROM V$LOGSTDBY_STATE);

Start SQL apply
SQL> ALTER DATABASE START LOGICAL STANDBY APPLY IMMEDIATE;


---------- chuyen tu logical standby sang physical standby
shutdown immediate;
startup mount;
flashback database to restore point rs_physical_standby;
shutdown immediate;
startup mount;
alter database convert to physical standby;
- n truong hop gap loi MRP0: Background Media Recovery waiting for new incarnation during transient logical upgrade procedure. Thi thuc hien
alter system set "_transient_logical_clear_hold_mrp_bit"=TRUE SCOPE=BOTH;
alter database recover managed standby database disconnect;

============================== logical standby database
ALTER DATABASE START LOGICAL STANDBY APPLY IMMEDIATE;
ALTER DATABASE START LOGICAL STANDBY APPLY IMMEDIATE SKIP FAILED TRANSACTION;
ALTER DATABASE STOP LOGICAL STANDBY APPLY;
-- xem dictionary da load chua

select state from v$logstdby_state;
-- co gia tri 100 la done
SELECT PERCENT_DONE, COMMAND
FROM V$LOGMNR_DICTIONARY_LOAD
WHERE SESSION_ID = (SELECT SESSION_ID FROM V$LOGSTDBY_STATE);
--- If the value of STATE is "NULL" or "SQL APPLY NOT ON" then the Sql Apply is not running.
select * from v$logstdby_state;

-- xem log da duoc apply
SELECT * FROM V$LOGSTDBY_PROCESS;
select thread#, sequence#, file_name, applied from dba_logstdby_log where applied!= 'YES';

-------- xem event cua logical standby. 
SET LINESIZE 200
SET LONG 400
SET PAGESIZE 999
column EVENT_TIME FORMAT A20
column STATUS FORMAT A50
column CURRENT_SCN 999999999999999
column COMMIT_SCN 999999999999999
column XIDUSN FORMAT 999999
column XIDSLT FORMAT 999999
column XIDSQN FORMAT 999999
SELECT TO_CHAR(EVENT_TIME,'YYYY/MM/DD HH24:MI:SS') "EVENT_TIME", STATUS, CURRENT_SCN, COMMIT_SCN, XIDUSN, XIDSLT, XIDSQN
FROM DBA_LOGSTDBY_EVENTS
WHERE EVENT_TIME > SYSDATE-1
ORDER BY EVENT_TIME;

----- skip transaction nao do
exec dbms_logstdby.skip_transaction(63,8 ,315 );
SELECT 'exec dbms_logstdby.skip_transaction( '||XIDUSN||','|| XIDSLT||','|| XIDSQN||');' FROM DBA_LOGSTDBY_EVENTS where ...

-- xem applied log
select thread# trd, sequence#,
first_change#, next_change#,
dict_begin beg, dict_end end,
to_char(timestamp, 'hh:mi:ss') timestamp,
(case when l.next_change# < p.read_scn then 'YES'
when l.first_change# < p.applied_scn then 'CURRENT'
else 'NO' end) applied
from dba_logstdby_log l, dba_logstdby_progress p
order by thread#, first_change#;

--- dung cai nay ma trace, biet duoc dang doc log nao
select thread#, sequence#, file_name, applied from dba_logstdby_log where applied!= 'YES';

select a.sequence_received,a.thread,b.sequence_applied,b.thread from (select max(sequence#) sequence_received,thread# thread from dba_logstdby_log group by thread#) a,
(select max(sequence#) sequence_applied,thread# thread from dba_logstdby_log where applied='YES' group by thread#) b where a.thread=b.thread;

-- check gap
select latest_time,applied_time,mining_time, (latest_time-applied_time)*24*3600 gap_in_second from V$logstdby_progress;

SELECT TYPE, STATUS, HIGH_SCN  FROM V$LOGSTDBY;
- co the so vs next_change# tren primary
select * from v$archived_log order by next_change# desc;;


--- schema auto skip
select owner from dba_logstdby_skip where statement_opt = 'INTERNAL SCHEMA' order by owner;
-- Find list of objects are not supported, co thay doi truong ko support thi cung se ko dong bo duoc
-- Neu 1 table co 1 or nhieu columns thuoc unsupported datatype thi ca bang se bi ignored boi sql apply
--Trong nay co the la bang thuc su bi ignore hoac bang chi co 1 truong blob, clob , ko co gi de xac dinh tinh duy nhat cua row
select distinct owner, table_name from dba_logstdby_unsupported order by owner,table_name;
-- Trong nay Bad_column = Y thi nghia la chua cac truong dang ko xd dc tinh duy nhat nhu long/blob. Co the gap loi LOGSTDBY: SQL Apply about to stop with ORA-1422. ORA-01422: exact fetch returns more than requested number of rows khi update cac truong nay
-- Khong chi la unique, con fai co constraints primary key moi dam bao
-- ko can disable trigger tren dich
COL OWNER FOR A10
COL TABLE_NAME FOR A10
SET LINES 190
SELECT OWNER, TABLE_NAME,BAD_COLUMN FROM DBA_LOGSTDBY_NOT_UNIQUE;

select owner, table_name from dba_logstdby_not_unique where (owner, table_name) not in (select distinct owner, table_name from dba_logstdby_unsupported) order by owner, table_name;
================== Vinh snapshot standby =================================
SYS@STANDBY> alter database recover managed standby database cancel;
Database altered.
Enable flashback mode:
05:59:54 SYS@STANDBY> shutdown immediate
06:00:44 SYS@STANDBY> startup mount;

Database mounted.
  
06:07:28 SYS@TESTER1 SQL> alter database flashback on;

SYS@TESTER1 SQL> alter database convert to snapshot standby;
Database altered.
Standby became primary SCN: 7688024468650
2022-09-09T08:06:21.267412+07:00
Setting recovery target incarnation to 188
187     187     T24COB   446130575        PARENT  7677474760647 01-SEP-22  --- dc hien tai
188     188     T24COB   446130575        CURRENT 7688024468653 09-SEP-22

SYS@TESTER1 SQL> alter database open;

------------------------------------------------------------------------------------------------------
Let convert it again to physical standby again.

SYS@TESTER1 SQL> shutdown immediate;

SYS@TESTER1 SQL> startup mount

SYS@TESTER1 SQL> select FLASHBACK_ON from v$database;
FLASHBACK_ON

SYS@TESTER1 SQL> alter database convert to physical standby;
Database altered.
Physical Standby Database mounted.
CONVERT TO PHYSICAL STANDBY: Complete - Database mounted as physical standby

SYS@TESTER1 SQL> select status from v$instance;
STATUS
------------
STARTED
1 row selected.
SYS@TESTER1 SQL> shut immediate

SYS@TESTER1 SQL> startup

Database opened.
SYS@TESTER1 SQL>ALTER DATABASE RECOVER MANAGED STANDBY DATABASE USING CURRENT LOGFILE DISCONNECT FROM SESSION;
SYS@TESTER1 SQL> select open_mode from v$database;

================================= move object khoi tablespace ORS  drop tablespace
select * from dba_tables where tablespace_name='APPSHIST';
select 'alter index '||owner||'.'||index_name||' rebuild tablespace WAY4RPT online parallel 16;' from dba_indexes where tablespace_name='WAY4RPTIDX';
select * from dba_tab_partitions where tablespace_name='APPSHIST';
select 'alter index '||index_owner||'.'||index_name||' rebuild partition '||partition_name||' tablespace WAY4RPT online parallel 16;' from dba_ind_partitions where tablespace_name='WAY4RPTIDX';
DROP TABLESPACE  WAY4RPTIDX;  -- khi k con object nao thi co the drop nhu nay, chay asm no se tu xoa Deleted Oracle managed file

---modify default attribute 
select 'ALTER TABLE '||owner||'.'||table_name||' MODIFY DEFAULT ATTRIBUTES TABLESPACE NOENCRYPT;' from dba_tables where tablespace_name='ENCRYPT';
select 'ALTER INDEX '||OWNER||'.'||'INDEX_NAME MODIFY DEFAULT ATTRIBUTES TABLESPACE NOENCRYPT;'  from dba_indexes where tablespace_name='ENCRYPT';
SELECT 'ALTER INDEX '||OWNER||'.'||INDEX_NAME||' MODIFY DEFAULT ATTRIBUTES TABLESPACE NOENCRYPT;' FROM DBA_PART_INDEXES WHERE DEF_TABLESPACE_NAME='ENCRYPT';
SELECT    'ALTER TABLE '|| OWNER|| '.' || TABLE_NAME|| '  MODIFY DEFAULT ATTRIBUTES TABLESPACE NOENCRYPT;' FROM DBA_PART_TABLES  WHERE DEF_TABLESPACE_NAME = 'ENCRYPT';
-- rebuild index partition
select 'alter index '||index_owner||'.'||index_name ||' rebuild partition '||partition_name||' tablespace NOENCRYPT online ;' from
( 
select index_owner,index_name,partition_name from dba_ind_partitions
where tablespace_name='ENCRYPT'
);

select 'alter index '||owner||'.'||segment_name ||' rebuild partition '||partition_name||' tablespace NOENCRYPT online ;' from
(
select distinct owner,segment_name,segment_type,partition_name from dba_segments where tablespace_name='ENCRYPT'
and segment_type='INDEX PARTITION' 
);
-- rebuild index thuong
select 'alter index '||owner||'.'||index_name ||' rebuild  tablespace NOENCRYPT online parallel 64;' from
( 
select owner,index_name from dba_indexes
where tablespace_name='ENCRYPT'
);
select 'alter index '||owner||'.'||index_name ||' noparallel;' from
( 
select owner,index_name from dba_indexes
where tablespace_name='ENCRYPT'
);


-- move table partition
select 'alter table '||table_owner||'.'||table_name ||' MOVE PARTITION '||partition_name||' ONLINE tablespace NOENCRYPT UPDATE INDEXES ;' from
(
select distinct table_owner,table_name,partition_name from dba_tab_partitions where tablespace_name='ENCRYPT'

);

select 'alter table '||owner||'.'||segment_name ||' MOVE PARTITION '||partition_name||' ONLINE tablespace NOENCRYPT UPDATE INDEXES ;' from
(
select distinct owner,segment_name,segment_type,partition_name from dba_segments where tablespace_name='ENCRYPT'
and segment_type='TABLE PARTITION' 
);

--move table - fai rebuil index
select 'alter table '||owner||'.'||table_name ||' MOVE ONLINE tablespace NOENCRYPT parallel 64;' from
(
select * from dba_tables where tablespace_name='ENCRYPT'

);

select 'alter table '||owner||'.'||table_name ||' noparallel;' from
(
select * from dba_tables where tablespace_name='ENCRYPT'

);

-----------move LOB
		select 'ALTER TABLE '||owner||'.'||table_name||' MOVE LOB( '||column_name||') STORE AS (TABLESPACE EMB_DATA_TBS) parallel 16;' from dba_lobs where tablespace_name='EMB_DATA';
select 'alter table '||table_owner||'.'||table_name ||' move partition '||partition_name ||' tablespace EMB_DATA_TBS '
  ||  'lob(' ||column_name||') store as  (tablespace EMB_DATA_TBS) online parallel 32;'    from dba_lob_partitions where tablespace_name='EMB_DATA' and table_name='LOG_ACTV';
  
===============modify default attribute 
select 'ALTER TABLE '||owner||'.'||table_name||' MODIFY DEFAULT ATTRIBUTES TABLESPACE NOENCRYPT;' from dba_tables where tablespace_name='ENCRYPT';
select 'ALTER INDEX '||OWNER||'.'||'INDEX_NAME MODIFY DEFAULT ATTRIBUTES TABLESPACE NOENCRYPT;'  from dba_indexes where tablespace_name='ENCRYPT';
SELECT 'ALTER INDEX '||OWNER||'.'||INDEX_NAME||' MODIFY DEFAULT ATTRIBUTES TABLESPACE NOENCRYPT;' FROM DBA_PART_INDEXES WHERE DEF_TABLESPACE_NAME='ENCRYPT';
SELECT    'ALTER TABLE '|| OWNER|| '.' || TABLE_NAME|| '  MODIFY DEFAULT ATTRIBUTES TABLESPACE NOENCRYPT;' FROM DBA_PART_TABLES  WHERE DEF_TABLESPACE_NAME = 'ENCRYPT';
 alter session set ddl_lock_timeout =60;
alter table GCM_AGCM_VIETNAM_MBTT.GCM_PENDING_TASK modify default attributes LOB (CUSTOM_DETAILS) (tablespace EMB_DATA_TBS);

=========================================== move partition + compress a thinh
--Sorting the Data for Compression
--Presort the data on a column which has :no. of distinct values ~ no. of blocks
--Presort the data on a column which has :no. of distinct values nho ( low cardinality)
--ALL_TAB_COL_STATISTICS ALL_PART_COL_STATISTICS ALL_SUBPART_COL_STATISTICS
--dbms_compression.get_compression_ratio
CREATE TABLE emp_comp COMPRESS AS
SELECT * FROM emp ORDER BY <some unselective column(s)>;

--alter table DWH.MB_TR_CRB_PS move partition LNFT_MASTER_032015 pctfree 0 tablespace LNFT_MASTER_TBS_NEW200509 compress for oltp parallel 64;
select 'alter table '||table_owner||'.'||table_name||' move partition '||partition_name||' tablespace AICT_DATA compress for oltp parallel 24;' from dba_tab_partitions where table_name='REP_TOI_FINAL_DAILY';

alter table DWH.MSB_ALL_VIEW_SOURCES move lob (OBJ_SOURCE) store as SYS_LOB0003070270C00004$$ ( tablespace IB_SMS_ECOM_TBS_NEW) parallel 64;
alter table DWH.DB_LOG move lob (FULL_MSG) store as SYS_LOB0004575461C00013$$ ( tablespace IB_SMS_ECOM_TBS_NEW) parallel 64;
------------------- rebuild index unusable 
SELECT 'ALTER INDEX '||INDEX_OWNER||'.'||INDEX_NAME||' REBUILD PARTITION '||PARTITION_NAME||' TABLESPACE '||
TABLESPACE_NAME
||' PARALLEL 64;' rebuild_idx, t.* from dba_ind_partitions t
 where status='UNUSABLE'
 and INDEX_OWNER||'.'||INDEX_NAME||'.'||PARTITION_NAME not in (select INDEX_OWNER||'.'||INDEX_NAME||'.'||PARTITION_NAME  from dbmonitor.unusable_idx)
-- and TABLESPACE_NAME = 'LNFT_MASTER_NEW_TBS'
order by index_owner,index_name,PARTITION_NAME;		

ALTER INDEX DWH.LNFT_MASTER_STATUS_IDX REBUILD PARTITION LNFT_MASTER_052020 TABLESPACE DATA_2020Q2 PARALLEL 64;

ALTER INDEX chungtc.BITMAP_IDX MODIFY PARTITION P_1000 UNUSABLE;
ALTER INDEX chungtc.BITMAP_IDX REBUILD PARTITION P_1000 TABLESPACE users PARALLEL 64;
------------------- HIEU ATNA -------------------------------
alter index KMTD5.C_NEIF_RELAY_CONFIGS_ID_PK REBUILD ONLINE TABLESPACE KMTD_INDEX
*
ERROR at line 1:
ORA-08106: cannot create journal table KMTD5.SYS_JOURNAL_88381
Loi nay thuong do rebuild index bị interupt. Cach xu ly:
select OWNER, OBJECT_NAME, OBJECT_ID from dba_objects 
where object_name like 'SYS_JOURNAL%';

select * from dba_objects where object_id= 361617;

drop table KMTD5.SYS_JOURNAL_88381 purge;

alter index KMTD5.C_NEIF_RELAY_CONFIGS_ID_PK REBUILD ONLINE TABLESPACE KMTD_INDEX;

--------------------HUY ATNA ------------- select datafiles HWM-------------
select 'alter database datafile' ||' '''|| file_name|| ''''||' resize '||round(highwater+ 2)||' ' ||'m'|| ';' from (
select /*+ rule */
   a.tablespace_name ,
    a.file_name,
   a.bytes/1024 /1024 file_size_MB ,
    (b.maximum+c.blocks-1 )*d .db_block_size /1024/ 1024 highwater
from dba_data_files a         ,
     (select file_id ,max(block_id ) maximum        
      from dba_extents        
      group by file_id) b,
      dba_extents c ,
     (select value db_block_size        
      from v$parameter        
      where name='db_block_size' ) d
where a. file_id=   b. file_id
and   c. file_id  = b.file_id
and   c. block_id = b. maximum
and a.tablespace_name='DATA2016'

order by a. tablespace_name,a.file_name
);
---------- Linh ATNA ------kiem tra cac object tren tablespace-------------
select owner, segment_name, segment_type,partition_name, tablespace_name
from dba_segments
where tablespace_name='DATA_BIG_201605'
order by 2,4;

select * from dba_tab_partitions where tablespace_name='DATA_BIG_201605';

select 'alter index ESP_OWNER.'||index_name||' rebuild partition '||PARTITION_NAME||' tablespace INDX2014 nologging parallel 16;' 
from dba_ind_partitions where tablespace_name='DATA_BIG_201605';

select * from dba_indexes where tablespace_name='DATA_BIG_201605';
================== find index need rebuild==================
select a.*, round(index_leaf_estimate_if_rebuilt/current_leaf_blocks*100) percent, case when index_leaf_estimate_if_rebuilt/current_leaf_blocks < 0.5 then 'candidate for rebuild' end status
from
(
select table_name, index_name, current_leaf_blocks, round (100 / 90 * (ind_num_rows * (rowid_length + uniq_ind + 4) + sum((avg_col_len) * (tab_num_rows) ) ) / (8192 - 192) ) as index_leaf_estimate_if_rebuilt
from (
select tab.table_name, tab.num_rows tab_num_rows , decode(tab.partitioned,'YES',10,6) rowid_length , ind.index_name, ind.index_type, ind.num_rows ind_num_rows, ind.leaf_blocks as current_leaf_blocks,
decode(uniqueness,'UNIQUE',0,1) uniq_ind,ic.column_name as ind_column_name, tc.column_name , tc.avg_col_len
from dba_tables tab
join dba_indexes ind on ind.owner=tab.owner and ind.table_name=tab.table_name
join dba_ind_columns ic on ic.table_owner=tab.owner and ic.table_name=tab.table_name and ic.index_owner=tab.owner and ic.index_name=ind.index_name
join dba_tab_columns tc on tc.owner=tab.owner and tc.table_name=tab.table_name and tc.column_name=ic.column_name
where tab.owner='&OWNER' and ind.leaf_blocks is not null and ind.leaf_blocks > 1000
) group by table_name, index_name, current_leaf_blocks, ind_num_rows, uniq_ind, rowid_length
) a where index_leaf_estimate_if_rebuilt/current_leaf_blocks < 0.5
order by index_leaf_estimate_if_rebuilt/current_leaf_blocks

============= gather database =======================================
BEGIN
DBMS_STATS.GATHER_FIXED_OBJECTS_STATS;
DBMS_STATS.gather_dictionary_stats;
DBMS_STATS.gather_database_stats(estimate_percent => dbms_stats.auto_sample_size, degree=>16 );
END;
/
====================gather index statistic ============================
select i.index_name, i.leaf_blocks,i.blevel,i.distinct_keys,
           i.num_rows,i.clustering_factor,t.blocks,
         i.last_analyzed
   from dba_indexes i ,
         dba_tables t
    where t.table_name = i.table_name
    and t.table_name ='DOC';

EXEC DBMS_STATS.gather_index_stats('MSB', 'DOC_DATE');
EXEC dbms_stats.gather_index_stats(ownname => 'AMLMCOB', indname => 'GWGKUNDE$HISTBIS', estimate_percent =>DBMS_STATS.AUTO_SAMPLE_SIZE);
	ALTER INDEX <index_name> COMPUTE STATISTICS;
    exec dbms_stats.gather_Table_stats('MSB','GALPAR1',cascade=>true);

	 execute dbms_stats.gather_index_stats(ownname => 'AMLMCOB', indname =>'IDX_GWGKUNDE_NEW', estimate_percent =>DBMS_STATS.AUTO_SAMPLE_SIZE);
-----------Linh ATNA- move hoac xoa table khoi tablespace ----------------------------
select 'alter table '||table_name||' move partition '||partition_name||' tablespace DATA2016 parallel 16 nologging update global indexes;' from dba_tab_partitions
where table_name='WARNING_MAIL'
AND tablespace_name not like 'DATA2016' 
and table_owner ='ESP_OWNER'
ORDER BY tablespace_name;

select 'alter table '||table_name||' move SUBPARTITION '||subpartition_name||'  tablespace KMTD5_DATA parallel 16  update GLOBAL indexes;' from user_tab_subpartitions
where tablespace_name ='KMTD_DATA' 
ORDER BY tablespace_name;

select 'alter table '||table_name||' drop partition '||partition_name||'  update global indexes;' from dba_tab_partitions
where table_name='CDR_TRANSACTION_DETAIL_HISTORY'
AND tablespace_name not like 'DATA2016' 
and table_owner ='ESP_OWNER'
ORDER BY tablespace_name;

alter index DWH.CRTB_DDACCH_DATE_IDX rebuild parallel 4 nologging compute statistics

+++Linh Atna kiem tra index invalid+++++++++++++++++++
	SELECT 'alter index ' ||owner||'.'||index_name|| ' rebuild nologging parallel 16;'
	  FROM dba_indexes
	 WHERE status != 'VALID'
	   AND partitioned != 'YES'
	   AND owner = 'ESP_OWNER';
	 
	SELECT 'alter index ' ||index_owner||'.'||index_name|| ' rebuild partition '||partition_name||' nologging parallel 16;' 
	  FROM dba_ind_partitions
	 WHERE status != 'USABLE'
	   AND index_owner = 'ESP_OWNER';
   
   --- neu gap loi ORA-00054: resource busy and acquire with NOWAIT specified thi ktra xem co dang bi lock boi sql update nao ko
   SELECT O.OBJECT_NAME, S.SID, S.SERIAL#, P.SPID, S.PROGRAM,S.USERNAME,
	S.MACHINE,S.PORT , S.LOGON_TIME,SQ.SQL_FULLTEXT 
	FROM V$LOCKED_OBJECT L, DBA_OBJECTS O, V$SESSION S, 
	V$PROCESS P, V$SQL SQ 
	WHERE L.OBJECT_ID = O.OBJECT_ID 
	AND L.SESSION_ID = S.SID AND S.PADDR = P.ADDR 
	AND S.SQL_ADDRESS = SQ.ADDRESS;

select * from v$access a , v$session s
where s.sid=s.sid
and a.owner='T24CORE'
AND A.OBJECT='DEF_DE_O_HE003';	

SET LINESIZE 500
SET PAGESIZE 1000
SET VERIFY OFF

COLUMN owner FORMAT A20
COLUMN username FORMAT A20
COLUMN object_owner FORMAT A20
COLUMN object_name FORMAT A30
COLUMN locked_mode FORMAT A15
SELECT lo.session_id AS sid,
       s.serial#,
       NVL(lo.oracle_username, '(oracle)') AS username,
       o.owner AS object_owner,
       o.object_name,
       Decode(lo.locked_mode, 0, 'None',
                             1, 'Null (NULL)',
                             2, 'Row-S (SS)',
                             3, 'Row-X (SX)',
                             4, 'Share (S)',
                             5, 'S/Row-X (SSX)',
                             6, 'Exclusive (X)',
                             lo.locked_mode) locked_mode,
       lo.os_user_name
FROM   v$locked_object lo
       JOIN dba_objects o ON o.object_id = lo.object_id
       JOIN v$session s ON lo.session_id = s.sid
ORDER BY 1, 2, 3, 4;
SET PAGESIZE 14
SET VERIFY ON

select
s.sid, s.serial#, p.spid,
s.username,
s.osuser,
s.program,
s.terminal,
s.module, s.action
, p.tracefile
, s.type
, s.logon_time
, s.state
, s.wait_time, s.seconds_in_wait, s.service_name
from
gv$session s,
gv$process p
where s.paddr = p.addr and type not in 'BACKGROUND';
;

				-- ktra lai sid co sqltext la j
				SELECT sid||','||serial# sid_ser,
        status,
     	schemaname||'@'||service_name  from_where, 
        osuser,
        program,
     	NVL((select DISTINCT sql_text from v$sql sql where sql.sql_id = ses.sql_id),'NOTHING GOING ON') sql_text,
     	blocking_session,
     	TO_CHAR(logon_time,'dd/mm/yyyy HH24:MM:SS AM') as from_when
   		FROM v$session ses
  		WHERE type = 'USER' 
  		and type <>'BACKGROUND'
  		and sid='153'
		--- sau do se can kill cac sid tren di 
		
		
select 
'ALTER ' || OBJECT_TYPE || ' ' || 
OWNER || '.' || OBJECT_NAME || ' COMPILE;' 
from 
dba_objects 
where 
status = 'INVALID' 
and 
object_type in ('PACKAGE','FUNCTION','PROCEDURE') 
; 


select 
   owner       c1, 
   object_type c3,
   object_name c2
from 
   dba_objects 
where 
   status != 'VALID'
order by
   owner,
   object_type;	

========= co the sua loi  ORA-00054: resource busy and acquire with NOWAIT   
alter session set DDL_LOCK_TIMEOUT = 10;
ALTER TABLE "T24CORE".chungtc ADD SUPPLEMENTAL LOG GROUP "GGS_8467729" ("RECID") ALWAYS;
ALTER TABLE "T24CORE"."ACFBNK_STMT002" ADD SUPPLEMENTAL LOG DATA (PRIMARY KEY) COLUMNS;
ALTER TABLE "T24CORE"."ACFBNK_STMT002" ADD SUPPLEMENTAL LOG DATA (UNIQUE) COLUMNS;
ALTER TABLE "T24CORE"."ACFBNK_STMT002" ADD SUPPLEMENTAL LOG DATA (FOREIGN KEY) COLUMNS;
select * from DBA_LOG_GROUPS where log_group_name='GGS_8467729';
select * from DBA_LOG_GROUP_COLUMNS;
 ==================================== --- neu gap loi ORA-00054: resource busy and acquire with NOWAIT
  select * from dba_objects where object_name =  'SOURCE' and object_type='TABLE'; 
select session_id from v$locked_object where object_id ='342592';
select * from v$session where sid=962;

SELECT p.spid FROM v$session s, v$process p
WHERE s.paddr = p.addr
AND s.sid = 10437;
 kill -9 spid
alter system kill session '962,44373' immediate;

--ORA-08104: this index object 343426 is being online built or rebuilt

DECLARE
   isclean   BOOLEAN;
BEGIN
   isclean := FALSE;
   WHILE isclean = FALSE
   LOOP
      isclean :=DBMS_REPAIR.ONLINE_INDEX_CLEAN ('8788057', DBMS_REPAIR.lock_wait);
      DBMS_LOCK.sleep (10);
   END LOOP;
END;
/
   ======================== invalid view =====================
   select * from dba_dependencies where name ='VW_INSTRUMENT_DESK_LN_HIST';
select * from dba_objects where object_name in 
(
select REFERENCED_NAME from dba_dependencies where name ='VW_INSTRUMENT_DESK_LN_HIST'
);

===
select * from dba_indexes where index_name='RPTTB_LN_CLFN_PRODUCT_TYPE_IDX';
select * from dba_ind_partitions where index_name='RPTTB_LN_CLFN_PRODUCT_TYPE_IDX'
and partition_name like '%NEW';
======================== CHUNGTC ALL INDEX OF TABLE ==========================================
SELECT DISTINCT INDEX_NAME,TABLE_NAME FROM
(
select 
b.uniqueness, a.index_name, a.table_name, a.column_name 
from all_ind_columns a, all_indexes b
where a.index_name=b.index_name 
AND A.TABLE_OWNER ='EVS2_OWNER'
order by a.table_name, a.index_name, a.column_position
);		


create table ftp.bitmap_index as select * from (
WITH F AS (SELECT idx.index_name,seg.partition_name, round(SUM(bytes)/1024/2014,2) MB
  FROM dba_segments seg,
       dba_indexes  idx
 WHERE idx.table_owner = 'FTP'
    AND idx.owner       = seg.owner
   AND idx.index_name  = seg.segment_name
   AND IDX.INDEX_TYPE='BITMAP'
 GROUP BY idx.index_name,seg.partition_name )
 SELECT F.* , a.COLUMN_NAME , a.table_name FROM F
 LEFT JOIN ALL_IND_COLUMNS A
 ON F.INDEX_NAME=A.INDEX_NAME
 )
==================== CHUNGTC CHECK ALL INDEX SIZE ===========================================
SELECT owner, segment_name, segment_type, partition_name, ROUND(bytes/(1024*1024),2) SIZE_MB, tablespace_name 
FROM DBA_SEGMENTS 
WHERE SEGMENT_TYPE IN ('TABLE', 'TABLE PARTITION', 'TABLE SUBPARTITION', 
'INDEX', 'INDEX PARTITION', 'INDEX SUBPARTITION', 'TEMPORARY', 'LOBINDEX', 'LOBSEGMENT', 'LOB PARTITION')
AND TABLESPACE_NAME LIKE 'INDX_TRANS%' 
--AND SEGMENT_NAME LIKE 'P2010201%' 
--AND partition_name LIKE 'P20100201%'
--AND segment_type = 'TABLE'
AND OWNER = 'EVS2_OWNER' 
--AND ROUND(bytes/(1024*1024),2) > 1000 
ORDER BY bytes DESC;

=============chungtc check index size of a table partition
select partition_name,sum(MB) from
(
SELECT idx.index_name,seg.partition_name, round(SUM(bytes)/1024/2014,2) MB
  FROM dba_segments seg,
       dba_indexes  idx
 WHERE idx.table_owner = 'FTP'
   AND idx.table_name  = 'PMFT_INSTRUMENT'
   AND seg.partition_name='PMFT_INSTRUMENT_201701'
   AND idx.owner       = seg.owner
   AND idx.index_name  = seg.segment_name
 GROUP BY idx.index_name,seg.partition_name
 )
 group by partition_name
==================== CHUNGTC CHECK INDEX TABLE SIZE ====================================
SELECT A.OWNER,A.SEGMENT_NAME,A.SEGMENT_TYPE,A.TABLESPACE_NAME,A.SIZE_M,B.TABLE_NAME FROM 

(
    SELECT OWNER,SEGMENT_NAME,segment_type,TABLESPACE_NAME, SUM(SIZE_mb) SIZE_m FROM
    (

    SELECT owner, segment_name, segment_type, partition_name, ROUND(bytes/(1024*1024),2) SIZE_MB, tablespace_name 
    FROM DBA_SEGMENTS 
    WHERE SEGMENT_TYPE IN ('TABLE', 'TABLE PARTITION', 'TABLE SUBPARTITION', 
    'INDEX', 'INDEX PARTITION', 'INDEX SUBPARTITION', 'TEMPORARY', 'LOBINDEX', 'LOBSEGMENT', 'LOB PARTITION')
    --AND TABLESPACE_NAME LIKE 'INDX_TRANS%' 
    --AND SEGMENT_NAME LIKE 'P2010201%' 
    --AND partition_name LIKE 'P20100201%'
    --AND segment_type = 'TABLE'
    AND OWNER = 'MSB' 
    --AND ROUND(bytes/(1024*1024),2) > 1000 
    )
    GROUP BY OWNER,SEGMENT_NAME,segment_type,TABLESPACE_NAME
) A,

(
    SELECT DISTINCT INDEX_NAME,TABLE_NAME FROM
    (
    select 
    b.uniqueness, a.index_name, a.table_name, a.column_name 
    from all_ind_columns a, all_indexes b
    where a.index_name=b.index_name 
    AND A.TABLE_OWNER ='MSB'
    and a.table_name in ('ENTRY','ITEM')
    order by a.table_name, a.index_name, a.column_position
    )
) B

WHERE A.SEGMENT_NAME = B.INDEX_NAME
ORDER BY A.SIZE_M DESC

---------------- alter default tablespace -------------------------
 alter table apps.EMB_APIGW_TRANS_LOG set STORE IN(AICT_DATA);

SELECT DEF_TABLESPACE_NAME FROM DBA_PART_TABLES WHERE TABLE_NAME='EMB_APIGW_TRANS_LOG';
alter table EVS2_OWNER.EMB_APIGW_TRANS_LOG modify default attributes tablespace INDX_TRANS;
-- check xem progress
select ops.OPNAME, ops.TIME_REMAINING,ops.start_time
from v$session_longops ops
where ops.sid=858
and ops.serial#=37743
and time_remaining>0;
===================dbms_scheduler=========================
select job_name, enabled from DBA_SCHEDULER_JOBS WHERE job_name = 'CSJBS_BENIFIT_MSG_CUTOFFTIME';
execute dbms_scheduler.disable('IBS.CSJBS_BENIFIT_MSG_CUTOFFTIME');
 exec dbms_scheduler.enable('SYS.JOB_DBA_KILL_SESS');
exec sys.dbms_scheduler.STOP_JOB(job_name=>'IBS.CSJBS_BENIFIT_MSG_CUTOFFTIME', force=>true);
execute dbms_scheduler.disable('SYS.JOB_DBA_KILL_SESS');
--run job
dbms_scheduler.run_job('UPDATE_PLAYER_STATES')
--

------------------------create schedule job ============================= https://dinhnguyenngoc.wordpress.com/2011/11/26/m%CC%A3t-s%CC%81-vi%CC%81-du%CC%A3-v%CC%80-oracle-job-scheduler/
-- View all running jobs, Run the following query from SQL*Plus
SELECT a.sid, c.serial#, a.job, a.failures, to_char(a.this_date, 'mm/dd/yyyy hh:mi pm') startdatetime, b.what
FROM dba_jobs_running a, dba_jobs b, v$session c
WHERE a.job = b.job AND a.sid = c.sid order by a.this_date;

-- View all jobs, Run the following query from SQL*Plus
SELECT job, to_char(last_date, 'mm/dd/yyyy hh:mi pm') lastdate, to_char(next_date, 'mm/dd/yyyy hh:mi pm') nextdate, failures, broken, what 
FROM dba_jobs 
ORDER BY next_date;
-- killing job
execute dbms_job.broken(job_id, true);

BEGIN
SYS.DBMS_SCHEDULER.CREATE_JOB
    (
       job_name        => 'CHUNGTC.J_ARC_ICF_MB_IC_CHG_AC_STATUS'
      ,start_date      => SYSDATE + 2/24/60
      ,repeat_interval => 'Freq=Daily;ByHour=3;ByMinute=00;BySecond=00'
      ,end_date        => NULL
      ,job_class       => 'DEFAULT_JOB_CLASS'
      ,job_type        => 'PLSQL_BLOCK'
      ,job_action      =>  'begin T24ARC.P_ARC_ICF_MB_IC_CHG_AC_STATUS; end;' 
      ,comments        => 'Xu ly archive du lieu T24CORE.ARC_ICF_MB_IC_CHG_AC_STATUS 20201120'
      ,enabled           => FALSE
    );
END;
/    
	
'Freq=MINUTELY;Interval=15'	
'Freq=HOURLY;Interval=1'	
 repeat_interval=> 'FREQ=DAILY; BYHOUR=3;',
      ,repeat_interval => 'Freq=Weekly;ByDay=Sun;ByHour=22'

BEGIN
  DBMS_SCHEDULER.RUN_JOB(
    JOB_NAME            => 'SYS.JOB_ADD_DATAFILE',
    USE_CURRENT_SESSION => FALSE);
END;
/

BEGIN
  SYS.DBMS_SCHEDULER.STOP_JOB
    (job_name   => 'SYS.JOB_ADD_DATAFILE'
    ,force      => TRUE);
END;

BEGIN
  SYS.DBMS_SCHEDULER.DISABLE
    (name  => 'SYS.JOB_ADD_DATAFILE'
    ,force => TRUE);
END;



FREQ=DAILY;BYHOUR=1,13; BYMINUTE=0; BYSECOND=0;
exec dbms_scheduler.disable('SYS','JOB_ADD_DATAFILE');
exec dbms_scheduler.enable('SYS','JOB_ADD_DATAFILE');

select * from DBA_SCHEDULER_JOB_LOG where owner='CHUNGTC';
select * from DBA_SCHEDULER_JOB_RUN_DETAILS where owner='CHUNGTC';
select * from DBA_SCHEDULER_JOBS where owner='CHUNGTC';

-------------------------- tao job chungtc============================================
DECLARE
  X NUMBER;
BEGIN
  SYS.DBMS_JOB.SUBMIT
  ( job       => X 
   ,what      => 'SYS.FGA_EXPORT_DAILY;'
   ,next_date => to_date('13/11/2017 14:20:00','dd/mm/yyyy hh24:mi:ss')
   ,interval  => 'SYSDATE+1/24 '
   ,no_parse  => FALSE
   ,instance => 2
  );
  SYS.DBMS_OUTPUT.PUT_LINE('Job Number is: ' || to_char(x));
COMMIT;
END;
/

VARIABLE jobno number;
BEGIN
     DBMS_JOB.SUBMIT(:jobno,'begin  t24core.CONVERT_BLOB_FILE_CHUNGTC(''DEF_DE_O_MSG_II'',256,1000,2);end;');   COMMIT;
     DBMS_JOB.SUBMIT(:jobno,'begin  t24core.CONVERT_BLOB_FILE_CHUNGTC(''DEF_DE_O_MSG_II'',256,1000,3);end;');   COMMIT;
     COMMIT;
  END;
  / 
Kiem tra lai cac job
select JOB,INSTANCE from user_jobs; 

exec dbms_scheduler.disable('SYS','JOB_ADD_DATAFILE');
++++++++++++++++++ select job running++++++++++++++++++++++++++++++++++++++
select owner , job_name , running_instance, session_id from dba_scheduler_running_jobs
order by owner , job_name ;

SELECT sid, r.job, log_user, r.this_date, r.this_sec
FROM dba_jobs_running r, dba_jobs j
WHERE r.job = j.job;

===============external job===============================
-- tao user co quyen chay rman
create user c##bkpuser identified by bkpuser container=all;
grant connect, resource, create job, create external job, create credential to c##bkpuser;

create user bkpuser identified by bkpuser;
grant connect, resource, create job, create external job, create credential to bkpuser;

create user comvault identified by comvault6688;
grant connect, sysbackup to comvault;

-- tao credential dung user oracle cua OS ( user dang nhap OS )
begin
dbms_credential.create_credential(
credential_name => 'For_rman_backup',
username => 'oracle',
password => 'oracle'
);
end;
/
 
 begin
dbms_credential.drop_credential(
credential_name => 'For_rman_backup'
);
end;
/
 
-- goi job backup . •'EXTERNAL_SCRIPT'  thi co the chay script ngoai
SET SERVEROUTPUT ON
DECLARE
   l_job_name   VARCHAR2 (30);
   l_script     VARCHAR2 (32767);
BEGIN
   l_job_name := DBMS_SCHEDULER.generate_job_name;
   DBMS_OUTPUT.put_line ('JOB_NAME=' || l_job_name);
   -- Define the backup script.
   l_script := 'connect target /
                run { 
                backup database plus archivelog;
                crosscheck backup;
                crosscheck archivelog all;
                }';

   DBMS_SCHEDULER.create_job (job_name          => l_job_name,
                              job_type          => 'BACKUP_SCRIPT',
                              job_action        => l_script,
                              credential_name   => 'For_rman_backup',
                              enabled           => TRUE);
END;
/

============= chungtc create user for impdp ===============
create user dumpuser identified by dumpuser123;
grant connect  to dumpuser;
Grant SELECT ANY DICTIONARY to dumpuser;
GRANT CREATE SESSION TO dumpuser;
grant IMP_FULL_DATABASE  to dumpuser;
grant EXP_FULL_DATABASE  to dumpuser;
GRANT DATAPUMP_EXP_FULL_DATABASE TO DUMPUSER;
GRANT DATAPUMP_IMP_FULL_DATABASE TO DUMPUSER;
grant unlimited tablespace to dumpuser;
grant FLASHBACK ANY TABLE to dumpuser;
-- 5 System Privileges for DUMPUSER 
  GRANT CREATE SESSION TO DUMPUSER;
  GRANT FLASHBACK ANY TABLE TO DUMPUSER;
  GRANT SELECT ANY DICTIONARY TO DUMPUSER;
  GRANT SELECT ANY TABLE TO DUMPUSER;
  GRANT UNLIMITED TABLESPACE TO DUMPUSER;
  -- 2 Object Privileges for DUMPUSER 
    GRANT SELECT ON SYS.DBA_TAB_PARTITIONS TO DUMPUSER;
	
CREATE TABLE "ET$17F000010001" ( "RECID", "XMLRECORD" ) ORGANIZATION EXTERNAL ( TYPE ORACLE_DATAPUMP DEFAULT DIRECTORY "DUMP" ACCESS PARAMETERS ( DEBUG = (0 , 0) DATAPUMP INTERNAL TABLE "T24CORE"."ACFBNK_STMT008" JOB ( "DUMPUSER","SYS_EXPORT_TABLE_02",1) WORKERID 1 PARALLEL 1 VERSION '11.2.0.3.0' ENCRYPTPASSWORDISNULL COMPRESSION ENABLED ENCRYPTION DISABLED ) LOCATION ('bogus.dat') ) PARALLEL 1 REJECT LIMIT UNLIMITED AS SELECT /*+ PARALLEL(KU$,1) */ "RECID", KU$."XMLRECORD".getClobVal() FROM
RELATIONAL("T24CORE"."ACFBNK_STMT008" NOT XMLTYPE) AS OF SCN 7073225474020 KU$;
update t24core.ACFBNK_CATE002  SET XMLRECORD=XMLTYPE('<row id=''chungtc1''><c7>50000</c7><c12>VND</c12><c25>20060101</c25></row>') where recid='chungtc1';
select * from t24core.ACFBNK_CATE002 where recid like 'chungtc%';

expdp  \' / as sysdba\'  TABLES=T24CORE.ACFBNK_CUST017 directory=DUMP dumpfile=ACFBNK_CUST017.dmp logfile=DUMP:ACFBNK_CUST017.log FILESIZE=30G compression=all content=DATA_ONLY PARALLEL=64;  --400G  00:07:56
impdp dumpuser/dumpuser123   directory=DUMP  dumpfile=REFBNK_RE_C010%U.data.dmp logfile=DUMP:REFBNK_RE_C010.log table_exists_action=append  REMAP_TABLE=REFBNK_RE_C010:REFBNK_RE_C010_I PARALLEL=16 ;
impdp dumpuser/dumpuser123   directory=DUMP  tables=T24CORE.DEF_DE_O_HA000_I logfile=DUMP:DEF_DE_O_HA000_I.import.log network_link=dblink_t24dml  REMAP_TABLE=DEF_DE_O_HA000_I:DEF_DE_O_HA000_II REMAP_TABLESPACE=T24DATA:T24DATA PARALLEL=32 cluster=n EXCLUDE=STATISTICS,PROCACT_INSTANCE

==> status fai co ket qua nhu duoi
Worker 1 Status:
  Instance ID: 1
  Instance name: T24COB1
  Host name: t24mock1-db01
  Object start time: Tuesday, 01 June, 2021 10:29:56
  Object status at: Tuesday, 01 June, 2021 10:29:56
  Process Name: DW00
  State: EXECUTING                      
  Object Schema: T24CORE
  Object Name: DEF_DE_O_HA000
  Object Type: TABLE_EXPORT/TABLE/TABLE_DATA
  Completed Objects: 1
  Completed Rows: 11,526,269
  Completed Bytes: 68,858,582,944
  Percent Done: 4
  Worker Parallelism: 49

INSERT /*+ APPEND ENABLE_PARALLEL_DML PARALLEL("DEF_DE_O_HA000_I",49)+*/ INTO RELATIONAL("T24CORE"."
INSERT /*+ PARALLEL("REFBNK_RE_C010_I",1)+*/ INTO RELATIONAL("T24CORE"."REFBNK_RE_C010_I" NOT XMLTYPE) ("RECID", "XMLRECORD") SELECT "RECID", SYS.XMLTYPE.CREATEXML("XMLRECORD") FROM "ET$1C3B00010001" KU$

================ chungtc expdp impdp parallel ==============
============  file owner tablename parallel  ./do_export.sh T24CORE DEF_DE_O_HE003 16
#!/bin/bash 
chunk=$3 
for ((i=0;i<chunk;i++)); 
do 
expdp dumpuser/dumpuser123 TABLES=$1.$2 QUERY=$1.$2:\"where mod\(dbms_rowid.rowid_block_number\(rowid\)\, ${chunk}\) = ${i}\" directory=DUMP dumpfile=$2.${i}.dmp logfile= $2.${i}.log exclude=statistics,index,constraint,trigger FLASHBACK_SCN=7054723290347 CONTENT=DATA_ONLY cluster=n &    
echo $i 
sleep 3
done
---------- ./do_import.sh T24CORE LIFBNK_LIMIT 4 LIFBNK_LIMIT_I
#!/bin/bash 
chunk=$3 
for ((i=0;i<chunk;i++)); 
do 
impdp dumpuser/dumpuser123  directory=DUMP REMAP_TABLE=$2:$4  dumpfile= $2.${i}.dmp logfile=$2.${i}.log  DATA_OPTIONS=DISABLE_APPEND_HINT  CONTENT=DATA_ONLY cluster=n & 
sleep 3
done
================== impdp partition from dblink
select owner,object_name,subobject_name,object_id  from dba_objects where object_name='TR_THLK';
---> cai object_id cua partition co the dung trong tbl$or$idx$part$num("APPS"."BANKPLUS_BP_TRANSACTIONS"@dblink_ors,0,3,0,KU$.ROWID)=2759292

INSERT /*+ APPEND NESTED_TABLE_SET_REFS PARALLEL(KUT$,1) */ INTO "APPS"."BANKPLUS_BP_TRANSACTIONS" KUT$ ("MTI", "CARD_NUMBER", "PROCESSING_CODE", "AMOUNT", "TRANSMISSION_DATE", "INSERT_DATE", "TRACE", "FEE", "COMPANY_CODE", "REFERENCE", "RESPONSE_CODE", "TERMINAL_ID", "REQUEST_ID", "SOURCE_MOBILE", "TARGET_MOBILE", "DEBIT_ACCOUNT", "CREDIT_ACCOUNT", "FROM_RESOURCE", "CUSTOMER_ID", "ID_NUMBER", "CUSTOMER_NAME", "RECEIVER_NAME", "BEN_BANK_CODE", "BEN_BANK_NAME", "TRANS_COMMENT", "STAFF_CODE",
"SHOP_CODE", "BALANCE", "SERVICE_INDICATOR", "BILLING_CODE", "SERVICE_CODE", "TRANS_TYPE", "OLD_REQUEST_ID", "INSERT_DATE_TRUNC") SELECT /*+ NESTED_TABLE_GET_REFS PARALLEL(KU$,1) */ "MTI", "CARD_NUMBER", "PROCESSING_CODE", "AMOUNT", "TRANSMISSION_DATE", "INSERT_DATE", "TRACE", "FEE", "COMPANY_CODE", "REFERENCE", "RESPONSE_CODE", "TERMINAL_ID", "REQUEST_ID", "SOURCE_MOBILE", "TARGET_MOBILE", "DEBIT_ACCOUNT", "CREDIT_ACCOUNT", "FROM_RESOURCE", "CUSTOMER_ID", "ID_NUMBER", "CUSTOMER_NAME",
"RECEIVER_NAME", "BEN_BANK_CODE", "BEN_BANK_NAME", "TRANS_COMMENT", "STAFF_CODE", "SHOP_CODE", "BALANCE", "SERVICE_INDICATOR", "BILLING_CODE", "SERVICE_CODE", "TRANS_TYPE", "OLD_REQUEST_ID", "INSERT_DATE_TRUNC" FROM "APPS"."BANKPLUS_BP_TRANSACTIONS"@dblink_ors KU$ WHERE tbl$or$idx$part$num("APPS"."BANKPLUS_BP_TRANSACTIONS"@dblink_ors,0,3,0,KU$.ROWID)=2759292

vi BANKPLUS_BP_TRANSACTIONS.par
logfile=BANKPLUS_BP_TRANSACTIONS.log
directory=DATA_PUMP_DIR
tables=APPS.BANKPLUS_BP_TRANSACTIONS:SYS_P56932
remap_Tablespace=*:AICT_DATA
table_exists_action=append
EXCLUDE=STATISTICS
EXCLUDE=INDEX
network_link=dblink_ors
transform=disable_archive_logging:y
TRANSFORM=TABLE_COMPRESSION_CLAUSE:"ROW STORE COMPRESS ADVANCED"

nohup impdp orswarm/orswarm123   parfile=BANKPLUS_BP_TRANSACTIONS.par 2>&1 &

impdp dungnv8/Dungnv1234@CAM_DEV_EBANK schemas=DFormCataLogUAT directory=dump dumpfile=DFormCataLogUAT.dmp content=all remap_tablespace=*:ebankcam
=====================export query ================
vi test.par
dumpfile=BB_OPERATION_LOG.dmp
logfile=BB_OPERATION_LOG.log
directory=EXPPAR
tables=ibs.BB_OPERATION_LOG
QUERY=ibs.BB_OPERATION_LOG:"where operate_TIME<= to_Date ('01/02/2019','dd/mm/yyyy')"
CONTENT=DATA_ONLY
EXCLUDE=STATISTICS

expdp \'sys/msbsysadmin123@IBPROD as sysdba\'   parfile=test.par
=> module se la Data Pump Worker, cau sql export co dang
CREATE TABLE "ET$0B3688000001" ( "SOTK", "MAKH", "TENKH", "SECTOR", "KHOI", "NHOMNO", "CATEGORY", "SODU", "NGAYBATDAU", "SODUQUAHAN", "SONGAYQUAHAN", "SODUGOC", "SODULAI_IN", "SODULAI_PE", "SODULAI_PS", "SODU_CHARGE", "SODU_COMMITION", "SODUKHAC", "NTE", "CN", "TRANSACTION_DATE", "INT_TYPE", "INT_FIX", "INT_SPREAD", "INT_RATE", "RM_BANCHEO", "PRODUCT_CODE", "RM_HOPDONG", "CRA_CODE", "SUB_PRODUCT", "LEGACY_ID", "Y_PREVENT_RETRY", "BP_THAMDINH", "RM", "VAL_DATE", "MAT_DATE", "Y_TK_THUNO",
"LC_EXP_DATE", "TK_THAUCHI", "DOUBTFUL_STA" ) ORGANIZATION EXTERNAL ( TYPE ORACLE_DATAPUMP DEFAULT DIRECTORY "GGS_DUMP" ACCESS PARAMETERS ( DEBUG = (0 , 0) DATAPUMP INTERNAL TABLE "APPS"."TR_PD" JOB ( "SYS","SYS_EXPORT_TABLE_02",1) WORKERID 1 PARALLEL 1 VERSION '12.1.0.2' ENCRYPTPASSWORDISNULL COMPRESSION DISABLED ENCRYPTION DISABLED ) LOCATION ('bogus.dat') ) PARALLEL 1 REJECT LIMIT UNLIMITED AS SELECT "SOTK", "MAKH", "TENKH", "SECTOR", "KHOI", "NHOMNO", "CATEGORY", "SODU", "NGAYBATDAU",
"SODUQUAHAN", "SONGAYQUAHAN", "SODUGOC", "SODULAI_IN", "SODULAI_PE", "SODULAI_PS", "SODU_CHARGE", "SODU_COMMITION", "SODUKHAC", "NTE", "CN", "TRANSACTION_DATE", "INT_TYPE", "INT_FIX", "INT_SPREAD", "INT_RATE", "RM_BANCHEO", "PRODUCT_CODE", "RM_HOPDONG", "CRA_CODE", "SUB_PRODUCT", "LEGACY_ID", "Y_PREVENT_RETRY", "BP_THAMDINH", "RM", "VAL_DATE", "MAT_DATE", "Y_TK_THUNO", "LC_EXP_DATE", "TK_THAUCHI", "DOUBTFUL_STA" FROM RELATIONAL("APPS"."TR_PD" NOT XMLTYPE) KU$ WHERE Transaction_date >= to_Date
('01/06/2020','dd/mm/yyyy') and Transaction_date<= to_Date ('01/09/2020','dd/mm/yyyy')

Total estimation using BLOCKS method: 7.203 GB
. . exported "APPS"."TR_KU_M"                            365.9 MB 1154225 rows
Master table "SYS"."SYS_EXPORT_TABLE_02" successfully loaded/unloaded

impdp \'sys/msbsysadmin123@IBPROD as sysdba\'  directory=EXPPAR  dumpfile=EXPPAR:BB_OPERATION_LOG.dmp logfile=EXPPAR:import.BB_OPERATION_LOG table_exists_action=append REMAP_TABLESPACE=IBS2:HIS_TBS  REMAP_TABLE=BB_OPERATION_LOG:BB_OPERATION_LOG_his;
-------export package only
expdp \' / as sysdba\' SCHEMAS=MBK INCLUDE=PACKAGE:\"IN \(\'DTYPE\'\)\" directory=EXPDIR dumpfile=PACKAGE.dmp logfile=expdpPACKAGE.log
impdp \' / as sysdba\' SCHEMAS=ATMLOG directory=EXPDIR dumpfile=atm_package.dmp logfile=impdpatmpackage.log
-- export roi import lai thanh user khac
  expdp  \'sys/oracle@XEDR as sysdba\' schemas=CITAD directory=DPUMP dumpfile=CITAD.dmp logfile=expdpCITAD.log compression=all EXCLUDE=STATISTICS; 
 nohup impdp \'sys/oracle@XEDR as sysdba\' directory=DPUMP dumpfile=CITAD.dmp logfile=impdpCITAD.log  remap_schema=CITAD:CITAD_HCM	&
----------- export dump data pump---------------------
  expdp  \'sys/Tiennhieudelamgi#2018@SMSDBPRO as sysdba\' tables=EGATEWAY.MESSAGES directory=DDUMP dumpfile=DDUMP:MESSAGES.dmp logfile=DDUMP:MESSAGES.log EXCLUDE=STATISTICS; 
expdp  \'sys/msbsysadmin123@FTP as sysdba\'  TABLES=FTP.PMFT_INSTRUMENT:PMFT_INSTRUMENT_201701,FTP.PMFT_INSTRUMENT:PMFT_INSTRUMENT_201702 directory=exppar dumpfile=PMFT_INSTRUMENT.dmp logfile=exppar:expPMFT_INSTRUMENT2017.log  compression=all; 
expdp  \' / as sysdba\'  views_as_tables=VISION.PWT_FI_FUND_VW,VISION.VISION_SBU directory=DUMPDIR dumpfile=view.dmp logfile=DUMPDIR:view.log  compression=all 
expdp  \' / as sysdba\'  TABLES=VISION.FTP_AUDIT_TAB,VISION.PWT_FI_FUND_VW_TMP,VISION.VISION_SBU_TMP directory=DUMPDIR dumpfile=dumpfile.dmp logfile=DUMPDIR:expdumpfile.log  compression=all version=11.2; 
expdp  \' / as sysdba\'  TABLES=T24CORE.REFBNK_RE_C010 directory=DUMP dumpfile=REFBNK_RE_C010%U.data.dmp logfile=DUMP:REFBNK_RE_C010.log FILESIZE=30G compression=all content=DATA_ONLY PARALLEL=16;

impdp scott/tiger@db10g tables=chungtc_BK_OPERATION_LOG directory=DUMP_DIR dumpfile=chungtc_BK_OPERATION_LOG.dmp logfile=chungtc_BK_OPERATION_LOG.log
impdp ocsg_owner/ocsg123 DIRECTORY=dump_dir DUMPFILE=GW_TRANS_DAILY_ONE.dmp REMAP_SCHEMA=cps_owner:ocsg_owner remap_table=GW_TRANS_DAILY_ONE:CPS_TRANS_DAILY_RPT CONTENT=DATA_ONLY logfile=GW_TRANS_DAILY_ONE_import.log
--MWOW
expdp  \'sys/msbsysadmin123@IBPROD as sysdba\'  TABLES=IBS.bk_cms_file,IBS.bk_cms_file_attachment,IBS.bk_cms_folder directory=exppar dumpfile=file1.dmp logfile=exppar:file1.log  compression=all EXCLUDE=STATISTICS; 
scp /backup/export/file.dmp 10.1.68.104:/backup/importMWOW/
impdp \'sys/msbsysadmin123@mwow1 as sysdba\'  directory=EXPPAR  dumpfile=EXPPAR:file.dmp logfile=EXPPAR:file.log table_exists_action=append REMAP_SCHEMA=IBS:MWOW REMAP_TABLESPACE=IBS2:MWOW_DATA_TBS ;

-------------export dblink -------------------
select * from DATABASE_EXPORT_OBJECTS where object_path like '%LINK%';
SELECT db_link FROM dba_db_links;
SELECT DBMS_METADATA.GET_dDL('DB_LINK', DB_LINK,'PUBLIC') FROM DBA_DB_LINKS WHERE OWNER = 'PUBLIC';
-- export phia nguon
vi par.par
full=y
INCLUDE=DB_LINK:"IN(SELECT db_link FROM dba_db_links)"
expdp \'sys/msbsysadmin123@my_jupiter as sysdba\'  directory=PDB_EXPDIR dumpfile=dblink-restore_JAYDEV.dmp logfile=dblink-restore_JAYDEV.log parfile=par.par 
-- copy file dump sang dich de import
impdp \'sys/msb@jupiter as sysdba\' JOB_NAME=IMPORT_jupiter directory=TEST_DIR dumpfile=dblink-restore_JAYDEV.dmp logfile=restore_JAYDEV.log  

----------------- a Thanh svtech restore ocsg ------------------------------------------------------
RMAN> restore controlfile from '/db/oracle/11.2.0/dbhome_1/dbs/c-1909780669-20161116-02';
RMAN> CONFIGURE DEVICE TYPE DISK PARALLELISM 8  BACKUP TYPE TO BACKUPSET;
run {
set newname for database to new; # nho tham so create SQL> show parameter create
restore database;
switch datafile all;
}
recover database skipp tablespace 'CPS_LOG','INGW_OLOG';
alter database open reset log ## cai nay se sinh lại redo online log theo init file.
---------------------a haidb svtech: de kill job datapump dang chay --------------------------------
select *from dba_datapump_jobs;-- ra dc SYS_EXPORT_TABLE_02
DECLARE
h1 NUMBER;
BEGIN
h1:=DBMS_DATAPUMP.ATTACH('SYS_IMPORT_TABLE_08','ORSWARM');
DBMS_DATAPUMP.STOP_JOB (h1,1,0);
END;
/


hoac 
select *from dba_datapump_jobs; -- lay ket qua thay vao object_name ben duoi
select *  from dba_objects where object_name='SYS_IMPORT_TRANSPORTABLE_01';
DROP TABLE sys.SYS_IMPORT_TRANSPORTABLE_01; -- drop vs tham so = ket qua cua cau tren

============ a tam msb check dataguard ===

------------a hai db svtech: check dataguard ----------------------------
ben dataguard
select thread#,max(SEQUENCE#) FROM V$ARCHIVED_LOG where applied='YES' group by thread#;
ben chinh
select thread#,max(SEQUENCE#) FROM V$LOG_HISTORY  group by thread#;

---HYPER   a Hiepnt cho
cat /u01/oracle/product/11.2.0/kmtd5/network/admin/tnsnames.ora 
ps -ef|grep ora_smon*  -- xem dang co may instance dang chay
export ORACLE_SID=repos
sqlplus / as sysdba
-- select ra job number dang running -> sau buoc nay co job number
set lines 200
set pages 0
col what format a40
col log_user format a10
 SELECT j.sid,
        j.log_user,
        j.job,
        j.broken,
        j.failures,
        j.last_date || ':' || j.last_sec last_date,
        j.this_date || ':' || j.this_sec this_date,
        j.next_date || ':' || j.next_sec next_date,
        j.next_date - j.last_date interval,
        j.what
   FROM (SELECT djr.SID,
                dj.LOG_USER,
                dj.JOB,
                dj.BROKEN,
                dj.FAILURES,
                dj.LAST_DATE,
                dj.LAST_SEC,
                dj.THIS_DATE,
                dj.THIS_SEC,
                dj.NEXT_DATE,
                dj.NEXT_SEC,
                dj.INTERVAL,
                dj.WHAT
           FROM dba_jobs dj, dba_jobs_running djr
          WHERE dj.job = djr.job) j;
          
------------- stop job running nho su dung job number o buoc tren chay tren chinh owner do-----------------------------
exec SYS.dbms_scheduler.stop_job(job_name=>'DBMS_JOB$_66505');
-- set job number broken
BEGIN
 DBMS_JOB.BROKEN(66458,TRUE);
END;

COMMIT;
-- kill oracle session GOOD -> produce duoc cau lenh de kill oracle session cua cac job runing
SELECT /*+ RULE */ D.JOB, V.SID, V.SERIAL#, LOG_USER USERNAME, WHAT,
DECODE(TRUNC(SYSDATE - LOGON_TIME), 0, NULL,
TRUNC(SYSDATE - LOGON_TIME) || ' Days' || ' + ') ||
TO_CHAR(TO_DATE(TRUNC(MOD(SYSDATE-LOGON_TIME,1) * 86400), 'SSSSS'), 'HH24:MI:SS') RUNNING,
D.FAILURES, 'alter system kill session ' || '''' || V.SID || ', ' || V.SERIAL# || '''' || ' immediate;' KILL_SQL
FROM DBA_JOBS_RUNNING D, V$SESSION V, DBA_JOBS J
WHERE V.SID = D.SID
AND D.JOB = J.JOB;



-- select process id tren OS de co the kill job -> nhap SID la truong SID o cau lenh tren
SELECT p.spid FROM v$session s, v$process p
WHERE s.paddr = p.addr
AND s.sid = &sid;

ALTER SYSTEM KILL SESSION '776,3981' IMMEDIATE;
select * from gv$sql_monitor where module='osh@etl-tt35-srv (TNS V1-V3)';

select * from gv$session where program ='osh@etl-tt35-srv (TNS V1-V3)';

alter system kill session '114,42504,@1' immediate;
-- tren OS: voi spid la truong spid cua cau lenh tren
ps -ef|grep spid
job cua Oracle no co name nhu sau: ora_j00n<n=1,2..>_<ORACLE_SID>
vd tren con PPS1:
[oracle@insp-hn-pps]$ps -ef|grep 7147
  oracle 13632  9451   0 11:02:20 pts/3       0:00 grep 7147
  oracle  7147     1   2 10:10:22 ?          33:35 ora_j001_pps1


===========Find locks Between 5 and 6 PM on 3/10/15


REM Find locks Between 5 and 6 PM on 3/10/15
set linesize 200
set pagesize 200
col sql_text format a40
col module format a20
SELECT  
            distinct a.sql_id,
            a.inst_id,
            a.blocking_session as BLK_sess,
            a.blocking_session_serial# as BLK_SESS_Serial#,
            a.user_id,
            s.sql_text,
            a.module
FROM  
            GV$ACTIVE_SESSION_HISTORY a,
            gv$sql s
where
            a.sql_id=s.sql_id
            and
            blocking_session is not null
            and
            a.user_id <> 0
            and
            a.sample_time between
                        to_timestamp('2015-03-10 19:00:00','YYYY-MM-DD HH24:MI:SS') and
                        to_timestamp('2015-03-10 18:00:00','YYYY-MM-DD HH24:MI:SS');


----------------- chungtc cursor: pin S wait on X 
http://www.dba-oracle.com/t_cursor_pin_wait_on_x.htm

select s.inst_id as inst,
       s.sid as blocked_sid, 
       s.username as blocked_user,
       sa.sql_id as blocked_sql_id,
       trunc(s.p2/4294967296) as blocking_sid,
       b.username as blocking_user,
       b.sql_id as blocking_sql_id
from gv$session s
join gv$sqlarea sa
  on sa.hash_value = s.p1
join gv$session b
  on trunc(s.p2/4294967296)=b.sid
 and s.inst_id=b.inst_id
join gv$sqlarea sa2
  on b.sql_id=sa2.sql_id
where s.event='cursor: pin S wait on X';		

select sql_id,loaded_versions,executions,loads,invalidations,parse_calls
from gv$sql 
where inst_id=4 and sql_id='cn7m7t6y5h77g';		
=========== chungtc reference key =============
SELECT a.table_name, a.column_name, a.constraint_name, c.owner, 
       -- referenced pk
       c.r_owner, c_pk.table_name r_table_name, c_pk.constraint_name r_pk
  FROM all_cons_columns a
  JOIN all_constraints c ON a.owner = c.owner
                        AND a.constraint_name = c.constraint_name
  JOIN all_constraints c_pk ON c.r_owner = c_pk.owner
                           AND c.r_constraint_name = c_pk.constraint_name
 WHERE c.constraint_type = 'R'
   AND a.table_name = 'ACCOUNT_MASK'
=============Tim Forein Key ===============================
select cc.owner, cc.table_name, cc.column_name, cc.position   
from dba_cons_columns cc
where 
 cc.owner not in ('SYS','SYSTEM')
 and cc.owner in ('CRM1')
 and position is not null
 and table_name in ( 'SMART_KHCN_MOBILIZATION','SMART_KHCN_OUTSTADING','SMART_KHCN_INS_AND_INV','SMART_KHCN_DIGITAL','SMART_KHCN_CREDIT','SMART_KHCN_DEBIT')
minus
select i.index_owner, i.table_name, i.column_name, i.column_position
from dba_ind_columns i
where 
 i.index_owner not in ('SYS','SYSTEM')
  and i.index_owner in ('CRM1')
  and table_name in ( 'SMART_KHCN_MOBILIZATION','SMART_KHCN_OUTSTADING','SMART_KHCN_INS_AND_INV','SMART_KHCN_DIGITAL','SMART_KHCN_CREDIT','SMART_KHCN_DEBIT');

 
 -----------
 SELECT l.sid, s.blocking_session blocker, s.event, l.type, 
           l.lmode, l.request, o.object_name, o.object_type 
FROM v$lock l, dba_objects o, v$session s 
WHERE l.id1 = o.object_id (+) 
AND l.sid = s.sid 
ORDER BY sid, type;

===================== gc wait event: chungtc: Current - is for DMLs ;CR - is for Selects
+”BUFFER BUSY WAIT” that you might have observed which is recorded when a session tries to access a data block/buffer which is already being accessed by another session that is connected to the same instance 
and buffer is also in the current instance’s buffer cache. 

+n RAC environment, if a session tries to read a BUFFER from a REMOTE instance’s buffer cache but the buffer is already being read by a different session, a “GC BUFFER BUSY ACQUIRE” wait event is recorded. 
If a session tries to read a BUFFER from the buffer cache of LOCAL instance, but buffer is already being read into REMOTE instance’s buffer cache from local cache by a session connected to that remote instance, a “GC BUFFER BUSY RELEASE” wait event is recorded. 
Buffer busy waits are usually caused by:
	-For tables with index on sequence generated column, Inserts will cause the right most leaf block of the index to grow causing contention. Index growth causes index block to split too. Such index leaf block will be hot.
	-Multiple session doing Inserts will content for segment header block in non-ASSM tablespace if freelist/freelist group is low.
	-Sequence with low Cache value could lead to contention for seq$ blocks if the usage(Inserts) is high
	-CPU issue. Low CPU can cause delays during the block pinning process (kind of stuck in between)
	-Interconnect delays also can cause delays during the block pinning process
	-For Select statements, buffer busy waits can happen from plan inefficiency, and high concurrent execution can increase the severity.
	
+ GC CURRENT BLOCK 2-WAY: xay ra trong RAC 2 node, khi sessiong#1 trong instance#1 yeu cau blocks dang do instance#2 master. Thi gc current block 2-way la thoi gian Master Instance 2 gui blocks qua interconnect cho Instance kia.
+ GC CURRENT BLOCK 3-WAY: xay ra trong RAC 3 node. La khoang thoi gian Master instance fwd yeu cau tu Instance#1 toi Holding Instance + voi thoi gian Holding Instance gui thong tin current block cho Instance#1
+ The GC CURRENT BLOCK BUSY and GC CR BLOCK BUSY events indicate that the local instance that is making the request did not immediately receive a current or consistent read block. 
The term busy in these events' names indicates that the sending of the block was delayed on a remote instance. For example, a block cannot be shipped immediately if Oracle Database has not yet written the redo for the block's changes to a log file.
For example, if the block is undergoing changes, then LMS process need to create a consistent version of the block applying undo records.
 But, LMS process must wait for LGWR to do a log flush sync event before sending the block. Log flush sync event is similar to log file sync event during commit processing.

------------https://support.oracle.com/epmos/faces/DocumentDisplay?_afrLoop=387791184237142&id=1475659.1&_adf.ctrl-state=14rki05d5c_52
"enq: RO - fast object reuse"
The RO enqueue known as "Multiple object resue" enqueue, is used to synchronise operations between foreground process and a background process such as DBWR or CKPT. It is typically used when dropping objects or truncating tables.

Following is the sequence of events When a truncate/drop occurs:

Foreground process acquires the "RO" enqueue in exclusive mode
Cross instance calls (or one call if it is a single object) are issued ("CI" enqueue is acquired)
CKPT processes on each of instances requests the DBWR to write the dirty buffers to the disk and invalidate all the clean buffers.
After DBWR completes writing all blocks, the foreground process releases the RO enqueue.

-------------		lock normal chungtc lock 

select sample_time,SESSION_ID,session_serial#,plsql_entry_object_id,plsql_entry_subprogram_id 
, blocking_session, blocking_session_serial#,current_obj#
from DBA_HIST_ACTIVE_SESS_HISTORY
where
event in 
 ('library cache pin')
 and blocking_Session is not null
order by sample_time desc;
---
select sample_time,event,SESSION_ID,session_serial#,plsql_entry_object_id,plsql_entry_subprogram_id 
, blocking_session, blocking_session_serial#,current_obj#
from DBA_HIST_ACTIVE_SESS_HISTORY
where
sample_time between
                       to_timestamp('2021-02-05 14:43:00','YYYY-MM-DD HH24:MI:SS') and
                        to_timestamp('2021-02-20 14:15:00','YYYY-MM-DD HH24:MI:SS') 
 and blocking_Session is not null
 and event='enq: TX - row lock contention'
order by sample_time desc;
---
select count(*),event
from DBA_HIST_ACTIVE_SESS_HISTORY
where
sample_time between
                       to_timestamp('2021-02-05 14:43:00','YYYY-MM-DD HH24:MI:SS') and
                        to_timestamp('2021-02-20 14:15:00','YYYY-MM-DD HH24:MI:SS') 
 and blocking_Session is not null
 group by event
order by count(*) desc;



select o.object_name, row_wait_obj#, row_wait_file#, row_wait_block#, row_wait_row#,
dbms_rowid.rowid_create ( 1, o.DATA_OBJECT_ID, ROW_WAIT_FILE#, ROW_WAIT_BLOCK#, ROW_WAIT_ROW# )
 from v$session s, dba_objects o where s.ROW_WAIT_OBJ# = o.OBJECT_ID 
 and sid in (select sid  from v$session where event like 'gc buffer busy acquire%');
 
SYS_IL0005018511C00002$$
SYS_IL0005018511C00002$$

---T24
SELECT o.object_name,
       s.sample_time,
       s.session_id,
       s.event,
       s.blocking_session,
       s.sql_id,
       current_obj#,
       current_file#,
       current_block#,
       current_row#,
       DBMS_ROWID.rowid_create (1,
                                o.DATA_OBJECT_ID,
                                current_FILE#,
                                current_BLOCK#,
                                current_ROW#)
  FROM gv$active_session_history s, dba_objects o
 WHERE 
sample_time between
                       to_timestamp('2021-02-05 14:43:00','YYYY-MM-DD HH24:MI:SS') and
                        to_timestamp('2021-02-20 14:15:00','YYYY-MM-DD HH24:MI:SS') and
object_name = 'STF_MB_BPM_TRANS' and blocking_session is not null and event='enq: TX - row lock contention' and s.current_OBJ# = o.OBJECT_ID;

select * from t24core.COFBNK_COLL000 where rowid='AAK+BrAATAAJyGdAAD';

SELECT name
FROM sys.dbms_lock_allocated la, v$session_wait sw
WHERE sw.event='enq: UL - contention'
AND la.lockid=sw.p2;


----Lay may cai thong tin machine, program ... thi dang nay
select * from dba_hist_active_sess_history where session_id=11554            and session_serial#=14852;
select * from dba_objects where object_id=3175985;
select * from dba_procedures where object_id=2106                      and subprogram_id=  2;

---- tong hop
enq: TM - contention    -- dang lock do delete parallel hang trieu rows tu 1 bang co nhieu index  https://perfstat.wordpress.com/2015/01/19/enq-tm-contention-due-to-parallel-dml-and-foreign-keys/
										-- do create index khong co online
https://aprakash.wordpress.com/2011/01/17/enq-tx-row-lock-contention-and-enqtm-contention/
enq: TX - row lock contention
library cache pin   -- lock dang index bitmap: deals with current execution of dependent objects. dam bao object ko bi modify khi dang duoc executing. 
					-- ngoai ra co the xay ra lock pin khi 1 procedure dang duoc thuc thi,  ma ta lai dich lai procedure nay
gc buffer busy acquire
cursor: pin s   -- do su dung AMM dynamic resizing of shared pool
-Library cache locks aka parse locks :needed to maintain dependency mechanism between objects and their dependent objects like SQL.
 dc thiet ke de nhan biet vd khi DDL cua object bi doi, thi cac sql lien quan phai reparse/ invalid.
 https://support.oracle.com/epmos/faces/DocumentDisplay?_afrLoop=252772329113414&parent=EXTERNAL_SEARCH&sourceId=TROUBLESHOOTING&id=1952395.1&_afrWindowMode=0&_adf.ctrl-state=7jdip6vp3_4
 https://support.oracle.com/epmos/faces/DocumentDisplay?_afrLoop=254226941065575&id=444560.1&_adf.ctrl-state=7jdip6vp3_53
Library cache lock la lock toi object handle, trong khi library cache pin la giai doan sau, chi lock toi object heap.
Object handle la dia chi cua object tren cache bao gom object heap ( environment, parameter, bind variable ) + execution plan.
- high version count thi lien quan toi: cung 1 sql_text nhung thuoc cac schema khac nhau, variable co definition size khac nhau, optimizer khac nhau ... 
-Shared pool latch: The shared pool latch is used to protect critical operations when allocating and freeing memory in the shared pool
-The library cache latch: In simple terms latches prevent two processes from simultaneously  updating-and possible corrupting-the same area of the SGA
must be acquired in order to add a new statement to the library cache ( hardparse - kem voi sharepool latch ).
The library cache latch is acquired during a soft parse operation. Oracle still has to check the syntax and semantics of the statement, unless the statement is cached in the session’s cursor cache
- DDL such as create, alter, drop, comment, grant, revoke.
- hard parse: library cache latch, shared pool latch, library cache pin, execution.
- cursor: pin S: do nhieu session cung goi toi 1 thu tuc, 1 cau lenh cung 1 luc https://blog.pythian.com/reducing-contention-on-hot-cursor-objects-cursor-pin-s/
- cursor: pin S wait on X: do long hardparse, do object bi alter ( doi DDL ) va cung luc co nhieu cau lenh dang thuc hien
select p1, p2raw, count(*) from v$session
     where event ='cursor: pin S wait on X'
     and wait_time = 0
     group by p1, p2raw;
	 
SELECT event,p1,FLOOR (p2/POWER(2,4*ws)) blocking_sid,MOD (p2,POWER(2,4*ws)) shared_refcount,
       FLOOR (p3/POWER (2,4*ws)) location_id,MOD (p3,POWER(2,4*ws)) sleeps, blocking_session
  FROM (SELECT DECODE (INSTR (banner, '64bit'), 0, '4', '8') ws FROM v$version WHERE ROWNUM = 1) wordsize, 
             v$active_session_history
 WHERE event = 'cursor: pin S wait on X'and
 sample_time between
                       to_timestamp('2020-08-04 11:50:00','YYYY-MM-DD HH24:MI:SS') and
                        to_timestamp('2020-08-04 12:30:00','YYYY-MM-DD HH24:MI:SS') ;
                        
                        select case when (kglhdadr =  kglhdpar) then 'Parent' else ' Child '||kglobt09 end cursor,
          kglhdadr ADDRESS,kglnaobj name, kglnahsh hash_value,kglobtyd type,kglobt23 LOCKED_TOTAL,kglobt24 PINNED_TOTAL
               from x$kglob  where kglnahsh=2182556592;		
select child_number,reason from v$sql_shared_cursor where sql_id='61x2h0y9zv0r6';

=============== lock dang library cache lock , select ma ko chay ra j, nhieu khi do proc bi invalid, va co ss invalid dang dung function nay. co the mo theo gv$active_session_history: library cache lock  co the do bi lock boi 1 ss wait library cache pin
 SELECT kglnaown "Owner", kglnaobj "Object" FROM x$kglob WHERE kglhdadr in
(select  p1raw from gv$session_wait where event = 'library cache lock');

SELECT s.sid, s.serial#, s.username, s.osuser, s.machine, s.status, kglpnmod "Mode", kglpnreq "Req" FROM x$kglpn p, gv$session s WHERE p.kglpnuse=s.saddr AND  kglpnhdl='0000002198DF3D70';

SELECT s.sid, s.serial#, s.username, s.osuser, s.machine, s.status, kglpnmod "Mode", kglpnreq "Req" FROM x$kglpn p, gv$session s WHERE p.kglpnuse=s.saddr AND  kglpnhdl='000000250263D218';


select sid, serial#, sql_text from dba_kgllock w, gv$session s, gv$sqlarea a where w.kgllkuse = s.saddr and w.kgllkhdl='0000002198DF3D70' and s.sql_address = a.address and s.sql_hash_value = a.hash_value;

==================== row cache lock dc_objects
1) doc file trace
tail -f T24COB1_mmnl_24709128.trc
*** 2022-05-25T18:03:47.845421+07:00
kqrhngc ph1: po 70001019ffbca28 req X from session 7000109627538d0 lock 70001038ef49970

2) tao function vs user sys
create or replace function dump_hex2str (dump_hex varchar2) return varchar2 is
  l_str varchar2(100);
begin
  with sq_pos as (select level pos from dual connect by level <= 1000)
      ,sq_chr as (select pos, chr(to_number(substr(dump_hex, (pos-1)*2+1, 2), 'XX')) ch
                  from sq_pos where pos <= length(dump_hex)/2)
  select listagg(ch, '') within group (order by pos) word
    into l_str
  from sq_chr;
  return l_str;
end;
/
3) query object, session
select dump_hex2str(rtrim(substr(key, 13), '0')) from v$rowcache_parent where cache_name in ('dc_objects') and address like upper('%70001019ffbca28');
select * from gv$session where  saddr like upper('%07000108A3553760');


=========================== row cache lock khac ====================== http://ksun-oracle.blogspot.com/2018/10/oracle-rowcache-views.html
select h.address, h.saddr, s.sid, h.lock_mode
from gv$rowcache_parent h, gv$rowcache_parent w, gv$session s
where h.address = w.address and
            w.saddr = (select saddr from gv$session where event like '%row cache lock%'
                                    and rownum = 1) and
            h.saddr = s.saddr and
            h.lock_mode > 0;

create or replace procedure print_table( p_query in varchar2 )
AUTHID CURRENT_USER
is
    l_theCursor     integer default dbms_sql.open_cursor;
    l_columnValue   varchar2(4000);
    l_status        integer;
    l_descTbl       dbms_sql.desc_tab;
    l_colCnt        number;
begin
      dbms_sql.parse(  l_theCursor,  p_query, dbms_sql.native );
    dbms_sql.describe_columns
    ( l_theCursor, l_colCnt, l_descTbl );

    for i in 1 .. l_colCnt loop
        dbms_sql.define_column
        (l_theCursor, i, l_columnValue, 4000);
    end loop;

    l_status := dbms_sql.execute(l_theCursor);

    while ( dbms_sql.fetch_rows(l_theCursor) > 0 ) loop
        for i in 1 .. l_colCnt loop
            dbms_sql.column_value
            ( l_theCursor, i, l_columnValue );
            dbms_output.put_line
            ( rpad( l_descTbl(i).col_name, 30 )
              || ': ' ||
              l_columnValue );
        end loop;
        dbms_output.put_line( '-----------------' );
    end loop;
    dbms_sql.close_cursor(l_theCursor);
exception
    when others then
     raise;
end;
/
----------------------
vi session
----------
set echo off

---------------------------------------------
-- @name: session
-- @author: Dion Cho
-- @description: detailed snapshot info for given session
-- @usage:
--       @session 147
--       @session 147,155
---------------------------------------------

define __SID = &1;

col process format a15
col machine format a15
col program format a15
col event format a30
col spid format 99999  
col operation_type format a20

set serveroutput on
set verify off

prompt 01. basic session info
begin
  print_table('
    select s.sid, s.serial#, p.spid, s.machine, s.program,
          (select value from v$sesstat where sid = s.sid and
              statistic# = n1.statistic#) as pga,
          (select value from v$sesstat where sid = s.sid and
              statistic# = n2.statistic#) as uga,
          last_call_et,
          logon_time
    from v$session s, v$statname n1, v$statname n2, v$process p
    where sid in (&__SID) and
        n1.name = ''session pga memory'' and
        n2.name = ''session uga memory'' and
        s.paddr = p.addr
  ');

end;
/

prompt 02. session wait
begin
  print_table('
    select sid, event, p1, p1raw, p2, p2raw, p3, p3raw,
          seconds_in_wait, state
    from v$session_wait
    where sid in (&__SID)
  ');
end;
/

prompt 03. process info
begin
        print_table('
            select pid, program, pga_used_mem, pga_alloc_mem, pga_max_mem
            from v$process
            where addr = (select paddr from v$session where sid in (&__SID))
        ');
end;
/

prompt 04. sql info
begin
  print_table('
    select
        (select min(sid) from v$session where sql_address = s.address) as sid,
        sharable_mem, persistent_mem, runtime_mem, executions,
        fetches, buffer_gets,
        sql_text
    from v$sql s
    where address = (select sql_address from v$session where sid in (&__SID))
  ');
end;
/


prompt 05. sql plan info

select
  p.plan_table_output
from
  v$sql s,
  table(dbms_xplan.display_cursor(s.sql_id, s.child_number, 'typical')) p
where
 s.address = (select sql_address from v$session where sid in (&__SID))
;


 
prompt 06. workarea info

begin
  print_table('
    select sid, operation_type, active_time, work_area_size, actual_mem_used,
      max_mem_used
    from v$sql_workarea_active
    where sid in (&__SID)
  ');
end;
/


prompt 07. transaction info

begin
  print_table('
    select addr, xidusn, xidslot, xidsqn,
      ubafil, ubablk, ubasqn,
      ubarec
    from
      v$transaction
    where
      addr = (select taddr from v$session where sid in (&__SID))
    ');
end;
/

set echo on
set serveroutput off
set verify on


---cuoi cung chay:
@session &sid
============================Posts Tagged ‘Row cache objects latch’Solving common Oracle Wait Events for performance tunning
https://samadhandba.wordpress.com/tag/row-cache-objects-latch/
						
						
=========================================== Latch: cache buffers chains https://developpaper.com/how-to-solve-latch-cache-buffers-chains/
+First find the latch address that generates the cache buffers chains that wait the most

select CHILD#  "cCHILD"
 ,      ADDR    "sADDR"
 ,      GETS    "sGETS"
 ,      MISSES  "sMISSES"
 ,      SLEEPS  "sSLEEPS" 
 from v$latch_children 
 where name = 'cache buffers chains'
 order by 5, 1, 2, 3;

+ Then get the segment name based on the latch address found. The TCH field of the above query can be used as a reference to measure the degree of data block hot.

column segment_name format a35
 select /*+ RULE */
   e.owner ||'.'|| e.segment_name  segment_name,
   e.extent_id  extent#,
   x.dbablk - e.block_id + 1  block#,
   x.tch,
   l.child#
 from
   sys.v$latch_children  l,
   sys.x$bh  x,
   sys.dba_extents  e
 where
   x.hladdr  = '&ADDR' and
   e.file_id = x.file# and
   x.hladdr = l.addr and
   x.dbablk between e.block_id and e.block_id + e.blocks -1
 order by x.tch desc ; 
++++++++++++++++a Hiep hyper : ktra session dang bi lock+++++++++++++++++++++++++
-- --- blocking_session la thang dang lockk thang sid_ser , vậy nên có thể ktra xem blocking_session làm gì thì xóa nó đi.
set lines 220
col object_name format a20
col object_type format a20
col machine format a20
col osuser format a20
col time_logon format a20
SELECT C.OWNER,b.INST_ID,b.BLOCKING_SESSION,c.object_name, c.object_type, b.SID, b.serial#, b.status, to_char(b.LOGON_TIME,'DD-MM-YYYY HH24:MM:SS') time_logon,b.LAST_CALL_ET , b.osuser, b.machine
  FROM gv$locked_object a, gv$session b, dba_objects c
 WHERE b.SID = a.session_id AND a.object_id = c.object_id order by LAST_CALL_ET;

 SELECT lo.session_id AS sid,
       s.serial#,
       NVL(lo.oracle_username, '(oracle)') AS username,
       o.owner AS object_owner,
       o.object_name,
       Decode(lo.locked_mode, 0, 'None',
                             1, 'Null (NULL)',
                             2, 'Row-S (SS)',
                             3, 'Row-X (SX)',
                             4, 'Share (S)',
                             5, 'S/Row-X (SSX)',
                             6, 'Exclusive (X)',
                             lo.locked_mode) locked_mode,
       lo.os_user_name
FROM   v$locked_object lo
       JOIN dba_objects o ON o.object_id = lo.object_id
       JOIN v$session s ON lo.session_id = s.sid
ORDER BY 1, 2, 3, 4;
--- blocking_session is locking sid for seconds_in_wait so just kill the blocking_session 
 select
   blocking_session,
   sid,
   serial#,
   wait_class,
   seconds_in_wait
from
   v$session
where
   blocking_session is not NULL
order by
   blocking_session;
--- kiem tra xem sqltext cua blocking_session	 la gi, thay trường blocking_session của query trên vào sid= trong where
	SELECT sid||','||serial# sid_ser,
        status,
     	schemaname||'@'||service_name  from_where, 
        osuser,
        program,
     	NVL((select DISTINCT sql_text from v$sql sql where sql.sql_id = ses.sql_id),'NOTHING GOING ON') sql_text,
     	blocking_session,
     	TO_CHAR(logon_time,'dd/mm/yyyy HH24:MM:SS AM') as from_when
   		FROM v$session ses
  		WHERE type = 'USER' 
  		and type <>'BACKGROUND'
  		and sid='153'
		
++++++++++++ transaction and locked object

select t.start_time, s.sid,s.serial#,s.username,s.status,s.schemaname,
s.osuser,s.process,s.machine,s.terminal,s.program,s.module,s.type, to_char(s.logon_time,'DD/MON/YY HH24:MI:SS') logon_time
from v$transaction t, v$session s
where s.saddr = t.ses_addr 
order by start_time		;

SELECT lo.session_id AS sid,
       s.serial#,
       NVL(lo.oracle_username, '(oracle)') AS username,
       o.owner AS object_owner,
       o.object_name,
       Decode(lo.locked_mode, 0, 'None',
                             1, 'Null (NULL)',
                             2, 'Row-S (SS)',
                             3, 'Row-X (SX)',
                             4, 'Share (S)',
                             5, 'S/Row-X (SSX)',
                             6, 'Exclusive (X)',
                             lo.locked_mode) locked_mode,
       lo.os_user_name
FROM   v$locked_object lo
       JOIN dba_objects o ON o.object_id = lo.object_id
       JOIN v$session s ON lo.session_id = s.sid
ORDER BY 1, 2, 3, 4;

select (b.sid || ',' || b.serial# || ',@' || a.inst_id) sess,b.username, a.addr trans_addr,a.start_scn,a.start_time,  b.osuser,b.process,b.machine,b.program, b.sql_id, d.owner, d.object_name , d.subobject_name, d.object_type  
from gv$transaction a, gv$session b , gv$locked_object c, dba_objects d
where sysdate - to_date(start_time,'mm/dd/yy hh24:mi:ss') > 5/24/60
and a.inst_id=b.inst_id
and a.ses_addr=b.saddr
and b.inst_id=c.inst_id
and b.sid=c.session_id
and d.object_id=c.object_id;
+++++++++++++ anhnq5 +++++++++++++++++++++++++++
-- Câu lệnh chạy nhưng không đóng cursor

select inst_id,sid, user_name,sql_text, sql_id, count(*) from gv$open_cursor a
group by inst_id,sid, user_name,sql_text, sql_id
order by count(*) desc

-- Danh sach cau lenh chay full scan
select username, client_info, program,sql_id,elapsed_time/1000/1000 Giay, sql_text   from gv$sql_monitor
where (inst_id, key) in ( select inst_id, key from  GV$SQL_PLAN_MONITOR
where plan_operation='TABLE ACCESS'
and plan_options='FULL'
)
and username not like 'SYS%'
and username not like 'DBSNMP'
order by elapsed_time/1000/1000 desc

-- Danh sach cau lenh chay lau can cai tien

select username, client_info, program,sql_id,elapsed_time/1000/1000 Giay, sql_text   from gv$sql_monitor
where username not in ('SYS','SYSTEM','DBSNMP')
and elapsed_time/1000/1000 > 60
order by elapsed_time/1000/1000 desc
+++++++++++++++++++ quy trinh chuyen doi ip cluster tuanna 
truoc tien stop het cluster -> doi ip host -> doi /etc/hosts -> start crs tren tat ca cac node
+ doi vip
1. Thực hiện trên máy chủ 10.1.25.21 
2. Câu lệnh:
oracle#srvctl config nodeapps -n test-db01 -a
oracle#srvctl stop vip -n test-db01 -f
root#/oracle/app/grid/19c/bin/srvctl modify nodeapps -n test-db01 -A test-db01-vip/255.255.255.0/en4
oracle#srvctl config nodeapps -n test-db02 -a
oracle#srvctl stop vip -n test-db02 -f
root#/oracle/app/grid/19c/bin/srvctl modify nodeapps -n test-db02 -A test-db02-vip/255.255.255.0/en4
/oracle/app/grid/19c/bin/srvctl modify nodeapps -n test-db03 -A test-db03-vip/255.255.255.0/en4

+ doi scan
root#/oracle/app/grid/19c/bin/srvctl config scan
root#/oracle/app/grid/19c/bin/srvctl stop scan_listener
root#/oracle/app/grid/19c/bin/srvctl  modify scan -n test-db-scan
root#/oracle/app/grid/19c/bin/srvctl start scan
root#/oracle/app/grid/19c/bin/srvctl start scan_listener
root#/oracle/app/grid/19c/bin/srvctl config scan

+ doi public
/oracle/app/grid/19c/bin/oifcfg delif -global en4/10.1.39.0 
/oracle/app/grid/19c/bin/oifcfg setif -global en4/10.1.3.0:public

root#/oracle/app/grid/19c/bin/crsctl stop crs
root#/oracle/app/grid/19c/bin/crsctl start crs

crsctl status resource -w "TYPE = ora.database.type" -t

+ kiem tra th them 1 ip scan
[grid@test-db01:/home/grid]$  srvctl config scan_listener
[grid@test-db01:/home/grid]$  srvctl modify scan_listener -update
[grid@test-db01:/home/grid]$ srvctl start scan_listener
[grid@test-db01:/home/grid]$ crsctl stat res -t        

============ delete node
grid#/oracle/app/grid/19c/deinstall/deinstall -local
root#/oracle/app/grid/19c/bin/crsctl delete node -n test-db03
grid#cluvfy stage -post nodedel -n node_list

root#/oracle/app/grid/19c/bin/srvctl config vip -node  test-db03
root#/oracle/app/grid/19c/bin/srvctl stop vip -vip  test-db03-vip
root#/oracle/app/grid/19c/bin/srvctl remove vip -vip  test-db03-vip

=========== clear install fail on 1 node
1. Xoa /etc/oracle
2. Run cd $GRID_HOME/deinstall/deinstall -local
3. ktra xoa cac thu muc duoi
Run 'rm -r /etc/oraInst.loc' as root on node(s) 'test-db03' at the end of the session.

Run 'rm -r /opt/ORCLfmap' as root on node(s) 'test-db03' at the end of the session.
Run 'rm -r /etc/oratab' as root on node(s) 'test-db03' at the end of the session.
+++++++++++++++++++ failgroup tuanna
select * from v$asm_diskgroup;
select * from v$asm_disk where group_number=4;
select NAME, GROUP_NUMBER from v$asm_diskgroup_stat;
select FAILGROUP, count(NAME) "Disks", max(TOTAL_MB) "MB"
from v$asm_disk_stat
where GROUP_NUMBER=4
group by FAILGROUP
order by 3;
++++++++++++++ hungtn1 long running transaction
select (b.sid || ',' ||b.serial#||',@'||a.inst_id) sess,b.username,a.addr trans_addr,a.start_scn,a.start_time,b.osuser,b.process,b.machine,b.program, b.sql_id,d.owner,d.object_name,d.subobject_name,d.object_type,e.sql_text   
					from gv$transaction a, gv$session b, gv$locked_object c, dba_objects d, gv$sql e
					where sysdate - to_date(start_time,'mm/dd/yy hh24:mi:ss') > 5/24/60
					and b.sql_id=e.sql_id(+)
					and a.inst_id=b.inst_id
					and a.ses_addr=b.saddr
					and b.inst_id=c.inst_id
					and b.sid=c.session_id
					and d.object_id=c.object_id
+++++++++++++ all transaction uncommit+++++++++++++++++++++++++++++++++++
SET lines 200
SET pages 0
 
 
col sid                     FORMAT 99999            
col serial_id               FORMAT 99999999         
col session_status          FORMAT a10               
col oracle_username         FORMAT a14              
col os_username             FORMAT a12             
col os_pid                  FORMAT 9999999          
col session_program         FORMAT a18              
col session_machine         FORMAT a15             
col number_of_undo_records  FORMAT 999,999,999,999 
col used_undo_size          FORMAT 999,999,999,999  
 
 
SELECT
    s.sid                  sid
  , lpad(s.status,9)       session_status
  , lpad(s.username,14)    oracle_username
  , lpad(s.osuser,12)      os_username
  , lpad(p.spid,7)         os_pid
  , b.used_urec            number_of_undo_records
  , b.used_ublk * d.value  used_undo_size
  , s.program              session_program
  , lpad(s.machine,15)     session_machine
FROM
    v$process      p
  , v$session      s
  , v$transaction  b
  , v$parameter    d
WHERE
      b.ses_addr =  s.saddr
  AND p.addr (+) =  s.paddr
  AND s.audsid   <> userenv('SESSIONID')
  AND d.name     =  'db_block_size';
=========== xoa database bao gom all files cua nos. xoa =dbca thi database fai o mode open
RMAN> CONNECT TARGET SYS@test1

target database Password: password
connected to target database: TEST1 (DBID=39525561)

RMAN> select 'DB unique name     ' || DB_UNIQUE_NAME || ' (DBNAME: '||NAME||', DBID: '||dbid||', created on ' || to_char(CREATED,'YYYY/MM/DD HH24:MI')||')' as "Database information"
 from v$database union all select 'Instance status    ' || status || ', Startup time: ' || to_char(startup_time,'YYYY/MM/DD HH24:MI:SS') from v$instance 
union all select 'Database open mode ' || open_mode || ' (SCN ' || to_char(CURRENT_SCN) ||')' from v$database union all select 'Database role      ' || database_role || ' ' || log_mode from v$database 
union all select 'Force logging      ' || force_logging from v$database union all select 'Flashback          ' || flashback_on from v$database union all select 'Resetlog time      '|| to_char(resetlogs_time,'YYYY/MM/DD HH24:MI:SS') from v$database;

RMAN> SQL 'ALTER SYSTEM ENABLE RESTRICTED SESSION';
RMAN> DROP DATABASE INCLUDING BACKUPS NOPROMPT;

alter system set cluster_database=false scope=spfile;
startup mount exclusive restrict;
drop database;
+++++++++ select SID++++++++++++++++++
select sys_context('userenv','db_name') from dual;
+++++++++ check spfile +++++++++++++++++++
show parameter spfile;
CREATE PFILE='$ORACLE_HOME/dbs/init.bk' FROM  spfile;
-- check using pfile or spfile
SELECT DECODE(value, NULL, 'PFILE', 'SPFILE') "Init File Type" 
   FROM sys.v_$parameter WHERE name = 'spfile';


show parameter name_convert
++++  schema va tablespace++++++++++++++++++++++
SELECT distinct tablespace_name FROM dba_segments
WHERE owner = upper ('&OWNER'); 
+++ set linesize nhin cho de++++++++++++++++++++
set linesize 9999;
======================chungtc pga acknowlege over PGA limit 
https://support.oracle.com/epmos/faces/DocumentDisplay?_afrLoop=351951064241022&parent=DOCUMENT&sourceId=2337875.1&id=2138882.1&_afrWindowMode=0&_adf.ctrl-state=ydrm6d4h9_129
The "acknowlege over PGA limit" is a new wait event that was introduced with PGA_AGGREGATE_LIMIT in 12.1, and it will force a process that wants more PGA to wait a bit if the  instance is getting close to hitting the limit. The hope is some other process will release memory and avoid the ORA-4036 error.

PGA_AGGREGATE_LIMIT specifies a limit on the aggregate PGA memory consumed by the instance. By default, PGA_AGGREGATE_LIMIT is set to the greater of 2 GB, 200% of PGA_AGGREGATE_TARGET, 
and 3 MB times the PROCESSES parameter. It will be set below 200% of PGA_AGGREGATE_TARGET if it is larger than 90% of the physical memory size minus the total SGA size, but not below 100% of PGA_AGGREGATE_TARGET.
One can override the default calculations to increase the value of PGA_AGGREGATE_LIMIT. For example:
(1) Increasing PGA_AGGREGATE_TARGET from 2G to 4G will give a default PGA_AGGREGATE_LIMIT of 8G.
(2) Increasing processes parameter to 3000 will give a default PGA_AGGREGATE_LIMIT of 9000M.
(3) Setting underscore parameter "_pga_limit_target_perc"=400 (default 200) will give a default limit of 8G.
		
++++++++++++++number of sessions is computed as ~ (1.5*processes)+20
+++++++++++++++ select max connection++++++++++++++++++++++++++
set linesize 999;
select
	INST_ID,
  resource_name,
  current_utilization,
  max_utilization,
  limit_value
from
  gv$resource_limit
where
  resource_name in ( 'sessions', 'processes');
++++++++++++++ hyper: check cac chuong trinh dang noi
SELECT s.inst_id,
       s.sid,
       s.serial#,
       p.spid,
       s.username,
       s.program
FROM   gv$session s
       JOIN gv$process p ON p.addr = s.paddr AND p.inst_id = s.inst_id
WHERE  s.type != 'BACKGROUND';
++++++++ database size++++++++++++++++++++++++++++++++
An oracle database consists of data files; redo log files, control files, temporary files. And in order to find out the size of the entire database we need to sum up size of all these files.

The biggest portion of a database's size comes from the data files. To find out how many megabytes are allocated to ALL data files: select sum (bytes)/1024/1024/1024 "GB" from v$datafile;

To get the size of all TEMP files: select nvl (sum (bytes), 0)/1024/1024 "Meg" from dba_temp_files;
 To get the size of the on-line redo-logs: select sum (bytes)/1024/1024 "Meg" from sys.v_$log; Hence to find the full size of database sum up all these files size.
 
 +++++++++++++++ redo genrate a day ++++++++++++++++++++++++
  SELECT                                          /* Redo generated per day */
        TO_CHAR (day_, 'YYYY-MM-DD') day_, redosize
    FROM (  SELECT TRUNC (first_time) day_,
                   ROUND (SUM (BLOCKS * BLOCK_SIZE) / 1024 / 1024 / 1024)
                      redosize
              FROM V$ARCHIVED_LOG
             WHERE dest_id = 1  ----------
          GROUP BY TRUNC (first_time))
ORDER BY day_ DESC;

================ tuanna so sanh sau tts ===================================
select a.owner aowner,a.object_type atype,b.owner bowner,b.object_type btype ,acount-bcount diff from 
(select owner,object_type,count(*) as acount from dba_objects where owner in (
select username from dba_users where oracle_maintained ='N')  group by owner,object_type order by owner, object_type)
==============hungtn1 th clear logfile khi restore standby database ============
    ALTER DATABASE CLEAR UNARCHIVED LOGFILE 1 UNRECOVERABLE DATAFILE;
    ALTER DATABASE CLEAR UNARCHIVED LOGFILE 1;
	alter database drop logfile group 1;


 ++++++++++++++++++++++ manage redo log ++++++++++++++++++++++++++++++++++++++++++++++++++++++
Tren thuc te redo log co 3 trang thai: current, active, inactive
	- current: logwriter dang ghi : ko drop duoc, mat current log file se co the mat du lieu
	- active: log file nay van cần để instance recovery ( log file này chứa scn chưa được checkpoint)
	- inactive: đã ko cần để instance recovery nữa
Một redo log file chỉ drop được khi nó inactive + đã được archive

select * from v$logfile;
select  * from v$log;
select * from v$standby_log;
select GROUP#,THREAD#,BYTES/1024/1024/1024,BLOCKSIZE,STATUS from v$standby_log;
select GROUP#,THREAD#,BYTES/1024/1024/1024,BLOCKSIZE,STATUS from v$log;

set linesize 555;
select l.group#,f.member,l.archived, round(l.bytes/1024/1024/1024,2) GB,l.status,f.type
  from v$log l, v$logfile f
 where l.group# = f.group#
order by l.group#;

alter system switch logfile; --- current thi dung cai nay de thanh inactive
alter system archive log current;  --archive thong tin tu redo ra archive file
alter system checkpoint;-- neu active thi dung cai nay de thanh inactive
alter database drop logfile member ‘/u01/oracle/ica/log11.ora’;
alter database drop logfile group 2;

alter database recover managed standby database cancel;
 alter system set standby_file_management=MANUAL;
alter database add  logfile THREAD 1 group 111 ('+DATAEF','+RECOEF') SIZE 1G;

alter database add standby logfile ;
alter database add standby logfile THREAD 1 group 111 ('+ORALOG','+FLASHBACK') SIZE 1G;
alter database add  logfile THREAD 1 group 4 ('+DATAGRP01','+FRAGRP01') SIZE 200M;
alter database add  logfile  group 3 ('+DATA','+FLASHBACK') SIZE 1G;
alter database add  logfile THREAD 2 group 123 ('+DATA') SIZE 2048M;

alter database drop standby logfile group 23;
ALTER DATABASE ADD  standby LOGFILE  THREAD 1 group 211  ('/data/datafile/DREXACRMDB/onlinelog/standby_log_crm.211') SIZE 1G;
alter database recover managed standby database using current logfile disconnect;

alter database drop  logfile group 211;

ALTER DATABASE ADD standby LOGFILE ('/pool72/app/oracle_11_2_0_4/fast_recovery_area/KMTD5_STBY/stby_redo_4.log reuse') SIZE 500M;
ALTER DATABASE ADD  LOGFILE ('/dbdata02/datafiles/orsnew/orsnew/redo07.log') SIZE 500M;
ALTER DATABASE  ADD LOGFILE GROUP 10 ('/oracle/dbs/log1c.rdo', '/oracle/dbs/log2c.rdo')     SIZE 500K;
===== drop redo log file
ALTER DATABASE ADD  LOGFILE ('/data/oltp/redo13.log') SIZE 500M;

SELECT a.group#, THREAD#,a.member, b.bytes/1024/1024  FROM v$logfile a, v$log b WHERE a.group# = b.group#;
alter system switch logfile;
-- sau do thuc hien drop cac logfile not current tu ket qua của sql> select group#, status from v$log;
alter database drop logfile group 2; -- neu gap loi ORA-01624: log 1 needed for crash recovery of instance ORA920 (thread 1) thi thuc hien SQL> ALTER SYSTEM CHECKPOINT GLOBAL;
------------

++++++++++++++++++++++ NOT IN vs NOT EXISTS ++++++++++++++++++++++++++++++++
where id not in (select manager_id from departments) -> se ko tra ve gia tri nao neu inner table co tra ve gia tri null
=> sua bang cach: where not exists (select manager_id from departments where d.manager_id=e.id);
=> OR	where id not in ( select coalesce (manager_id,-1) from departments);
+++++++++++++ kiem tra tat ca schema trong he thong +++++++++++++++++++++++++
select distinct
   owner
from
   dba_segments
where
   owner not in ('ANONYMOUS','AURORA$ORB$UNAUTHENTICATED',
'AWR_STAGE','CSMIG','CTXSYS',
'DBSNMP','DEMO','DIP','DMSYS','DSSYS','EXFSYS',
'HR','OE','SH','LBACSYS','MDSYS','ORACLE_OCM',
'ORDPLUGINS','ORDSYS','OUTLN','PERFSTAT','SCOTT',
'ADAMS','JONES','CLARK','BLAKE','SYS','SYSTEM',
'TRACESVR','TSMSYS','XDB','WMSYS','WKSYS',
'OLAPSYS','SYSMAN','PM','IX');
++++++++++++++remove job+++++++++++++++++++++++++++++
sqlplus> exec dbms_ijob.remove(283);
commit;
sqlplus> exec dbms_ijob.remove(284);
commit;
sqlplus> exec dbms_ijob.remove(285);
commit;
######## select sequence table ################
select t.table_name, d.referenced_name as sequence_name
   from   user_triggers t
          join user_dependencies d
          on d.name = t.trigger_name
   where  d.referenced_type = 'SEQUENCE'
   and    d.type = 'TRIGGER'
   
+++ select all tables in schema++++++++++++++++++++++
	SELECT DISTINCT OWNER, OBJECT_NAME 
  FROM DBA_OBJECTS
 WHERE OBJECT_TYPE = 'TABLE'
   AND OWNER = '[some other schema]'
++++ pass trang oracle+++++++++++
Callfromdemon21431985
++++++++Xem Flash Recovery Area  FRA++++++++++++++++++ anh Linh

sqlplus / as sysdba
Show parameter db_reco
+++++++++++++++xem dang su dung FRA nhu nao
Select file_type, percent_space_used as used,percent_space_reclaimable/1024/1024/1024 as reclaimable,number_of_files as "number" from v$recovery_area_usage;
SELECT substr(name, 1, 30) name,
space_limit/1024/1024/1024 AS quota,
space_used/1024/1024/1024 AS used,
space_reclaimable /1024/1024/1024 AS reclaimable,
number_of_files AS files
FROM V$RECOVERY_FILE_DEST ;

SELECT 
  ROUND((A.SPACE_LIMIT / 1024 / 1024 / 1024), 2) AS FLASH_IN_GB, 
  ROUND((A.SPACE_USED / 1024 / 1024 / 1024), 2) AS FLASH_USED_IN_GB, 
  ROUND((A.SPACE_RECLAIMABLE / 1024 / 1024 / 1024), 2) AS FLASH_RECLAIMABLE_GB,
  SUM(B.PERCENT_SPACE_USED)  AS PERCENT_OF_SPACE_USED
FROM 
  V$RECOVERY_FILE_DEST A,
  V$FLASH_RECOVERY_AREA_USAGE B
GROUP BY
  SPACE_LIMIT, 
  SPACE_USED , 
  SPACE_RECLAIMABLE ;
  
----Neu co su sai khac  giua 2 tham so used cua V$RECOVERY_FILE_DEST va used cua v$recovery_area_usage thi cap nhat chungtc flashback
sqlplus / as sysdba
alter session set events 'immediate trace name kra_options level 1';
exec DBMS_BACKUP_RESTORE.REFRESHAGEDFILES;
exit
+++++++++ Xem duong dan alert log cua DB++++++++++++++++++++++++++anh Linh
Show parameter dump;  -- chon bdump background_dump_dest
Sau do vao duong dan do, ls -lh alert*
tail -100f $ORACLE_BASE/diag/rdbms/evs/$ORACLE_SID/trace/alert_$ORACLE_SID.log

++++++++++Kiem tra lich su dung luong archive log ++++++++++ anh Linh
 select trunc(first_time) on_date,
        thread# thread,
        min(sequence#) min_sequence,
        max(sequence#) max_sequence,
        max(sequence#) - min(sequence#) nos_archives,
        (max(sequence#) - min(sequence#)) * log_avg_mb req_space_mb
 from   v$log_history,
        (select avg(bytes/1024/1024) log_avg_mb
         from   v$log)
group  by trunc(first_time), thread#, log_avg_mb
order by on_date
/

================= delete applied archive log  chungtc=====================
#!/bin/ksh
#
#
# Remove applied archivelog all;
#
# 
ORACLE_SID=ORCL; export ORACLE_SID
ORACLE_BASE=/u01/app/oracle; export ORACLE_BASE
ORACLE_HOME=$ORACLE_BASE/product/12.2.0/db_1; export ORACLE_HOME

tmpfile=/home/oracle/script/checklag.log

$ORACLE_HOME/bin/sqlplus -S /nolog <<EOF > $tmpfile
connect / as sysdba
set head off
set pages 0
select max(sequence#) from v\$archived_log where applied = 'YES';
exit
EOF

echo DELETE NOPROMPT ARCHIVELOG UNTIL SEQUENCE = `head -n 1  $tmpfile | awk '{print $1}'` ';' > $tmpfile

$ORACLE_HOME/bin/rman target / <<EOF
 @$tmpfile
exit
EOF

========================chungtc check archivelog sinh ra trong ngay
select THREAD#, trunc(completion_time) as "DATE"
, count(1) num
, trunc(sum(blocks*block_size)/1024/1024/1024) as GB
, trunc(sum(blocks*block_size)/1024/1024) as MB
, sum(blocks*block_size)/1024 as KB
from v$archived_log
where first_time > trunc(sysdate-10) 
and dest_id = (select dest_id from V$ARCHIVE_DEST_STATUS where status='VALID' and type='LOCAL')
group by thread#, trunc(completion_time)
order by 2,1
;
========================chungtc check log switch ================================
select thread#, trunc(completion_time) as "date", to_char(completion_time,'Dy') as "Day", count(1) as "total",
sum(decode(to_char(completion_time,'HH24'),'00',1,0)) as "h00",
sum(decode(to_char(completion_time,'HH24'),'01',1,0)) as "h01",
sum(decode(to_char(completion_time,'HH24'),'02',1,0)) as "h02",
sum(decode(to_char(completion_time,'HH24'),'03',1,0)) as "h03",
sum(decode(to_char(completion_time,'HH24'),'04',1,0)) as "h04",
sum(decode(to_char(completion_time,'HH24'),'05',1,0)) as "h05",
sum(decode(to_char(completion_time,'HH24'),'06',1,0)) as "h06",
sum(decode(to_char(completion_time,'HH24'),'07',1,0)) as "h07",
sum(decode(to_char(completion_time,'HH24'),'08',1,0)) as "h08",
sum(decode(to_char(completion_time,'HH24'),'09',1,0)) as "h09",
sum(decode(to_char(completion_time,'HH24'),'10',1,0)) as "h10",
sum(decode(to_char(completion_time,'HH24'),'11',1,0)) as "h11",
sum(decode(to_char(completion_time,'HH24'),'12',1,0)) as "h12",
sum(decode(to_char(completion_time,'HH24'),'13',1,0)) as "h13",
sum(decode(to_char(completion_time,'HH24'),'14',1,0)) as "h14",
sum(decode(to_char(completion_time,'HH24'),'15',1,0)) as "h15",
sum(decode(to_char(completion_time,'HH24'),'16',1,0)) as "h16",
sum(decode(to_char(completion_time,'HH24'),'17',1,0)) as "h17",
sum(decode(to_char(completion_time,'HH24'),'18',1,0)) as "h18",
sum(decode(to_char(completion_time,'HH24'),'19',1,0)) as "h19",
sum(decode(to_char(completion_time,'HH24'),'20',1,0)) as "h20",
sum(decode(to_char(completion_time,'HH24'),'21',1,0)) as "h21",
sum(decode(to_char(completion_time,'HH24'),'22',1,0)) as "h22",
sum(decode(to_char(completion_time,'HH24'),'23',1,0)) as "h23"
from
v$archived_log
where first_time > trunc(sysdate-10)
and dest_id = (select dest_id from V$ARCHIVE_DEST_STATUS where status='VALID' and type='LOCAL')
group by thread#, trunc(completion_time), to_char(completion_time, 'Dy') order by 2,1;
	 
  
=== frequency of switching
select b.recid,
       to_char(b.first_time, 'dd/mm/yyyy HH24:mi:ss') start_time,
       a.recid,
       to_char(a.first_time, 'dd/mm/yyyy HH24:mi:ss') end_time,
       round(((a.first_time - b.first_time) * 25) * 60, 2) minutes
  from v$log_history a, v$log_history b
 where a.recid = b.recid + 1
 order by a.first_time asc;  
select thread#,status,count(*)  from v$log group by status,thread#,status;
show parameter fast;
show parameter checkpoint; 
Beginning log switch checkpoint up to RBA [0x11ef0.2.10], SCN: 7445538884498
Completed checkpoint up to RBA [0x11ef0.2.10], SCN: 7445538884498
 
=== frequency of switching
select b.recid,
       to_char(b.first_time, 'dd/mm/yyyy HH24:mi:ss') start_time,
       a.recid,
       to_char(a.first_time, 'dd/mm/yyyy HH24:mi:ss') end_time,
       round(((a.first_time - b.first_time) * 25) * 60, 2) minutes
  from v$log_history a, v$log_history b
 where a.recid = b.recid + 1
 order by a.first_time asc;  
+++++++++++++Kiem tra cau lenh chiem tai nguyen trong khoang thoi gian+++++++++++++ anh Linh+++++++++++++++++++++++++
@?/rdbms/admin/ashrpt.sql
================ clone newuser SCORING_AML to with grant of old user AMLETL
BEGIN
  FOR t IN (SELECT object_name, object_type FROM all_objects WHERE owner='AMLETL' AND object_type IN ('TABLE','VIEW','PROCEDURE','FUNCTION','PACKAGE')) LOOP
    IF t.object_type IN ('TABLE','VIEW') THEN
      EXECUTE IMMEDIATE 'GRANT SELECT, UPDATE, INSERT, DELETE ON AMLETL.'||t.object_name||' TO SCORING_AML ';
    ELSIF t.object_type IN ('PROCEDURE','FUNCTION','PACKAGE') THEN
      EXECUTE IMMEDIATE 'GRANT EXECUTE ON AMLETL.'||t.object_name||' TO SCORING_AML';
    END IF;
  END LOOP;
END;

SELECT DBMS_METADATA.GET_GRANTED_DDL('ROLE_GRANT','AMLETL') FROM DUAL;

 SELECT DBMS_METADATA.GET_GRANTED_DDL('SYSTEM_GRANT','AMLETL') FROM DUAL;

 SELECT DBMS_METADATA.GET_GRANTED_DDL('OBJECT_GRANT','AMLETL') FROM DUAL;




++++++++++++CLONE NEWUSER STS AS USER KMTD4+++++++++++++++++++++++++++++++++++++++++++++++
+++++++++ user TEST nhu KMTD4 sinh ra tu TOAD
DROP USER TEST CASCADE;
select s.sid, s.serial#, s.status, p.spid
from v$session s, v$process p
where s.username = 'myuser'
and p.addr (+) = s.paddr;

CREATE USER TEST
  IDENTIFIED BY VALUES 'TEST'
  DEFAULT TABLESPACE KMTD3_DATA -- table space moi
  TEMPORARY TABLESPACE TEMP
  PROFILE DEFAULT
  ACCOUNT_MASK UNLOCK;
  -- 2 Roles for TEST 
  GRANT CONNECT TO TEST;
  GRANT RESOURCE TO TEST;
  ALTER USER TEST DEFAULT ROLE ALL;
    ALTER USER VISION_READ DEFAULT ROLE all;

  -- 6 System Privileges for TEST 
  GRANT CREATE ANY TABLE TO TEST;
  GRANT CREATE DATABASE LINK TO TEST;
  GRANT CREATE TABLESPACE TO TEST;
  GRANT CREATE VIEW TO TEST;
  GRANT UNLIMITED TABLESPACE TO TEST;
  GRANT DROP TABLESPACE TO TEST;
  -- 10 Object Privileges for TEST 
    GRANT READ, WRITE ON DIRECTORY SYS.BACKUP_DIR TO TEST WITH GRANT OPTION;
    GRANT SELECT ON SYS.DBA_DATA_FILES TO TEST;
    GRANT SELECT ON SYS.DBA_FREE_SPACE TO TEST;
    GRANT SELECT ON SYS.DBA_TABLESPACES TO TEST;
    GRANT EXECUTE ON SYS.DBMS_CRYPTO TO TEST;
    GRANT READ, WRITE ON DIRECTORY SYS.EXPORT_DIR TO TEST WITH GRANT OPTION;
    GRANT SELECT ON SYS.V_$PGASTAT TO TEST;
    GRANT SELECT ON SYS.V_$SGA TO TEST;
    GRANT SELECT ON SYS.V_$SGASTAT TO TEST;
    GRANT SELECT ON SYS.V_$SYSMETRIC_HISTORY TO TEST;
 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++



create user STS_company identified by STS_company default tablespace KMTD_DATA temporary tablespace TEMP
QUOTA 1000M ON KMTD_DATA;
grant CONNECT to STS_company;
grant RESOURCE to STS_company;
grant CREATE ANY TABLE to STS_company;
grant CREATE DATABASE LINK to STS_company;
grant CREATE VIEW to STS_company;
GRANT SELECT  any table TO STS_company;
GRANT INSERT ANY TABLE TO STS_company;
grant DELETE ANY TABLE TO STS_company;
grant ALTER ANY TABLE TO STS_company;
grant UPDATE ANY TABLE TO STS_company;



--- grant quyen select cho user B tren user A
set head off
set pages 0
set lines 9999
set trimspool on
set long 9999999
set feedback off
spool sms.log
select MOBILE||';'|| PROVIDER||';'|| SERVICE_ID||';'|| CREATED_DATE||';'|| UPDATED_DATE||';'|| ID from mbanking.tb_mnp;
spool off;


============create user for dblink

CREATE USER MWOW_DBLINK
  IDENTIFIED BY "mw0d8l1k"
  DEFAULT TABLESPACE USERs
  TEMPORARY TABLESPACE TEMP
  PROFILE APP
  ACCOUNT_MASK UNLOCK;
    GRANT SELECT ON  ibs.bc_user_info to MWOW_DBLINK;
    GRANT SELECT ON ibs.bc_card_info to MWOW_DBLINK;
    GRANT SELECT ON  ibs.bc_bill_payment_history to MWOW_DBLINK;
    GRANT SELECT ON  ibs.bc_bill_payment_service to MWOW_DBLINK;
    GRANT SELECT ON  ibs.bk_sys_parameter to MWOW_DBLINK ;
    grant select,insert,update,delete on ibs.bc_user_info_mwow to MWOW_DBLINK;
    grant select,insert,update,delete on ibs.bc_card_info_mwow to MWOW_DBLINK;
      
    GRANT CREATE SESSION  TO MWOW_DBLINK;
----- tao db link
 CREATE PUBLIC DATABASE LINK DB_LNK_CSKH
 CONNECT TO citadhn
 IDENTIFIED BY citadhn
 USING '(DESCRIPTION=
    (ADDRESS=
      (PROTOCOL=TCP)
      (HOST=10.1.8.214)
      (PORT=1521)
    )
    (CONNECT_DATA=
      (SID=citadhn)
    )
  )';

	CREATE PUBLIC DATABASE LINK dblink_t24rptdr
 CONNECT TO t24core
 IDENTIFIED BY oracle123
 USING '(DESCRIPTION=
    (ADDRESS=
      (PROTOCOL=TCP)
      (HOST=10.2.3.10.2.3.39)
      (PORT=1521)
    )
    (CONNECT_DATA=
      (SERVER=dedicated)
      (SERVICE_NAME=t24rtpdr)
    )
)';

  
  DROP PUBLIC DATABASE LINK ora01uat_2_citadhn


-- voi 11g
CREATE  PUBLIC DATABASE LINK DB_LNK_KMTD196
 CONNECT TO kmtd4 --user
 IDENTIFIED BY "kmtd4"  --pass 
 USING '(DESCRIPTION=
    (ADDRESS=
      (PROTOCOL=TCP)
      (HOST=10.151.242.196)
      (PORT=1521)
    )
    (CONNECT_DATA=
      (SID=kmtd5)
    )
  )';
----select cac connection tu user STS dang thuc hien
select
       substr(a.spid,1,9) pid,
       substr(b.sid,1,5) sid,
       substr(b.serial#,1,5) ser#,
       substr(b.machine,1,6) box,
       substr(b.username,1,10) username,
       b.server,
       substr(b.osuser,1,8) os_user,
       substr(b.program,1,30) program
from v$session b, v$process a
where
b.paddr = a.addr
and type='USER'
and substr(b.username,1,10)  ='STS'
order by spid; 
--
select 'create user '|| 'STS' ||
       ' identified by ' || 'STS' ||
       ' default tablespace ' || default_tablespace ||
       ' temporary tablespace ' || temporary_tablespace || ';' "user"
from   dba_users
where  username = 'KMTD4';

--
select 'alter user STS quota '||
       decode(max_bytes, -1, 'unlimited'
       ,                     ceil(max_bytes / 1024 / 1024) || 'M') ||
       ' on ' || tablespace_name || ';'
from   dba_ts_quotas
where  username = 'KMTD4';

--
select 'grant ' ||granted_role || ' to STS' ||
       decode(admin_option, 'NO', ';', 'YES', ' with admin option;') "ROLE"
from   dba_role_privs
where  grantee = 'KMTD4';

--
select 'grant ' || privilege || ' to STS' ||
       decode(admin_option, 'NO', ';', 'YES', ' with admin option;') "PRIV"
from   dba_sys_privs
where  grantee = 'KMTD4'

---------- cuongtv replace mig 11 10 so---------------
Declare
v_isdn_old varchar2(20):='128'; --vi du '128'
v_isdn_new varchar2(20):='78'; -- vi du '78'
begin
insert into gw_route_Detail set route_value = REPLACE(SUBSTR(route_value, 1, 3),v_isdn_old,v_isdn_new)||SUBSTR(route_value,4)  WHERE route_value LIKE v_isdn_old||'%';
COMMIT;
end;

BEGIN 
  OCSG_OWNER.FORCE_SYNC;
  COMMIT; 
END;

======================== Solution for making a password expire:

SQL> connect sys/secret_password as sysdba;
SQL> alter user sysman ACCOUNT_MASK unlock ;
-- SQL> alter user DBUSER identified by newpa$$word;
-- See these important notes in you want to changing_your_password.

Next, change the profile limit to unlimited.

SQL> alter profile DEFAULT limit PASSWORD_REUSE_TIME unlimited;
SQL> alter profile DEFAULT limit PASSWORD_LIFE_TIME  unlimited;

Check the password expiry date 
 
SQL> select username, ACCOUNT_MASK_status, EXPIRY_DATE from dba_users where username='BURLESON';

-------------CUONGTV CREATE USER---------------------------
CREATE USER inhn PROFILE DEFAULT
IDENTIFIED BY "123456" DEFAULT TABLESPACE DATA
TEMPORARY TABLESPACE TEMP
ACCOUNT_MASK UNLOCK;
GRANT SELECT ON ESP_OWNER.CDR_CONVERTED_DETAIL TO inhn;
GRANT SELECT ON ESP_OWNER.CDR_TRANSACTION_DETAIL TO inhn;
GRANT SELECT ON ESP_OWNER.V_RESELLER TO inhn;
GRANT SELECT ON ESP_OWNER.V_TRANS TO inhn;
GRANT SELECT ON ESP_OWNER.TRANS_REQUEST_LOG TO inhn;
GRANT SELECT ON ESP_OWNER.V_SMS_STK_REQUESTS TO inhn;
GRANT SELECT ON ESP_OWNER.V_SMS_STK_REQUEST_LOG TO inhn;
GRANT SELECT ON ESP_OWNER.V_SMS_STK_RESPONSES TO inhn;
GRANT CONNECT TO inhn;
GRANT RESOURCE TO inhn;

============ change user never expired password================
SQL> alter user sysman ACCOUNT_MASK unlock ;

-- SQL> alter user CRMUSER identified by "crmuser";

-- See these important notes in you want to	changing_your_password.


Next, change the profile limit to unlimited.


	alter profile DEFAULT limit PASSWORD_REUSE_TIME unlimited;

	alter profile DEFAULT limit PASSWORD_LIFE_TIME  unlimited;

	alter user CRMUSER identified by "crmuser";
Check the password expiry date 
	select username, ACCOUNT_MASK_status, EXPIRY_DATE from dba_users where username='CRMUSER';
------------cuongtv change archihve log dest, size ---------------------

show parameter log_archive_dest
show parameter db_recovery_file_dest
SQL> alter system set db_recovery_file_dest_size=70G;

System altered.

SQL> alter system archive log current;

System altered.

SQL> alter system set db_recovery_file_dest='+FRA' sid='*';

System altered.

++++++++++ kt chung ve Automatic memory management (auto tune PGA + SGA): evs dataguard: chinh lai memory_target cho asm, chinh lai sga cho oracle
==== pga advisor, sga advisor
select * from v$sga_target_advice order by sga_size;
select * from v$pga_target_advice order by pga_Target_for_estimate;

Automatic memory management is configured using two new initialization parameters:

MEMORY_TARGET: The amount of shared memory available for Oracle to use when dynamically controlling the SGA and PGA. This parameter is dynamic, so the total amount of memory available to Oracle can be increased or decreased, 
provided it does not exceed the MEMORY_MAX_TARGET limit. The default value is "0".
MEMORY_MAX_TARGET: This defines the maximum size the MEMORY_TARGET can be increased to without an instance restart. If the MEMORY_MAX_TARGET is not specified, it defaults to MEMORY_TARGET setting.
sga_max_size:  parameter sets the hard limit up to which sga_target can dynamically adjust sizes
sga_target: thuong fai set khi ko su dung Automatic memory management 
pga_aggregate_target: thuong fai set khi ko su dung Automatic memory management 
- trong truong hop set Memory_target thi nen set sga_target=pga_aggregate_target=0 de su dung Automatic memory management. Khi do sga size va pga size se duoc auto tune trong Memory_target.
- trong truong hop ko set Memory_target thi fai set gia tri cho sga_target va pga_aggregate_target , luc nay se ko su dung Automatic memory management.

AMM in Oracle 11g:  The 11g release uses AMM and manages all of the SGA AND PGA via the memory_target parameter.  Also, AMM does not use Linux hugepages. Some experts DO NOT recommend using Automatic Shared Memory Management (AMM, e.g. setting memory_target) with Linux hugepages. See MOSC note 749851.1 "HugePages and Oracle Database 11g Automatic Memory Management (AMM) on Linux". Also see MOSC notes 361323.1 and 361468.1.
			1)Check the current values configured for SGA_TARGET and PGA_AGGREGATE_TARGET.
			SQL>SHOW PARAMETER TARGET
			2)Using Spfile
			==============
			ALTER SYSTEM SET MEMORY_MAX_TARGET = 18G SCOPE = SPFILE sid='*';
			ALTER SYSTEM SET MEMORY_TARGET = 18G SCOPE = SPFILE sid='*';
			ALTER SYSTEM SET SGA_TARGET =0 SCOPE = SPFILE sid='*';
			ALTER SYSTEM SET PGA_AGGREGATE_TARGET = 0 SCOPE = SPFILE sid='*';
			ALTER SYSTEM SET pga_aggregate_limit = 0 SCOPE = SPFILE sid='*';
			
			2)Using Pfile
			==============
			If you have started the instance with Pfile, then edit the pfile and set the parameters manually
			MEMORY_MAX_TARGET = 808M
			MEMORY_TARGET = 808M
			SGA_TARGET =0
			PGA_AGGREGATE_TARGET = 0


ASMM in Oracle10g:  Oracle ASMM was with Oracle 10g and uses two parameters  sga_max_size for the SGA and pga_aggregate_target for the PGA.  Also, beware that AMM re-size operations can cripple Oracle performance in some cases, where there s not enough RAM for the optimal pool sizes.
			In case you have enabled Automatic Memory Management , then to switch to Automatic Shared Memory Management , please follow below procedure
			SQL>Alter system set MEMORY_TARGET=0 scope=both;
			SQL>Alter system set SGA_TARGET=3096M scope=both
			alter system set sga_target=3G scope=spfile sid='*';
			alter system set pga_aggregate_target=1G scope=both sid='*';
	
-------- flashback select----------------------------
select * from FLASHBACK_TRANSACTION_QUERY;

SELECT * FROM a_alert_users
AS OF TIMESTAMP TO_TIMESTAMP('2018-12-14 15:43:21', 'YYYY-MM-DD HH24:MI:SS');			
+++++++check PGA, SGA dang cau hinh bao nhieu +++++++++++++++
show parameter sga
show parameter pga
SQL> alter system set SGA_MAX_SIZE=9G scope=spfile;
SQL> alter system set SGA_TARGET=9G scope=spfile;

SQL> SHOW PARAMETER TARGET
NAME                                 TYPE        VALUE
archive_lag_target                   integer     0
db_flashback_retention_target        integer     1440
fast_start_io_target                 integer     0
fast_start_mttr_target               integer     0
memory_max_target                    big integer 0
memory_target                        big integer 0
parallel_servers_target              integer     1024
pga_aggregate_target                 big integer 25G   -- đặt tĩnh
sga_target                           big integer 75G		-- đặt tĩnh sga tăng từ sga_target tới sga_max_size
SQL> show parameter sga
NAME                                 TYPE        VALUE
lock_sga                             boolean     FALSE
pre_page_sga                         boolean     FALSE
sga_max_size                         big integer 128G
sga_target                           big integer 128G

SQL> SHOW PARAMETER TARGET
NAME                                 TYPE        VALUE
archive_lag_target                   integer     0
db_flashback_retention_target        integer     1440
fast_start_io_target                 integer     0
fast_start_mttr_target               integer     0
memory_max_target                    big integer 50G	-- tự động share giữa pga và sga
memory_target                        big integer 49G
parallel_servers_target              integer     1024
pga_aggregate_target                 big integer 0		-- đặt động
sga_target                           big integer 0		-- đặt động
SQL> show parameter sga
NAME                                 TYPE        VALUE
lock_sga                             boolean     FALSE
pre_page_sga                         boolean     FALSE
sga_max_size                         big integer 50G  
sga_target                           big integer 0
+++++++++++++++++ ktra DB is up or not++++++++++++++++++++++
sqlplus / as sysdba
SQL> select status from v$instance;

+++++++++++shut down/ start server+++++++++++++++++++++++++++++++
C2:
#sqlplus / as sysdba
Đánh l?nh: 
# shutdown immediate
N?u ko đư?c:
# shutdown abort
ORA-01031: insufficient privileges
SQL> 
# connect / as sysdba
# shutdown abort

B4: start DB lên, CRT vào server
C1:
#chkconfig --level 345 dbora on
#service dbora start
C2
#sqlplus / as sysdba
#startup
===================convert cdb single to rac: Database option RAC mismatch: PDB installed version NULL. CDB installed version 12.2.0.1.0.
select * from CDB_REGISTRy where comp_id ='RAC';
EXECUTE dbms_registry.loading('RAC','Oracle Real Application Clusters','dbms_clustdb.validate');
@?/rdbms/admin/utlrp

--Neu manual convert thi fai chay
start ?/rdbms/admin/catclust.sql
-- vs loi pdb$seed
alter session set "_oracle_script"=true;
alter pluggable database pdb$seed open read write force;
alter session set container=pdb$seed
EXECUTE dbms_registry.loading('RAC','Oracle Real Application Clusters','dbms_clustdb.validate');
@?/rdbms/admin/utlrp
alter pluggable database pdb$seed close immediate;
alter pluggable database pdb#seed open read only;
+++++++++ CHECK VERSION DB +++++++++++++++++++++++++++++++++
select * from v$version where banner like 'Oracle%';
+++++++++++++TIM DUONG DAN WEB CONSOLE++++++++++++++++++++++
emctl status dbconsole
emctl start dbconsole
emctl stop dbconsole
++++++++++++++++++SHUTDOWN++++++++++++++++++++++++++++++++++
SQLPLUS /NOLOG
CONNECT username/password AS SYSDBA
SHUTDOWN ABORT

++++++++++++++ Tuanba Xem link EM+++++++++++++++++++++++++++++++++++++++
bash#emctl status dbconsole

++++++++ Ktra cache miss > 1% la fai xem lai+++++++++++++++
SELECT   SUM(PINS) "EXECUTIONS",    SUM(RELOADS) "CACHE MISSES WHILE EXECUTING" FROM    V$LIBRARYCAHE; 


============== remove acfs =======================
https://logic.edchen.org/how-to-create-acfs-file-system/
Create ACFS Command:
/sbin/mkfs -t acfs /dev/asm/acfshc01-146


Following commands should be run as privileged user :

/u01/app/19c/grid/bin/srvctl add filesystem -d /dev/asm/acfshc01-146 -m /acfshc01 -u oracle -fstype ACFS -autostart ALWAYS

/u01/app/19c/grid/bin/srvctl start filesystem -d /dev/asm/acfshc01-146

chown oracle:oinstall /acfshc01

chmod 775 /acfshc01


-- kiem tra acfs
asmcmd volinfo --all

-- resize = profile +ASM1
acfsutil size 19T /acfs01

https://asanga-pradeep.blogspot.com/2011/03/creating-and-removing-acfs.html
ASMCMD>  volinfo -G flashback /acfs01
1. Unmount the file system
# umount acfs01
2. De-register the file system
# acfsutil registry -d /acfs01
acfsutil registry: successfully removed ACFS mount point /acfs01 from Oracle Registry
3. Drop the volumne from the diskgroup
SQL> alter diskgroup ORALOG drop volume acfs01;

Diskgroup altered.

SQL> select volume_name,volume_device from v$asm_volume;

============= check cpu core socket ================
col c1 heading '#|CPUs'        format 999
col c2 heading '#|CPU|Cores'   format 999
col c3 heading '#|CPU|Sockets' format 999

select
   (select max(value) from dba_hist_osstat 
    where stat_name = 'NUM_CPUS')        c1,
   (select max(value) from dba_hist_osstat 
    where stat_name = 'NUM_CPU_CORES')   c2,
   (select max(value) from dba_hist_osstat 
    where stat_name = 'NUM_CPU_SOCKETS') c3
from dual;
============================parallell force local ==============================
Alter system set parallel_force_local = true scope=both sid='*';


nohup sqlplus "/ as sysdba" @script.sql > script.out 2>&1 &
nohup sqlplus "/ as sysdba" @script1.sql > script1.out 2>&1 &
nohup sqlplus "/ as sysdba" @ods_index.sql > ods_index.out 2>&1 &

impdp \'sys/sys123@khdncore as sysdba\' parfile='/acfs01/dump/mypar_imp.par'

nohup sqlplus "sys/oracle@khdnpdb1 as sysdba" @script.sql >  script.out 2>&1 &
=====================trace rman ===============================================
rman target / debug trace=debug1.trc log=rman1.log

RMAN> { your commands }

=================restore datafile ===========================
backup datafile 16 format '/tmp/16.dbf';

catalog start with '/tmp/16.dbf'
run{
set newname for datafile 16 to '+DATA';
restore datafile 16;
SWITCH datafile 16;  
}
============nohup rman restore===================================================
--restore datafile 2102 from service ecmscan using compressed backupset;
-- recover database from service "ecmscan" noredo using compressed backupset;
--restore  from service  'ecmscan' standby controlfile;
--restore database from service "ecmscan"  using compressed backupset;
--switch database to copy
create spfile ='/u01/app/oracle/product/11.2.0.4/dbs/spfiledformdb1.ora' from pfile='/tmp/pfile';
restore standby controlfile from '/backup/backup/ctf_20200326_CDB10_34_1';	
rman target sys/mb#123dba@10.1.39.181:1521/T24COB auxiliary sys/mb#123dba@10.1.33.18:1521/T24COB
duplicate target database to 'T24COB' from active database;

catalog start with '/backup/backup';
alter database flashback off;
alter database disable BLOCK CHANGE TRACKING;
crosscheck backup;
crosscheck archivelog all;
vi /home/oracle/run_rman.sh
#!/bin/ksh
export ORACLE_SID=owprod1
export ORACLE_BASE=/oracle/app/oracle
export ORACLE_HOME=/oracle/app/oracle/product/12.2.0.1
export BASE_PATH=/usr/sbin:$PATH
export PATH=$PATH:$ORACLE_HOME/bin:$ORACLE_HOME/OPatch
rman target / cmdfile=/home/oracle/rman_restore_way4dr.rman msglog /home/oracle/rman_restore_way4dr.log

chmod 775 /home/oracle/run_rman.sh

vi /home/oracle/rman_restore_way4dr.rman
run{
allocate channel rman_disk01 type disk maxopenfiles 1;                                   
allocate channel rman_disk02 type disk maxopenfiles 1;                                                                                                               
allocate channel rman_disk03 type disk maxopenfiles 1;                                   
allocate channel rman_disk04 type disk maxopenfiles 1;                                   
allocate channel rman_disk05 type disk maxopenfiles 1;                                                                                                               
allocate channel rman_disk06 type disk maxopenfiles 1;
allocate channel rman_disk07 type disk maxopenfiles 1;                                   
allocate channel rman_disk08 type disk maxopenfiles 1;                                                                                                               
allocate channel rman_disk09 type disk maxopenfiles 1;
SET NEWNAME FOR DATABASE TO '+DATA/ECMSCADR/DATAFILE/%U';
restore database;
switch datafile all;
recover database;
release channel rman_disk01;
release channel rman_disk02;
release channel rman_disk03;
release channel rman_disk04;
release channel rman_disk05;
release channel rman_disk06;
release channel rman_disk07;
release channel rman_disk08;
release channel rman_disk09;
} 

nohup /home/oracle/run_rman.sh & 


svmon -Pt15 | perl -e 'while(<>){print if($.==2||$&&&!$s++);$.=0 if(/^-+$/)}'

alter system set log_archive_config='dg_config=(ra1db,T24COB,t24dr,t24rptdr)' scope=both sid='*';
alter system set log_archive_dest_2   ='SERVICE=DRT24VNDLM NOAFFIRM ASYNC VALID_FOR=(ONLINE_LOGFILES,PRIMARY_ROLE) DB_UNIQUE_NAME=DRT24VNDLM' scope=both sid='*';

alter system set log_archive_dest_3  ='SERVICE=t24rptdr NOAFFIRM ASYNC VALID_FOR=(ONLINE_LOGFILES,PRIMARY_ROLE) DB_UNIQUE_NAME=t24rptdr' scope=both sid='*';
alter system set log_archive_dest_2='service=t24drnew ARCH COMPRESSION=ENABLE  VALID_FOR=(ALL_LOGFILES,STANDBY_ROLE) db_unique_name=t24drnew' scope=both sid='*';
alter system set log_archive_dest_2='service=t24drnew ARCH COMPRESSION=ENABLE  VALID_FOR=(ONLINE_LOGFILES,PRIMARY_ROLE) db_unique_name=orswarmdr DELAY=1440' scope=both sid='*' ;
alter system set fal_client=drtest scope=both sid='*';
alter system set fal_server=test,testdr scope=both sid='*';

alter system set log_archive_dest_2   ='SERVICE=orswarmdr NOAFFIRM ASYNC VALID_FOR=(ONLINE_LOGFILES,PRIMARY_ROLE) DB_UNIQUE_NAME=orswarmdr DELAY=1440' scope=both sid='*';
ALTER DATABASE RECOVER MANAGED STANDBY DATABASE USING ARCHIVED LOGFILE DISCONNECT;
select COMPLETION_TIME from v$archived_log where SEQUENCE#=75652;
--neu co loi ORA-16188: LOG_ARCHIVE_CONFIG settings inconsistent with previously started instance
alter system set log_archive_config=NODG_CONFIG scope=both sid='*';
================== rman restore when have read only datafile =====================
restore controlfile from '/u01/app/oracle/backup/ctf_20200619_TESTDB_9_1';
restore database check readonly;
restore datafile 7;
recover database;
 alter database open resetlogs;
 
 -- neu ko co buoc restore datafile 7 ( la datafile read only ) co the se co loi dang
 RMAN> recover database;

Starting recover at 19-JUN-20
using channel ORA_DISK_1

starting media recovery

Oracle Error: 
ORA-01547: warning: RECOVER succeeded but OPEN RESETLOGS would get error below
ORA-01152: file 1 was not restored from a sufficiently old backup 
ORA-01110: data file 1: '+DATA/testdb/datafile/system.571.1043520569'

========== tim scn 
restore archivelog all;

 col next_change# format 999999999999999;
			 col first_change# format 999999999999999;

			 select sequence#, to_date(first_time,'DD-MON-YYYY HH24:MI:SS') first_time, 
						  first_change#, 
						  to_date(next_time,'DD-MON-YYYY HH24:MI:SS') next_time, 
						  next_change# from v$archived_log
			 where completion_time between to_date('JUN-22-2010','MON-DD-YYYY') and Sysdate
			 ;

======================
RMAN> RESTORE DATABASE PREVIEW;

Output will look like example.

validation succeeded for backup piece

Media recovery start SCN is 169070460360

Recovery must be done beyond SCN 169092024179 to clear datafile fuzziness

validation succeeded for backup piece

Finished restore at 06.05.2015 14:18:16

RMAN> restore database;

RMAN> recover database until scn 169092024179;

==================== chungtc check rman progress khi restore point in time ====================== alter session set nls_date_format = 'DD-MON-YYYY HH24:MI:SS';

---------------- ve ly thuyet khi restore point in time thi fai de y toi thoi gian backup + datafile moi tao
---vi du neu thoi gian backup tu 6h-7h thi fai kiem tra co datafile moi nao duoc tao trong khoang thoi gian nay khong. Neu co thi chac chan se khong restore duoc. 
--Va fai dich ve khoang thoi gian backup sau do, hoac som hon thoi diem datafile duoc tao ra
select * from v$datafile where creation_time >= to_date('2021-11-19 06:00:00','YYYY-MM-DD hh24:mi:ss') 
order by creation_time;
-- checkpoint_change la thoi gian theo controlfile, checkpoint_Time se dung o thoi diem point in time mong muon, se ko co datafile nao bi fuzzy
--- STATUS  TO_CHAR(CHECKPOINT_CHANGE#)              CHECKPOINT_TIME     TO_CHAR(RESETLOGS_CHANGE#)               RESETLOGS_TIME        COUNT(*) FUZ
------- ---------------------------------------- ------------------- ---------------------------------------- ------------------- ---------- ---
--ONLINE  7027022405017 (sau khi resetlog day la scn thoi diem point in time)                           2021-03-29 22:00:00 ( thoi gian muon point in time) 6023915464236                            2017-02-10 20:26:51       1926 NO ( ko datafile nao bi fuzzy)

select status,to_char(checkpoint_change#),checkpoint_time, to_char(resetlogs_change#), resetlogs_time, count(*), fuzzy 
from v$datafile_header group by status,checkpoint_change#,checkpoint_time, resetlogs_change#, resetlogs_time, fuzzy;

select to_char(first_change#),to_char(next_change#),next_time from v$archived_log where sequence#='7017881474312' and dest_id=1;

---- thoi gian theo controlfile, de database open dc thi CHECKPOINT_CHANGE tai v$datafile_header va v$database fai trung nhau + ko datafile nao trong tinh trang FUZZY
---- Khi backup tu standby database, thi khi restore ve khoang time ma backup van dang running thi co tinh trang bi fuzzy.
---- Voi ZDL, no se restore controlfile tu thoi gian backup gan nhat ( nhung som' hon thoi gian point in time )
select to_Char(CONTROLFILE_CHANGE#) ,to_Char(CHECKPOINT_CHANGE#)  from v$database;  7029797012804

-- chon nexchange de recover toi thoi gian mong muon
select to_char(first_change#),to_char(next_change#),next_time from v$archived_log
where next_time >=to_date('2021-03-23 06:55:00','YYYY-MM-DD hh24:mi:ss') 
and next_time <=to_date('2021-03-23 07:05:00','YYYY-MM-DD hh24:mi:ss') ;

---- xem xem da restore du datafile chua
select file# from v$datafile minus select file# from v$datafile_copy union
select file# from v$datafile_copy where name is null;


------ vi du ve viec co the read only ok:
STATUS  TO_CHAR(CHECKPOINT_CHANGE#)              CHECKPOINT_TIME     TO_CHAR(RESETLOGS_CHANGE#)               RESETLOGS_TIME        COUNT(*) FUZ
------- ---------------------------------------- ------------------- ---------------------------------------- ------------------- ---------- ---
ONLINE  7162719911953                            2021-07-06 01:39:59 6825526849562                            2020-09-25 21:40:28        793 NO

Elapsed: 00:00:03.27
10:13:22 sys@way4db1> select to_Char(CONTROLFILE_CHANGE#) ,to_Char(CHECKPOINT_CHANGE#)  from v$database;  

TO_CHAR(CONTROLFILE_CHANGE#)             TO_CHAR(CHECKPOINT_CHANGE#)
---------------------------------------- ----------------------------------------
7162719911953                            6939495236247
========================== rman restore point in time =============================== vi du restore ngay 29 thi fai restore control file ngay 30
db_name=IBPROD
db_unique_name=aduF_pitr_IBPROD
compatible=12.1.0.2.0
db_block_size=8192
db_files=200
diagnostic_dest=/u01/app/oracle
_system_trig_enabled=FALSE
sga_target=2560M
processes=200
db_create_file_dest=/data/
*.cluster_database=false
log_archive_dest_1='location=/data/'
*.control_files='/u01/app/oracle/product/12.1.0/dbhome_1/dbs/control_ibp.dbf'

ALLOCATE CHANNEL FOR MAINTENANCE DEVICE type 'sbt_tape' PARMS 'SBT_LIBRARY=/opt/commvault/Base/libobk.so';
ALLOCATE CHANNEL FOR MAINTENANCE DEVICE TYPE DISK 
https://documentation.commvault.com/commvault/v11/article?p=20123.htm
run {
allocate channel ch1 type 'sbt_tape' PARMS="SBT_LIBRARY=/opt/commvault/Base/libobk.so,BLKSIZE=1048576";
set until time "to_date('23-MAR-2021 07:00:00','DD-MON-YYYY HH24:MI:SS')"; 
restore controlfile  from  '452717_AICTRPT_o3vqfr3e_1_1';
	  }
	  
run {
allocate channel ch1 type 'sbt_tape' PARMS="SBT_LIBRARY=/opt/commvault/Base/libobk.so,BLKSIZE=1048576";
allocate channel ch2 type 'sbt_tape' PARMS="SBT_LIBRARY=/opt/commvault/Base/libobk.so,BLKSIZE=1048576";
setlimit channel ch1 maxopenfiles 12;
setlimit channel ch2 maxopenfiles 12;
recover database; }



run {
allocate channel ch1 type 'sbt_tape' PARMS="SBT_LIBRARY=/opt/commvault/Base/libobk.so, BLKSIZE=1048576 ENV=(CV_mmsApiVsn=2,CV_channelPar=ch12,ThreadCommandLine= -jm 262286 -a 2:3512 -cl 699 -ins 106 -at 22 -j 456541 -jt 456541:3:3 -rcp 0 -ms 12 -p 2 -df -cn 10.1.7.150-backup-restoredb-2021 -vm Instance001)" TRACE 0;
send " -jm 131086 -a 2:3512 -cl 699 -ins 106 -at 22 -j 456509 -jt 456509:2:1 -rcp 0 -ms 12 -p 1 -df";
 restore controlfile  from  'c-357060088-20210326-03' ;
}


cd /usr/openv/netbackup/bin

./bplist -S dc-nbumaster.msb.com.vn  -s 03/29/2020 -e 03/30/2020  -C ibprd01 -t 4 -l -R /


run {
 allocate channel c1 device type 'sbt_tape' parms 'SBT_LIBRARY=/usr/openv/netbackup/bin/libobk.a64(shr.o)';
 #allocate channel c1 device type 'sbt_tape' parms 'SBT_LIBRARY=/usr/openv/netbackup/bin/libobk.so64';

 send 'NB_ORA_SERV=dc-nbumaster.msb.com.vn, NB_ORA_CLIENT= ibprd01';
 set until time "to_date('29-MAR-2020 23:00:00','DD-MON-YYYY HH24:MI:SS')"; 
 restore controlfile  from '/ctrl_dIBPROD_uf7usbhcm_s12775_p1_t1036371350';
 release channel c1;
 }
 
 vi /home/oracle/run_rman.sh
#!/bin/ksh
export ORACLE_SID=ibprod
export ORACLE_BASE=/u01/app/oracle
export ORACLE_HOME=/u01/app/oracle/product/12.1.0/dbhome_1
export BASE_PATH=/usr/sbin:$PATH
export PATH=$PATH:$ORACLE_HOME/bin:$ORACLE_HOME/OPatch
rman target / cmdfile=/home/oracle/rman_restore.rman msglog /home/oracle/rman_restore.log

chmod 775  /home/oracle/run_rman.sh

vi /home/oracle/rman_restore.rman
run{
allocate channel c1 device type 'sbt_tape' parms 'SBT_LIBRARY=/usr/openv/netbackup/bin/libobk.a64(shr.o)';
allocate channel c2 device type 'sbt_tape' parms 'SBT_LIBRARY=/usr/openv/netbackup/bin/libobk.a64(shr.o)';
allocate channel c3 device type 'sbt_tape' parms 'SBT_LIBRARY=/usr/openv/netbackup/bin/libobk.a64(shr.o)';
allocate channel c4 device type 'sbt_tape' parms 'SBT_LIBRARY=/usr/openv/netbackup/bin/libobk.a64(shr.o)';

send 'NB_ORA_SERV=dc-nbumaster.msb.com.vn, NB_ORA_CLIENT= ibprd01';
set until time "to_date('29-MAR-2020 23:00:00','DD-MON-YYYY HH24:MI:SS')"; 
SET NEWNAME FOR DATABASE TO '/data/%b';
restore database;
switch datafile all;
recover database;
               release channel c1 ;
			                  release channel c2 ;
               release channel c3 ;
               release channel c4 ;

 }


nohup /home/oracle/run_rman.sh & 

run {
allocate channel c1 device type 'sbt_tape' parms 'SBT_LIBRARY=/usr/openv/netbackup/bin/libobk.a64(shr.o)';
send 'NB_ORA_SERV=dc-nbumaster.msb.com.vn, NB_ORA_CLIENT= ibprd01';
set until time "to_date('29-MAR-2020 23:00:00','DD-MON-YYYY HH24:MI:SS')";
recover database;
}


================================================= zdl t24
rman target /
connect catalog VPC_ZDLRA/Grabm26wLj@zdl-scan1:1521/ra1db:dedicated;
run
{
ALLOCATE CHANNEL T1 TYPE 'SBT_TAPE' PARMS='SBT_LIBRARY=/oracle/app/oracle/product/19c/lib/libra.so, ENV=(RA_WALLET=location=file:/oracle/app/oracle/wallet credential_alias=zdl-scan1:1521/ra1db:dedicated)';
ALLOCATE CHANNEL T2 TYPE 'SBT_TAPE' PARMS='SBT_LIBRARY=/oracle/app/oracle/product/19c/lib/libra.so, ENV=(RA_WALLET=location=file:/oracle/app/oracle/wallet credential_alias=zdl-scan1:1521/ra1db:dedicated)';
ALLOCATE CHANNEL T3 TYPE 'SBT_TAPE' PARMS='SBT_LIBRARY=/oracle/app/oracle/product/19c/lib/libra.so, ENV=(RA_WALLET=location=file:/oracle/app/oracle/wallet credential_alias=zdl-scan1:1521/ra1db:dedicated)';
ALLOCATE CHANNEL T4 TYPE 'SBT_TAPE' PARMS='SBT_LIBRARY=/oracle/app/oracle/product/19c/lib/libra.so, ENV=(RA_WALLET=location=file:/oracle/app/oracle/wallet credential_alias=zdl-scan1:1521/ra1db:dedicated)';
ALLOCATE CHANNEL T5 TYPE 'SBT_TAPE' PARMS='SBT_LIBRARY=/oracle/app/oracle/product/19c/lib/libra.so, ENV=(RA_WALLET=location=file:/oracle/app/oracle/wallet credential_alias=zdl-scan1:1521/ra1db:dedicated)';
ALLOCATE CHANNEL T6 TYPE 'SBT_TAPE' PARMS='SBT_LIBRARY=/oracle/app/oracle/product/19c/lib/libra.so, ENV=(RA_WALLET=location=file:/oracle/app/oracle/wallet credential_alias=zdl-scan1:1521/ra1db:dedicated)';
ALLOCATE CHANNEL T7 TYPE 'SBT_TAPE' PARMS='SBT_LIBRARY=/oracle/app/oracle/product/19c/lib/libra.so, ENV=(RA_WALLET=location=file:/oracle/app/oracle/wallet credential_alias=zdl-scan1:1521/ra1db:dedicated)';
ALLOCATE CHANNEL T8 TYPE 'SBT_TAPE' PARMS='SBT_LIBRARY=/oracle/app/oracle/product/19c/lib/libra.so, ENV=(RA_WALLET=location=file:/oracle/app/oracle/wallet credential_alias=zdl-scan1:1521/ra1db:dedicated)';
ALLOCATE CHANNEL T9 TYPE 'SBT_TAPE' PARMS='SBT_LIBRARY=/oracle/app/oracle/product/19c/lib/libra.so, ENV=(RA_WALLET=location=file:/oracle/app/oracle/wallet credential_alias=zdl-scan1:1521/ra1db:dedicated)';
ALLOCATE CHANNEL T10 TYPE 'SBT_TAPE' PARMS='SBT_LIBRARY=/oracle/app/oracle/product/19c/lib/libra.so, ENV=(RA_WALLET=location=file:/oracle/app/oracle/wallet credential_alias=zdl-scan1:1521/ra1db:dedicated)';
BACKUP AS COMPRESSED BACKUPSET ARCHIVELOG from time 'trunc(sysdate-1)+(6/24)' until time 'trunc(sysdate-1)+8.5/24';
}
=========================================================nohup rman restore point in time by ZDL
vi /home/oracle/run_rman.sh
#!/bin/ksh
export NLS_DATE_FORMAT='yyyy/mm/dd hh24:mi:ss'
export ORACLE_SID=T24TEST1
export NLS_DATE_FORMAT='yyyy/mm/dd hh24:mi:ss'
export ORACLE_BASE=/oracle/app/oracle
export ORACLE_HOME=/oracle/app/oracle/product/11.2.0.3
export BASE_PATH=/usr/sbin:$PATH
export PATH=$PATH:$ORACLE_HOME/bin:$ORACLE_HOME/OPatch
rman target /  cmdfile=/home/oracle/rman_restore.rman msglog /home/oracle/rman_restore.log

chmod 775 /home/oracle/run_rman.sh

cat /home/oracle/rman_restore.rman 
CONNECT AUXILIARY / ;
CONNECT CATALOG /@zdl-scan1:1521/ra1db:dedicated;
run{
ALLOCATE auxiliary CHANNEL T1 TYPE 'SBT_TAPE' PARMS='SBT_LIBRARY=/oracle/app/oracle/product/11.2.0.3/lib/libra.so, ENV=(RA_WALLET=location=file:/oracle/app/oracle/wallet credential_alias=zdl-scan1:1521/ra1db:dedicated)';
ALLOCATE auxiliary CHANNEL T2 TYPE 'SBT_TAPE' PARMS='SBT_LIBRARY=/oracle/app/oracle/product/11.2.0.3/lib/libra.so, ENV=(RA_WALLET=location=file:/oracle/app/oracle/wallet credential_alias=zdl-scan1:1521/ra1db:dedicated)';
set until time "to_date('15-MAR-2021 18:00:00','DD-MON-YYYY HH24:MI:SS')"; 
DUPLICATE DATABASE T24COB to T24TEST NOFILENAMECHECK;
}

nohup /home/oracle/run_rman.sh & 


--------
rman  target /  CATALOG /@zdl-scan1:1521/ra1db:dedicated 
 list backup of controlfile;

--- co the catalog cac datafile cu va switch
catalog start with '';
switch database to copy;
---- rename log file neu can
select 'sql "ALTER DATABASE RENAME FILE '''''||MEMBER||'''''  to  ''''' ||replace (member,'CDBSM','CDBSMDR')||'''''";' from v$logfile;
--bat db len
alter database open resetlogs;
-- kiem tra scn
select SCN_TO_TIMESTAMP(7470730623904) from dual;
select SCN_TO_TIMESTAMP((select current_scn from v$database)), TIMESTAMP_TO_SCN(sysdate-1)  from dual;
====================nohup rman backup =====================================
vi /home/oracle/scripts/run_rman.sh
#!/bin/ksh
export ORACLE_SID=orswarm1
export ORACLE_BASE=/oracle/app/oraclebase
export ORACLE_HOME=$ORACLE_BASE/product/12.1.0.2
export PATH=/usr/sbin:$PATH
export PATH=$ORACLE_HOME/bin:$PATH

export LD_LIBRARY_PATH=$ORACLE_HOME/lib:/lib:/usr/lib
export CLASSPATH=$ORACLE_HOME/jlib:$ORACLE_HOME/rdbms/jlib
export CLASSPATH=$CLASSPATH:/oracle/soft/jsch-0.1.54.jar

rman target / cmdfile=/home/oracle/scripts/run_rman.rman msglog /home/oracle/scripts/run_rman.log

chmod 775 /home/oracle/scripts/run_rman.sh
-------------
vi /home/oracle/scripts/run_rman.rman
run {
allocate channel ch1 device type disk format '/backup1/test/backupfile_%U';
allocate channel ch2 device type disk format '/backup1/test/backupfile_%U';
allocate channel ch3 device type disk format '/backup1/test/backupfile_%U';
allocate channel ch4 device type disk format '/backup1/test/backupfile_%U';
allocate channel ch5 device type disk format '/backup1/test/backupfile_%U';
allocate channel ch6 device type disk format '/backup1/test/backupfile_%U';
allocate channel ch7 device type disk format '/backup1/test/backupfile_%U';
allocate channel ch8 device type disk format '/backup1/test/backupfile_%U';
sql 'alter system archive log current';
CROSSCHECK ARCHIVELOG ALL;
backup as compressed backupset database plus archivelog maxsetsize 20G TAG FULL20200828;
BACKUP AS COMPRESSED BACKUPSET CURRENT CONTROLFILE FORMAT '/backup1/test/ctf' TAG CTLFILE;
release channel ch1;
release channel ch2;
release channel ch3;
release channel ch4;
release channel ch5;
release channel ch6;
release channel ch7;
release channel ch8;
} 


vi /home/oracle/scripts/run_rman.sh
#!/bin/ksh
export ORACLE_SID=clouddb
export ORACLE_BASE=/oracle/app/oracle
export ORACLE_HOME=$ORACLE_BASE/product/12.2.0.1
export BASE_PATH=/usr/sbin:$PATH
export PATH=$PATH:$ORACLE_HOME/bin:$ORACLE_HOME/OPatch
sqlplus / as sysdba <<ENDOFSQL
CREATE PFILE='/dbdata2/backup/pfile.bk' FROM  spfile;
exit;
ENDOFSQL
rman target=/ cmdfile=/home/oracle/scripts/backup.rman msglog /home/oracle/scripts/backup.log

chmod 775  /home/oracle/scripts/run_rman.sh

nohup /home/oracle/run_rman.sh & 
================== tuanna restore 

rman target / 
connect catalog VPC_ZDLRA/Grabm26wLj@172.16.83.12:1522/ra1db
run {
ALLOCATE CHANNEL T1 DEVICE TYPE 'SBT_TAPE' PARMS='SBT_LIBRARY=/oracle/app/oracle/product/19c/lib/libra.so, ENV=(RA_WALLET=location=file:/oracle/app/oracle/wallet credential_alias=zdl_rest)';
set until time "to_date('01-OCT-2022 21:58:00','DD-MON-YYYY HH24:MI:SS')";
restore controlfile;
}
ctl_T24COB_20220930_j31922ji_124515_1_1.ctl
ctl_t24dlm_20221004_sq19f1ti_115610_1_1.ctl tag=TAG20221004T204849

run{
ALLOCATE CHANNEL T1 DEVICE TYPE 'SBT_TAPE' PARMS='SBT_LIBRARY=/oracle/app/oracle/product/19c/lib/libra.so, ENV=(RA_WALLET=location=file:/oracle/app/oracle/wallet credential_alias= zdl_rest)'; 
ALLOCATE CHANNEL T2 DEVICE TYPE 'SBT_TAPE' PARMS='SBT_LIBRARY=/oracle/app/oracle/product/19c/lib/libra.so, ENV=(RA_WALLET=location=file:/oracle/app/oracle/wallet credential_alias= zdl_rest)'; 
ALLOCATE CHANNEL T3 DEVICE TYPE 'SBT_TAPE' PARMS='SBT_LIBRARY=/oracle/app/oracle/product/19c/lib/libra.so, ENV=(RA_WALLET=location=file:/oracle/app/oracle/wallet credential_alias= zdl_rest)'; 
ALLOCATE CHANNEL T4 DEVICE TYPE 'SBT_TAPE' PARMS='SBT_LIBRARY=/oracle/app/oracle/product/19c/lib/libra.so, ENV=(RA_WALLET=location=file:/oracle/app/oracle/wallet credential_alias= zdl_rest)'; 
ALLOCATE CHANNEL T5 DEVICE TYPE 'SBT_TAPE' PARMS='SBT_LIBRARY=/oracle/app/oracle/product/19c/lib/libra.so, ENV=(RA_WALLET=location=file:/oracle/app/oracle/wallet credential_alias= zdl_rest)'; 
ALLOCATE CHANNEL T6 DEVICE TYPE 'SBT_TAPE' PARMS='SBT_LIBRARY=/oracle/app/oracle/product/19c/lib/libra.so, ENV=(RA_WALLET=location=file:/oracle/app/oracle/wallet credential_alias= zdl_rest)'; 
ALLOCATE CHANNEL T7 DEVICE TYPE 'SBT_TAPE' PARMS='SBT_LIBRARY=/oracle/app/oracle/product/19c/lib/libra.so, ENV=(RA_WALLET=location=file:/oracle/app/oracle/wallet credential_alias= zdl_rest)'; 
ALLOCATE CHANNEL T8 DEVICE TYPE 'SBT_TAPE' PARMS='SBT_LIBRARY=/oracle/app/oracle/product/19c/lib/libra.so, ENV=(RA_WALLET=location=file:/oracle/app/oracle/wallet credential_alias= zdl_rest)'; 
ALLOCATE CHANNEL T9 DEVICE TYPE 'SBT_TAPE' PARMS='SBT_LIBRARY=/oracle/app/oracle/product/19c/lib/libra.so, ENV=(RA_WALLET=location=file:/oracle/app/oracle/wallet credential_alias= zdl_rest)'; 
ALLOCATE CHANNEL T10 DEVICE TYPE 'SBT_TAPE' PARMS='SBT_LIBRARY=/oracle/app/oracle/product/19c/lib/libra.so, ENV=(RA_WALLET=location=file:/oracle/app/oracle/wallet credential_alias= zdl_rest)'; 
ALLOCATE CHANNEL T11 DEVICE TYPE 'SBT_TAPE' PARMS='SBT_LIBRARY=/oracle/app/oracle/product/19c/lib/libra.so, ENV=(RA_WALLET=location=file:/oracle/app/oracle/wallet credential_alias= zdl_rest)'; 
ALLOCATE CHANNEL T12 DEVICE TYPE 'SBT_TAPE' PARMS='SBT_LIBRARY=/oracle/app/oracle/product/19c/lib/libra.so, ENV=(RA_WALLET=location=file:/oracle/app/oracle/wallet credential_alias= zdl_rest)'; 
ALLOCATE CHANNEL T13 DEVICE TYPE 'SBT_TAPE' PARMS='SBT_LIBRARY=/oracle/app/oracle/product/19c/lib/libra.so, ENV=(RA_WALLET=location=file:/oracle/app/oracle/wallet credential_alias= zdl_rest)'; 
ALLOCATE CHANNEL T14 DEVICE TYPE 'SBT_TAPE' PARMS='SBT_LIBRARY=/oracle/app/oracle/product/19c/lib/libra.so, ENV=(RA_WALLET=location=file:/oracle/app/oracle/wallet credential_alias= zdl_rest)'; 
ALLOCATE CHANNEL T15 DEVICE TYPE 'SBT_TAPE' PARMS='SBT_LIBRARY=/oracle/app/oracle/product/19c/lib/libra.so, ENV=(RA_WALLET=location=file:/oracle/app/oracle/wallet credential_alias= zdl_rest)'; 
ALLOCATE CHANNEL T16 DEVICE TYPE 'SBT_TAPE' PARMS='SBT_LIBRARY=/oracle/app/oracle/product/19c/lib/libra.so, ENV=(RA_WALLET=location=file:/oracle/app/oracle/wallet credential_alias= zdl_rest)'; 
ALLOCATE CHANNEL T17 DEVICE TYPE 'SBT_TAPE' PARMS='SBT_LIBRARY=/oracle/app/oracle/product/19c/lib/libra.so, ENV=(RA_WALLET=location=file:/oracle/app/oracle/wallet credential_alias= zdl_rest)'; 
ALLOCATE CHANNEL T18 DEVICE TYPE 'SBT_TAPE' PARMS='SBT_LIBRARY=/oracle/app/oracle/product/19c/lib/libra.so, ENV=(RA_WALLET=location=file:/oracle/app/oracle/wallet credential_alias= zdl_rest)'; 
ALLOCATE CHANNEL T19 DEVICE TYPE 'SBT_TAPE' PARMS='SBT_LIBRARY=/oracle/app/oracle/product/19c/lib/libra.so, ENV=(RA_WALLET=location=file:/oracle/app/oracle/wallet credential_alias= zdl_rest)'; 
ALLOCATE CHANNEL T20 DEVICE TYPE 'SBT_TAPE' PARMS='SBT_LIBRARY=/oracle/app/oracle/product/19c/lib/libra.so, ENV=(RA_WALLET=location=file:/oracle/app/oracle/wallet credential_alias= zdl_rest)'; 
ALLOCATE CHANNEL T21 DEVICE TYPE 'SBT_TAPE' PARMS='SBT_LIBRARY=/oracle/app/oracle/product/19c/lib/libra.so, ENV=(RA_WALLET=location=file:/oracle/app/oracle/wallet credential_alias= zdl_rest)'; 
ALLOCATE CHANNEL T22 DEVICE TYPE 'SBT_TAPE' PARMS='SBT_LIBRARY=/oracle/app/oracle/product/19c/lib/libra.so, ENV=(RA_WALLET=location=file:/oracle/app/oracle/wallet credential_alias= zdl_rest)'; 
ALLOCATE CHANNEL T23 DEVICE TYPE 'SBT_TAPE' PARMS='SBT_LIBRARY=/oracle/app/oracle/product/19c/lib/libra.so, ENV=(RA_WALLET=location=file:/oracle/app/oracle/wallet credential_alias= zdl_rest)'; 
ALLOCATE CHANNEL T24 DEVICE TYPE 'SBT_TAPE' PARMS='SBT_LIBRARY=/oracle/app/oracle/product/19c/lib/libra.so, ENV=(RA_WALLET=location=file:/oracle/app/oracle/wallet credential_alias= zdl_rest)'; 
ALLOCATE CHANNEL T25 DEVICE TYPE 'SBT_TAPE' PARMS='SBT_LIBRARY=/oracle/app/oracle/product/19c/lib/libra.so, ENV=(RA_WALLET=location=file:/oracle/app/oracle/wallet credential_alias= zdl_rest)'; 
ALLOCATE CHANNEL T26 DEVICE TYPE 'SBT_TAPE' PARMS='SBT_LIBRARY=/oracle/app/oracle/product/19c/lib/libra.so, ENV=(RA_WALLET=location=file:/oracle/app/oracle/wallet credential_alias= zdl_rest)'; 
ALLOCATE CHANNEL T27 DEVICE TYPE 'SBT_TAPE' PARMS='SBT_LIBRARY=/oracle/app/oracle/product/19c/lib/libra.so, ENV=(RA_WALLET=location=file:/oracle/app/oracle/wallet credential_alias= zdl_rest)'; 
ALLOCATE CHANNEL T28 DEVICE TYPE 'SBT_TAPE' PARMS='SBT_LIBRARY=/oracle/app/oracle/product/19c/lib/libra.so, ENV=(RA_WALLET=location=file:/oracle/app/oracle/wallet credential_alias= zdl_rest)'; 
ALLOCATE CHANNEL T29 DEVICE TYPE 'SBT_TAPE' PARMS='SBT_LIBRARY=/oracle/app/oracle/product/19c/lib/libra.so, ENV=(RA_WALLET=location=file:/oracle/app/oracle/wallet credential_alias= zdl_rest)'; 
ALLOCATE CHANNEL T30 DEVICE TYPE 'SBT_TAPE' PARMS='SBT_LIBRARY=/oracle/app/oracle/product/19c/lib/libra.so, ENV=(RA_WALLET=location=file:/oracle/app/oracle/wallet credential_alias= zdl_rest)'; 
ALLOCATE CHANNEL T31 DEVICE TYPE 'SBT_TAPE' PARMS='SBT_LIBRARY=/oracle/app/oracle/product/19c/lib/libra.so, ENV=(RA_WALLET=location=file:/oracle/app/oracle/wallet credential_alias= zdl_rest)'; 
ALLOCATE CHANNEL T32 DEVICE TYPE 'SBT_TAPE' PARMS='SBT_LIBRARY=/oracle/app/oracle/product/19c/lib/libra.so, ENV=(RA_WALLET=location=file:/oracle/app/oracle/wallet credential_alias= zdl_rest)'; 
restore ARCHIVELOG from time 'sysdate -3' until time 'sysdate-1/24';
}
set until time "to_date('01-OCT-2022 21:58:00','DD-MON-YYYY HH24:MI:SS')";
set newname for database to '+DATA';
restore datafile 
================= tuanna duplicate database
rman target sys/mb#123dba@10.1.33.18:1521/T24COB auxiliary sys/mb#123dba@10.1.39.215:1521/T24COB
alter system set cluster_database=false scope=spfile;
duplicate target database to 'T24COB' from active database;
======================= duplicate standby database
cat /u01/app/19.0.0.0/grid/network/admin/listener.ora
LISTENER=(DESCRIPTION=(ADDRESS_LIST=(ADDRESS=(PROTOCOL=IPC)(KEY=LISTENER))))            # line added by Agent

SID_LIST_LISTENER=
  (SID_LIST = 
   (SID_DESC = 
     (GLOBAL_DBNAME=orsexadr)
     (ORACLE_HOME=/u01/app/oracle/product/19c/dbhome_1)
     (SID_NAME=orsexadr1)
   )
  )
  
vi $ORACLE_HOME/network/admin/tnsnames.ora
orsexa =
  (DESCRIPTION =
    (ADDRESS = (PROTOCOL = TCP)(HOST = 10.2.8.36)(PORT = 1521))
    (CONNECT_DATA =
      (SERVER = DEDICATED)
      (SERVICE_NAME = orsexa)
    )
  )

orsexadr =
  (DESCRIPTION =
    (ADDRESS = (PROTOCOL = TCP)(HOST = 10.2.8.195)(PORT = 1521))
    (CONNECT_DATA =
      (SERVER = DEDICATED)
      (SERVICE_NAME = orsexadr)
        (UR = A)
    )
  )
  
vi rmanclone.rcv
connect target sys/mbdba#123@orsexa
connect auxiliary sys/mbdba#123@orsexadr
run {
allocate channel prmy1 type disk;
allocate channel prmy2 type disk;
allocate channel prmy3 type disk;
allocate channel prmy4 type disk;
allocate channel prmy5 type disk;
allocate channel prmy6 type disk;
allocate channel prmy7 type disk;
allocate channel prmy8 type disk;
allocate auxiliary channel stby type disk;
duplicate target database for standby from active database
spfile
parameter_value_convert 'orsexa','orsexadr'  
set db_name='orsexa'	#name nen de chu thuong
set db_unique_name='orsexadr'
set db_file_name_convert= 'DATAHC','DATAC1'
set log_file_name_convert= 'orsexa','orsexadr'
SET db_recovery_file_dest='+DATAC1'
SET db_CREATE_file_dest='+DATAC1'
set control_files='+DATAC1/orsexadr/CONTROLFILE/controlfile1','+RECOC1/orsexadr/CONTROLFILE/controlfile2'
set log_archive_max_processes='5'
set fal_client='orsexadr'
set fal_server='orsexa'
set standby_file_management='AUTO'
set log_archive_config='dg_config=(orsexa,orsexadr,dcqtdl)'
set log_archive_dest_2='service=orsexa ASYNC valid_for=(ONLINE_LOGFILE,PRIMARY_ROLE) db_unique_name=orsexa'
set audit_file_dest='/u01/app/oracle/admin/orsexadr/adump'
set log_archive_dest_1='LOCATION=+RECOC1 VALID_FOR=(ALL_LOGFILES,ALL_ROLES) DB_UNIQUE_NAME=orsexadr'
set instance_number='1'
;
}
vi /home/oracle/run_rman.sh
#!/bin/ksh
export ORACLE_SID=orsexadr1
export ORACLE_BASE=/u01/app/oracle
export ORACLE_HOME=/u01/app/oracle/product/19c/dbhome_1
export BASE_PATH=/usr/sbin:$PATH
export PATH=$PATH:$ORACLE_HOME/bin:$ORACLE_HOME/OPatch
rman cmdfile=/home/oracle/rmanclone.rsv log=/home/oracle/rmanclone.log 
================= restore point =======================
Flashback Logs alone are not sufficient.  The process of FLASHBACK DATABASE does need *some* redo entries from Archive/Online Redo Logs.
--if a guaranteed restore point is created when logging for Flashback Database is disabled, then,
 the first time a datafile block is modified after the time of the guaranteed restore point, an image of the block before the modification is stored in the flashback logs. 
 The flashback logs thus preserve the contents of every changed data block at the time that the guaranteed restore point was created. 
 However, subsequent modifications to the same block do not cause the block contents to be logged again, unless another guaranteed restore point has been created since the block was last modified.
 => vay nen guarantee restore point can it flashbackp log hon Flash back database . Nhung han che la chi restore duoc toi restore point.
CREATE RESTORE POINT b4_remove_duplicate GUARANTEE FLASHBACK DATABASE;
create table b4_030520_1717 as select * from v$database;
SELECT NAME, SCN, TIME, DATABASE_INCARNATION#,
        GUARANTEE_FLASHBACK_DATABASE,STORAGE_SIZE
        FROM V$RESTORE_POINT;
		
select * from V$FLASHBACK_DATABASE_LOG;
select * from V$FLASHBACK_DATABASE_STAT;		
select * from V$FLASHBACK_DATABASE_LOGFILE;
For normal restore points, STORAGE_SIZE is zero. For guaranteed restore points, STORAGE_SIZE indicates the amount of disk space in the fast recovery area used to retain logs required to guarantee FLASHBACK DATABASE to that restore point.
create restore point CLEAN_DB guarantee flashback database;

SELECT substr(name, 1, 30) name,
            space_limit/1024/1024/1024              AS quota,
            space_used/1024/1024/1024               AS used,
            space_reclaimable /1024/1024/1024       AS reclaimable,
            number_of_files          AS files
       FROM V$RECOVERY_FILE_DEST ;
	   
Select file_type, percent_space_used as used,percent_space_reclaimable/1024/1024/1024 as reclaimable,
    number_of_files as "number" from v$recovery_area_usage;	   
---- flashback database
select to_char(OLDEST_FLASHBACK_TIME,'yyyymmdd hh24:mi:ss') from   v$flashback_database_log;
flashback database to timestamp TO_TIMESTAMP( '2022-10-24 22:20:00','YYYY-MM-DD HH24:MI:SS');
2021-02-26 00:10:18
select * from v$restore_point;
shutdown immediate;
startup mount exclusive;
flashback database to restore point B4_DO;
alter database open resetlogs;
-----------------------loi share pool   ORA-04031: unable to allocate bytes of shared memory  ---------------
show parameter sga

select INST_ID,NAME,BYTES/1024/1024 RES ,CON_ID from gv$sgainfo order by inst_id,name;
select INST_ID,pool,sum(bytes)/1024/1024 MB from gv$sgastat group by pool,INST_ID;    ------ khac

select NAME,BYTES/1024/1024 RES ,CON_ID from v$sgainfo order by name;
select pool,sum(bytes)/1024/1024 MB from gv$sgastat group by pool;

-> phuong an la tang SGA, dong thoi tang shared_pool_size len gia tri hien tai:
SELECT MAX(final_size)/1024/1024/1024,component FROM V$SGA_RESIZE_OPS group by component ;
select a.begin_interval_time,a.end_interval_time, b.bytes
from sys.WRM$_SNAPSHOT A, DBA_HIST_SGASTAT B
where a.snap_id = b.snap_id
and b.pool = 'shared pool' and b.name = 'KGH: NO ACCESS'
order by 1;

alter system set sga_max_target=2G scope=spfile;
alter system set sga_target=2G scope=spfile;
alter system set SHARED_POOL_SIZE=2G scope=spfile;

The Shared IO Pool is part of Buffer Cache accordingly to v$sgastat and v$memory_dynamic_components views. v$sga put it also in Database Buffers, not in Variable Size. v$sgainfo show them separated.
The Variable Size of v$sga is the sum of Large Pool, Java Pool, Streams Pool and Shared Pool (not Shared IO Pool). If AMM is enabled, it also includes PGA.
There is very small difference (350 Kbytes is the highest I got) in Variable Size to match it with the pools. I would love to understand why this difference is not exactly zero. If anyone knows please share.
==============check cac component sga ========================
https://support.oracle.com/epmos/faces/SrCreate?_adf.ctrl-state=11zzt1c3b1_4&_afrLoop=250316742525765

select component, current_size/1024/1024 "CURRENT_SIZE", min_size/1024/1024 "MIN_SIZE", user_specified_size/1024/1024 "USER_SPECIFIED_SIZE" from v$sga_dynamic_components;
============== check cac object tren buffer cache =================
set pages 999
set lines 80
 

 
with t1 as (select
   o.object_name    object_name,
   o.object_type    object_type,
   count(1)         num_blocks
from
   dba_objects  o,
   v$bh         bh
where
   o.object_id  = bh.objd
and
   o.owner not in ('SYS','SYSTEM')
group by
   o.object_name,
   o.object_type
order by
   count(1) desc
)
select
   object_name      ,
   object_type      ,
   num_blocks      ,  
   (num_blocks/decode(sum(blocks), 0, .001, sum(blocks)))*100 
from
   t1,
   dba_segments s
where
   s.segment_name = t1.object_name
and
   num_blocks > 10
group by
   object_name,
   object_type,
   num_blocks
order by
   num_blocks desc
;
=======================KEEP cache BUFFER POOL ================================
-- check table need keep cache
select o.owner          owner,o.object_name    object_name,o.subobject_name subobject_name,o.object_type    object_type,
count(distinct file# || block#)         num_block
from
   dba_objects  o,
   v$bh         bh
where
   o.data_object_id  = bh.objd
and
   o.owner not in ('SYS','SYSTEM')
and
   bh.status != 'free'
group by
   o.owner,
   o.object_name,
   o.subobject_name,
   o.object_type
order by
   count(distinct file# || block#) desc;
-- check table size
select bytes/1024/1024 from user_segments where segment_name='&TABLE_NAME';   
--- thuc hien   
alter system set db_keep_cache_size = 8m scope=both;
alter system set db_keep_cache_size = 10320M scope=both sid='cmsprod1';

select component, current_size from v$memory_dynamic_components where component = 'KEEP buffer cache';
alter table hr.departments storage( buffer_pool keep);
-- kiem tra lai 
select buffer_pool from dba_tables where owner = 'HR' and table_name = 'DEPARTMENTS';
select buffer_pool from dba_INDEXES where owner = 'MSB' and INDEX_NAME = 'ENTRY_ITEM';
SELECT * FROM DBA_SEGMENTS S WHERE S.OWNER='MSB' AND S.BUFFER_POOL='KEEP';

select obj.owner, obj.object_name, obj.object_type,
    count(buf.block#) as cached_blocks,
    tab.blocks as total_blocks,
    tab.buffer_pool as Cache
from v$bh buf
inner join dba_objects obj
    on buf.objd = obj.data_object_id
inner join dba_tables tab
    on tab.owner = obj.owner
    and tab.table_name = obj.object_name
    and obj.object_type = 'TABLE'
where buf.class# = 1
and buf.status != 'free'
and obj.owner = 'HR'
and obj.object_type = 'TABLE'
group by obj.owner, obj.object_name, obj.object_type,
    tab.blocks, tab.buffer_pool;
	
-- cach tong quat hon	
select obj.owner, obj.object_name, obj.object_type,
    count(buf.block#) as cached_blocks,
    tab.blocks as total_blocks,
    tab.buffer_pool as Cache
from v$bh buf
inner join dba_objects obj
    on buf.objd = obj.data_object_id
inner join dba_segments tab
    on tab.owner = obj.owner
    and tab.segment_name = obj.object_name
    --and obj.object_type = 'TABLE'
where buf.class# = 1
and buf.status != 'free'
and obj.owner = 'MBW'
and obj.object_name in ('OPT_DOC_HOLD_D','PKY_OPT_DOC_HOLD_D','ACNT_CONTRACT_NUMBER')
group by obj.owner, obj.object_name, obj.object_type,
    tab.blocks, tab.buffer_pool
;
--Name	Owner	Type
OPT_DOC_HOLD_D	MBW	Table
	
++++++++++++++++LIBRARY CACHE HIT RATIO+++++++++++++++++++++++++++++++++++
select trunc(sum(pins-reloads)/sum(pins)*100, 2) "LCHR %" from v$librarycache;

+++++++++++ backup set va backup piece: ktra = list backup; list backupset;  list backup of controlfile ;
Trong rman, 1 backupset co the chua thong tin cua 1  hoac nhieu datafiles hoac archive ...backupset la khai niem logical
Trong 1 backupset co the co 1 hoac nhieu backup piece.Usually, one backup set has only one backup piece.
Mot backup pice chinh la 1 file Rman sinh ra. Khi dung multisecion thi 1 backkupset se bao gom nhieu backup piece 
	RMAN> BACKUP SECTION SIZE 300M TABLESPACE users;  -> neu tbs user co size > 300 thi 1 backupset se gom nhieu backup piece, kich thuoc moi backup pice ko vuot qua 300M
- MAXSETSIZE: Defines the maximum size of a backup set. The default MAXSETSIZE for a database is unlimited. MAXSETSIZE should be at least as large as the largest datafile
- MAXPIECESIZE: Defines the maximum size of a backup piece. The default MAXPIECESIZE is unlimited.
	When it is set to default, your backup set is usually stored in 1 backup piece (if to disk, this means one file per set).
	Neu MAXPIECESIZE duoc set rat nho thi nhieu kha nang 1 backupset se gom nhieu backup piece
- FILESPERSET: Specify the maximum number of files in each backup set. The FILESPERSET default is 64.
	The real number of files in each backup set is the minimum of the FILESPERSET setting and the number of files read by each channel.
- SECTION SIZE: It is useful when you want to enable RMAN channels to back up a single large file in parallel. 
	Neu input datafile > sesssion size thi RMAN divides the work among multiple channels, with each channel backing up one file section in a backup piece. ( sinh ra dong thoi nhieu backup piece trong 1 backupset)
- You cannot specify SECTION SIZE in conjunction with MAXPIECESIZE	
- MAXOPENFILES: This defines the number of files that can be read simultaneously by each channel. The MAXOPENFILES default is 8.

==================== a thinh -- tham so recommend cho db dc-dr ==================
alter system set db_block_checking=FULL scope=both sid='*';
alter system set db_block_checksum=FULL scope=both sid='*';
alter system set db_lost_write_protect=typical scope=both  sid='*';

=== A THINH Proxy User and Connect Through  https://oracle-base.com/articles/misc/proxy-users-and-connect-through
CONN / AS SYSDBA
CREATE USER test_user IDENTIFIED BY T1234_user;

ALTER USER apps GRANT CONNECT THROUGH test_user;
We can now connect to the SCOTT user, using the credentials of the proxy user.

SQL> CONN test_user[apps]/T1234_user
SQL> SHOW USER
USER is "SCOTT"
SQL>
Proxy users can be identified using the PROXY_USERS view.

SELECT * FROM proxy_users;
ALTER USER scott REVOKE CONNECT THROUGH test_user;

-- A Thinh mặc định session cho phép parallel ddl, nhung dml thi khong, phai enable
execute immediate 'alter session enable parallel dml';
ALTER SESSION FORCE PARALLEL DDL PARALLEL 64;
ALTER SESSION FORCE PARALLEL DML PARALLEL 64;
ALTER SESSION FORCE PARALLEL QUERY;

execute immediate 'ALTER SESSION FORCE PARALLEL DML PARALLEL 4';

------------------ truong hop loi khi rman bao ko tim thay backup mac du vua thuc hien xong - co the do broker set true no tu enable he thong standby - a Thinh ocm
list incarnation;  -- sau restore control file thi primary va standby fai giong nhau
reset database to incarnation 2;
backup as compressed backupset spfile include current controlfile format '/backup/ctl_CDB4_%U.bk';		
alter database create standby controlfile as '/backup/ctl_CDB4.bk';

================= check corrupt block ====================
rman verify 
roi check 
SELECT /* Blocks corrupted */ file#,sum(blocks) from V$DATABASE_BLOCK_CORRUPTION group by file# order by file#;

========= xoa trace file ================
export ADR_BASE=/u01/app/oracle
AGE7DAYS=10080
AGE10DAYS=14400
AGE15DAYS=21600
AGE30DAYS=43200
PURGETARGET=$AGE15DAYS
for f in $( adrci exec="show homes" | grep -v "ADR Homes:" );
do
echo "Purging ${f}:";
adrci exec="set home $f; purge -age $PURGETARGET ;" ;
done
----------------------------- backup full rman =======================


sqlplus / as sysdba <<ENDOFSQL
CREATE PFILE='/s05/rman_backupset/ocsg/datafile/spfile_ocsg.bk' FROM  spfile;
exit;
ENDOFSQL
run{
allocate channel ch1 device type disk format '/backup/FTP/FTP_FULL_%U';
allocate channel ch2 device type disk format '/backup/FTP/FTP_FULL_%U';
allocate channel ch3 device type disk format '/backup/FTP/FTP_FULL_%U';
allocate channel ch4 device type disk format '/backup/FTP/FTP_FULL_%U';
allocate channel ch5 device type disk format '/backup/FTP/FTP_FULL_%U';
allocate channel ch6 device type disk format '/backup/FTP/FTP_FULL_%U';

sql 'alter system archive log current';
CROSSCHECK ARCHIVELOG ALL;
backup as compressed backupset database plus archivelog;
BACKUP AS COMPRESSED BACKUPSET CURRENT CONTROLFILE FORMAT '/backup/ctf_CDB4_%T_%d_%s_%p' TAG CTLFILE;

release channel ch1;
release channel ch2;
release channel ch3;
release channel ch4;
release channel ch5;
release channel ch6;
} 
++++++++++++++++++ KIEM TRA RMAN HANG NGAY++++++++++++++++++++++++++++
rman TARGET / CATALOG repos/repos@REPOS 
rman target /
list backup summary;    ++ Xem list file  backup ra
LIST COPY OF DATAFILE '+DATA/orcl/datafile/example.dbf';  
LIST DATAFILECOPY ALL;
---------------------4.4.1.2 Differential Incremental Backups

In a differential level 1 backup, RMAN backs up all blocks that have changed since the most recent cumulative or differental incremental backup, whether at level 1 or level 0. RMAN determines which level 1 backup occurred most recently and backs up all blocks modified after that backup. If no level 1 is available, RMAN copies all blocks changed since the level 0 backup.

The following command performs a level 1 differential incremental backup of the database:

RMAN> BACKUP INCREMENTAL LEVEL 1 DATABASE;

If no level 0 backup is available, then the behavior depends upon the compatibility mode setting. 
If compatibility is >=10.0.0, RMAN copies all blocks changed since the file was created, and stores the results as a level 1 backup. 
In other words, the SCN at the time the incremental backup is taken is the file creation SCN. 
If compatibility <10.0.0, RMAN generates a level 0 backup of the file contents at the time of the backup, to be consistent with the behavior in previous releases.
############# This script will report on all backups – full, incremental and archivelog backups –
col STATUS format a9
col hrs format 999.99
select
SESSION_KEY, INPUT_TYPE, STATUS,
to_char(START_TIME,'mm/dd/yy hh24:mi') start_time,
to_char(END_TIME,'mm/dd/yy hh24:mi')   end_time,
elapsed_seconds/3600                   hrs
from V$RMAN_BACKUP_JOB_DETAILS
order by session_key;
======================Generate an SQL file to create the control file:


ALTER DATABASE BACKUP CONTROLFILE TO TRACE AS '/tmp/create_control.sql'

+++++ SHOW RMAN configuration++++++++++++++++++++++++++++++++++
> show all;
RMAN configuration parameters are:
CONFIGURE RETENTION POLICY TO RECOVERY WINDOW OF 8 DAYS;  + chu ky 8 ngay
CONFIGURE BACKUP OPTIMIZATION ON;
CONFIGURE DEFAULT DEVICE TYPE TO DISK; # default
CONFIGURE CONTROLFILE AUTOBACKUP ON;
CONFIGURE CONTROLFILE AUTOBACKUP FORMAT FOR DEVICE TYPE DISK TO '%F'; # default
CONFIGURE DEVICE TYPE DISK PARALLELISM 4 BACKUP TYPE TO BACKUPSET;
CONFIGURE DATAFILE BACKUP COPIES FOR DEVICE TYPE DISK TO 1; # default
CONFIGURE ARCHIVELOG BACKUP COPIES FOR DEVICE TYPE DISK TO 1; # default
CONFIGURE MAXSETSIZE TO UNLIMITED;
CONFIGURE ENCRYPTION FOR DATABASE OFF; # default
CONFIGURE ENCRYPTION ALGORITHM 'AES128'; # default
CONFIGURE ARCHIVELOG DELETION POLICY TO NONE;
CONFIGURE SNAPSHOT CONTROLFILE NAME TO '/u01/oracle/product/10.2/kmtd4/dbs/snapcf_kmtd4.f'; # default

CONFIGURE CHANNEL DEVICE TYPE DISK FORMAT   '/backup_daily/losprod/losprod_%U';
CONFIGURE SNAPSHOT CONTROLFILE NAME TO '+FRAGRP02/LOSPROD/AUTOBACKUP/snapcf_losprod1.f';
mkdir +FRAGRP02/LOSPROD/AUTOBACKUP/

========fix rman chay lau khi backup control file ================
execute dbms_backup_restore.resetcfilesection(19);
Elapsed: 00:00:00.01

 exec dbms_stats.UNLOCK_TABLE_STATS('SYS','X$KCCRSR');
Elapsed: 00:00:01.60

exec dbms_stats.gather_fixed_objects_stats;
Elapsed: 00:06:50.04

exec dbms_stats.DELETE_TABLE_STATS('SYS','X$KCCRSR');
Elapsed: 00:00:00.25

exec dbms_stats.LOCK_TABLE_STATS('SYS','X$KCCRSR');
Elapsed: 00:00:00.02

exec DBMS_BACKUP_RESTORE.REFRESHAGEDFILES;
Elapsed: 00:00:20.65
+++++++++++++++ check RMAN backup status ++++++++++++++++++++++++++++++++++++++++ 
col STATUS format a9 col hrs format 999.99 
select SESSION_KEY, INPUT_TYPE, STATUS, to_char(START_TIME,'mm/dd/yy hh24:mi') start_time, to_char(END_TIME,'mm/dd/yy hh24:mi')   end_time, elapsed_seconds/3600    hrs from V$RMAN_BACKUP_JOB_DETAILS 
order by session_key; 
++++++++++++ check rman session +++++++++++++++++++++++++ 
select b.sid||','|| b.serial#, a.spid, b.client_info from v$process a, v$session b 
where a.addr=b.paddr and client_info like 'rman%'; 
+++++++++++++++++++check RMAN time & size ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
set linesize 9999
select j.session_recid, j.session_stamp, to_char(j.start_time, 'yyyy-mm-dd hh24:mi:ss') 
start_time, to_char(j.end_time, 'yyyy-mm-dd hh24:mi:ss') end_time, 
(j.output_bytes/1024/1024) output_mbytes, j.status, j.input_type, 
decode(to_char(j.start_time, 'd'), 1, 'Sunday', 2, 'Monday', 3, 'Tuesday', 4, 
'Wednesday', 5, 'Thursday', 6, 'Friday', 7, 'Saturday') dow, j.elapsed_seconds, 
j.time_taken_display from V$RMAN_BACKUP_JOB_DETAILS j left outer join (select 
d.session_recid, d.session_stamp, sum(case when d.controlfile_included = 'YES' 
then d.pieces else 0 end) CF, sum(case when d.controlfile_included = 'NO' and 
d.backup_type||d.incremental_level = 'D' then d.pieces else 0 end) DF, sum(case 
when d.backup_type||d.incremental_level = 'D0' then d.pieces else 0 end) I0, 
sum(case when d.backup_type||d.incremental_level = 'I1' then d.pieces else 0 
end) I1, sum(case when d.backup_type = 'L' then d.pieces else 0 end) L from 
V$BACKUP_SET_DETAILS d join V$BACKUP_SET s on s.set_stamp = d.set_stamp and 
s.set_count = d.set_count where s.input_file_scan_only = 'NO' group by 
d.session_recid, d.session_stamp) x on x.session_recid = j.session_recid and 
x.session_stamp = j.session_stamp left outer join (select o.session_recid, 
o.session_stamp, min(inst_id) inst_id from GV$RMAN_OUTPUT o group by 
o.session_recid, o.session_stamp) ro on ro.session_recid = j.session_recid and 
ro.session_stamp = j.session_stamp where j.start_time > trunc(sysdate)-
&NUMBER_OF_DAYS order by j.start_time;
===================== chungtc check modify need restart or not
select name, issys_modifiable from V$PARAMETER2 where name like '%inmemory%';
Rich1234
==========================================hidden parameter 
SELECT x.ksppinm "Parameter",
       Y.ksppstvl "Session Value",
       Z.ksppstvl "Instance Value"
FROM   x$ksppi X,
       x$ksppcv Y,
       x$ksppsv Z
WHERE  x.indx = Y.indx
AND    x.indx = z.indx
AND    x.ksppinm LIKE '/_%' escape '/'
and x.ksppinm like '_lm_enable_aff_benefit_stats%'
order by x.ksppinm;
_max_spacebg_slaves: default la 1024, recommend dat =10 , dat dynamic. dat xong gather va doi 1,2 ngay  execute dbms_stats.gather_fixed_objects_stats;
_db_fast_obj_ckpt: fai dat la true bug 19.14 https://support.oracle.com/epmos/faces/DocumentDisplay?_afrLoop=335060854863870&parent=SrDetailText&sourceId=3-29787311961&id=2866866.1&_afrWindowMode=0&_adf.ctrl-state=u8r0fgjo_64
_defer_log_boundary_ckpt: is set to true Oracle will allow some log file switches to occur without trying to force a “log switch checkpoint”.
_disable_image_check
_with_subquery  : ORA-12850: Could not allocate slaves on all specified instances  ALTER SYSTEM SET "_with_subquery"=INLINE;  OPTIMIZER
_dlm_stats_collect
_shared_io_pool_size
_sqlmon_max_plan
_sqlmon_max_planlines
_db_link_sources_tracking
_optimizer_use_feedback
_fix_control
_report_capture_cycle_time
alter system set "_max_spacebg_slaves"=10 scope=both sid='*';
alter session  set "_gc_read_mostly_locking"=FALSE scope=spfile sid='*';  --ODS
alter system set "_offline_rollback_segments"="_SYSSMU43_2525192208$" scope=spfile sid='*';


*._b_tree_bitmap_plans=FALSE
*._first_spare_parameter=10
*._gby_hash_aggregation_enabled=FALSE
*._hash_join_enabled=FALSE
*._optim_peek_user_binds=FALSE
*._optimizer_skip_scan_enabled=FALSE
*._optimizer_sortmerge_join_enabled=FALSE

=====================================PGA memory operation tang 2 tham so duoi 
Lien quan toi work area - sort area , khi 1 trong 2 tham so duoi vuot thi se fai su dung toi temp space
_smm_max_size: maximum workarea size for one process
_pga_max_size: maximum PGA size for a single process
 -----------  show parameter standby -----
---------------------------- --------- check database name ---------------------
----------- show parameter standby select sys_context('userenv','db_name') from 
dual; 
------------check mode apply log dataguard----------------------------------------------- 
select * from v$archive_dest_status; 
Async/Sync ( Primary ) ---- thread redo (Primary) ---> RFS (Process) -> standby redo log -> coordinator Process  -> MRP Process
------------mode chung cua dataguard-------------------------------------------- 
SELECT PROTECTION_MODE, PROTECTION_LEVEL, DATABASE_ROLE FROM V$DATABASE; 
----------------------------dataguard query ----------------------------------------------------------------
---- --Kiểm tra tiến trình MRP đang hoạt động như thế nào 
SELECT PROCESS proc, CLIENT_PROCESS cl_proc, THREAD# THR#, SEQUENCE# SEQ#, STATUS, BLOCK#, BLOCKS FROM GV$MANAGED_STANDBY order by PROCESS, thread#, SEQUENCE#;
select inst_id, process, status, thread#, sequence#, block#, blocks from gv$managed_standby where process in ('RFS','LNS','MRP0');
select process, status, thread#, sequence#, block#, blocks from v$managed_standby;

 "--kiem tra dang writting applying sequence nao, nếu sequence trung nhau thi ok
disk

select name, instance_name, open_mode, database_role, flashback_on , current_scn from v$database,v$instance;
--check lag
COLUMN NAME FORMAT A24
COLUMN VALUE FORMAT A16
COLUMN DATUM_TIME FORMAT A24
SELECT NAME, VALUE, DATUM_TIME FROM V$DATAGUARD_STATS;
-- kiem tra last apply log tren 2 db trung nhau la ok
select thread#,max(sequence#) from v$archived_log where applied='YES' group by thread#;

 Data Guard Status Check Queries

1. Issue the following query to show information about the protection mode, the protection level, the role of the database, and switchover status:

                SELECT DATABASE_ROLE, DB_UNIQUE_NAME INSTANCE, OPEN_MODE, PROTECTION_MODE, PROTECTION_LEVEL, SWITCHOVER_STATUS FROM V$DATABASE;

2. On the standby database, query the V$ARCHIVED_LOG view to identify existing files in the archived redo log.

                SELECT SEQUENCE#, FIRST_TIME, NEXT_TIME FROM V$ARCHIVED_LOG ORDER BY SEQUENCE#;

Or

                SELECT THREAD#, MAX(SEQUENCE#) AS "LAST_APPLIED_LOG" FROM V$LOG_HISTORY GROUP BY THREAD#;

3. On the standby database, query the V$ARCHIVED_LOG view to verify the archived redo log files were applied.

                SELECT SEQUENCE#,APPLIED FROM V$ARCHIVED_LOG ORDER BY SEQUENCE#;

4. Query the physical standby database to monitor Redo Apply and redo transport services activity at the standby site.

                SELECT PROCESS, STATUS, THREAD#, SEQUENCE#, BLOCK#, BLOCKS FROM V$MANAGED_STANDBY;

5. To determine if real-time apply is enabled, query the RECOVERY_MODE column of the V$ARCHIVE_DEST_STATUS view.

                SELECT RECOVERY_MODE FROM V$ARCHIVE_DEST_STATUS;

6. The V$DATAGUARD_STATUS fixed view displays events that would typically be triggered by any message to the alert log or server process trace files.

                SELECT MESSAGE FROM V$DATAGUARD_STATUS;

7. Determining Which Log Files Were Not Received by the Standby Site.

                SELECT LOCAL.THREAD#, LOCAL.SEQUENCE# FROM (SELECT THREAD#, SEQUENCE# FROM V$ARCHIVED_LOG WHERE DEST_ID=1) LOCAL WHERE LOCAL.SEQUENCE# NOT IN (SELECT SEQUENCE# FROM V$ARCHIVED_LOG WHERE DEST_ID=2 AND THREAD# = LOCAL.THREAD#);

8.If a delayed apply has been specified or an archive log is missing then switchover may take longer than expected.
Check v$managed_standby

                select process, status, sequence# from v$managed_standby;

OR alternatively:

                select name, applied from v$archived_log;

=================== delete archivelog ben standby
CONFIGURE ARCHIVELOG DELETION POLICY TO APPLIED ON all STANDBY;
dieu kien la archive fai trong FRA
SELECT /* Flash recovery area usage */ * from V$RECOVERY_AREA_USAGE order by 1;
alter system set log_archive_dest_1='location=+DATA' scope=both sid='*'; 
location=USE_DB_RECOVERY_FILE_DEST VALID_FOR=(ALL_LOGFILES,ALL_ROLES) DB_UNIQUE_NAME=orswarm	
-- neu moi truog UAT
CONFIGURE ARCHIVELOG DELETION POLICY TO BACKED UP 0 TIMES TO DISK;
--- neu moi truong primary co thuc hien backup
CONFIGURE ARCHIVELOG DELETION POLICY TO APPLIED ON ALL STANDBY BACKED UP 1 TIMES TO DISK;


alter system archive log current;			
======================== delete archive ====================================================
crosscheck archivelog all;
RMAN> list archivelog all;
RMAN>DELETE ARCHIVELOG ALL COMPLETED BEFORE 'sysdate-2';
DELETE ARCHIVELOG ALL COMPLETED BEFORE  "to_date('20-SEP-2022 19:30:00','DD-MON-YYYY HH24:MI:SS')"

delete archivelog until time 'sysdate-5';
delete force archivelog until time  "to_date('23-SEP-2022 07:00:00','DD-MON-YYYY HH24:MI:SS')";

RMAN>DELETE ARCHIVELOG ALL BACKED UP 1 TIMES to disk;
RMAN>DELETE NOPROMPT ARCHIVELOG UNTIL SEQUENCE = 3790;
Delete Archivelog Backups
The following command can be used to manage the backup of the archive log when storage space needs to be released.
RMAN>DELETE BACKUP OF archivelog UNTIL TIME='sysdate-1';   
delete noprompt archivelog until time 'SYSDATE-1';

RMAN> crosscheck archivelog all;
RMAN> delete noprompt expired archivelog all;
crosscheck backup;
crosscheck archivelog all;
delete noprompt expired backup of database;
delete  noprompt expired backup of archivelog all;
           
==========================cuongtv restore archivelog=======================================================

RMAN> list archivelog sequence 236341 thread 2;
list backup of archivelog sequence 884224 thread 2;
RMAN> restore archivelog sequence 1365836 thread 1;                 
-------------------------cuongtv dataguard-----------------------------------------------------------
alter system set log_archive_dest_2   ='SERVICE=cdbsmdr NOAFFIRM ASYNC VALID_FOR=(ONLINE_LOGFILES,PRIMARY_ROLE) DB_UNIQUE_NAME=cdbsmdr' scope=both sid='*';
	alter system set log_archive_dest_2   ='SERVICE=t24drnew NOAFFIRM ASYNC VALID_FOR=(ALL_LOGFILES,all_roles) DB_UNIQUE_NAME=t24drnew'
ALTER SYSTEM SET log_archive_dest_2='SERVICE=drexaloyal NOAFFIRM ASYNC VALID_FOR=(ONLINE_LOGFILES,PRIMARY_ROLE) COMPRESSION=ENABLE DB_UNIQUE_NAME=DREXALOYAL' SCOPE=BOTH;	
ALTER SYSTEM SET log_archive_dest_3='service=drexacrmdb COMPRESSION=ENABLE ARCH VALID_FOR=(ONLINE_LOGFILES,PRIMARY_ROLE) db_unique_name=drexacrmdb' SCOPE=BOTH;

COLUMN NAME FORMAT A24
COLUMN VALUE FORMAT A16
COLUMN DATUM_TIME FORMAT A24
SELECT NAME, VALUE, DATUM_TIME FROM V$DATAGUARD_STATS;
------- fail over
ALTER DATABASE RECOVER MANAGED STANDBY DATABASE FINISH;
ALTER DATABASE ACTIVATE STANDBY DATABASE;
alter database open;
--shutdown immediate;
--startup;

============failover standby database then convert it back
alter database recover managed standby database cancel;
create restore point before_failover guarantee flashback database;
ALTER DATABASE RECOVER MANAGED STANDBY DATABASE FINISH;  -- doan nay no se recover not tat ca cac archivelog dang co
alter database activate physical standby database;  -- doan nay no se tao lai online redolog, nho tao thu muc truoc trong asm
shutdown immediate;
startup;
select database_role,open_mode from v$database;

shutdown immediate;
startup mount;
select database_role,open_mode from v$database;
flashback database to  restore point before_failover;
select database_role,open_mode from v$database;

alter database convert to physical standby;
select database_role,open_mode from v$database;

DATABASE_ROLE    OPEN_MODE
---------------- --------------------
PHYSICAL STANDBY MOUNTED


shutdown immediate;
startup mount;

ALTER DATABASE RECOVER MANAGED STANDBY DATABASE DISCONNECT FROM SESSION;
----------------------cuongtv ocsg vao rac ------------------------------------------------------
su - oracle
bash-3.2$ cd ~
bash-3.2$ . .profile_rac
sqlplus / as sysdba

------------------FGA
BEGIN
  DBMS_FGA.add_policy(
    object_schema   => 'T24CORE',
    object_name     => 'F_CUSTOMER_EVENT_MB',
    policy_name     => 'CHUNGTC_F_CUSTOMER_EVENT_MB',
    audit_condition => NULL, 
    statement_types => 'DELETE,INSERT,UPDATE,SELECT');
END;
/
select * from ALL_AUDIT_POLICIES;
-- Check the audit trail.
SELECT * FROM dba_fga_audit_trail order by timestamp;
-- Drop the policy.
CONN sys/password@db10g AS SYSDBA
BEGIN
  DBMS_FGA.drop_policy(
    object_schema   => 'T24CORE',
    object_name     => 'F_JOB_LIST_373',
    policy_name     => 'CHUNGTC_F_JOB_LIST_373');
END;
/

==============Script for check all the enabled auditing on Database

--Check the parameter is enabled or disable for Audit
select name || '=' || value PARAMETER from sys.v_$parameter where name like '%audit%';
--Statement Audits Enabled on this Database
column user_name format a10
column audit_option format a40
select * from sys.dba_stmt_audit_opts;
--Privilege Audits Enabled on this Database
select * from dba_priv_audit_opts;
-- Object Audits Enabled on this Database
select (owner ||'.'|| object_name) object_name,
alt, aud, com, del, gra, ind, ins, loc, ren, sel, upd, ref, exe
from dba_obj_audit_opts
where alt != '-/-' or aud != '-/-'
or com != '-/-' or del != '-/-'
or gra != '-/-' or ind != '-/-'
or ins != '-/-' or loc != '-/-'
or ren != '-/-' or sel != '-/-'
or upd != '-/-' or exe != '-/-';

--Default Audits Enabled on this Database
select * from all_def_audit_opts;

====================unified audit from 12c : https://oracledbwr.com/oracle-12c-auditing-tips-and-tricks/
-- check: 
SELECT value FROM v$option WHERE parameter = 'Unified Auditing';
	FALSE – > MIXED AUDTING
	TRUE –> PURE AUDITING
	Pure auditing – Once pure auditing is enabled. We cannot use the traditional auditing methods.
-- xem co nhung option unified nao, nhung option nao duoc enable
select distinct POLICY_NAME from AUDIT_UNIFIED_POLICIES;
select distinct policy_name from AUDIT_UNIFIED_ENABLED_POLICIES;

-- xem unified audit trail
select action_name,SQL_TEXT,UNIFIED_AUDIT_POLICIES ,EVENT_TIMESTAMP from unified_AUDIT_trail where DBUSERNAME='HARI' and EVENT_TIMESTAMP > sysdate -1/24;SQL> SQL> SQL> 

------------------- cuongtv audit----------------------------
DBA_AUDIT_TRAIL - Standard auditing only (from AUD$).
DBA_FGA_AUDIT_TRAIL - Fine-grained auditing only (from FGA_LOG$).
DBA_COMMON_AUDIT_TRAIL - Both standard and fine-grained auditing.

SELECT * FROM dba_stmt_audit_opts;
--disable audit for log-on and log-off
AUDIT ALL by username --- audit DDL
noaudit create session;
NOAUDIT session;
NOAUDIT session BY preston, sebastian;
NOAUDIT DELETE ANY TABLE;
NOAUDIT SELECT TABLE, INSERT TABLE, DELETE TABLE, EXECUTE PROCEDURE;
select * from SYS.FGA_LOG$;
select * from DBA_FGA_AUDIT_TRAIL order by timestamp desc;
select * from DBA_AUDIT_POLICIES;
select * from V$XML_AUDIT_TRAIL where EXTENDED_TIMESTAMP>= trunc(sysdate); --- show xml audit 
select * from dba_common_audit_Trail;
SELECT * FROM DBA_STMT_AUDIT_OPTS;
select * from dba_audit_session;
show parameter AUDIT_TRAIL;

select * from sys.AUD$ ;
select * from dba_audit_trail;
SELECT * FROM dba_stmt_audit_opts;
select * from dba_common_audit_Trail;

SQL>  create tablespace TT35NHNNIDX datafile '+DATA' size 100M autoextend on next 100M maxsize 30G;

Tablespace created.

SQL> 
SQL>  BEGIN
  2  DBMS_AUDIT_MGMT.set_audit_trail_location(
  3  audit_trail_type => DBMS_AUDIT_MGMT.AUDIT_TRAIL_AUD_STD,--this moves table AUD$
  4  audit_trail_location_value => 'AUDITUSER');
  5  END;
  6  /

PL/SQL procedure successfully completed.

SQL> 
SQL>  BEGIN
  2  DBMS_AUDIT_MGMT.set_audit_trail_location(
  3  audit_trail_type => DBMS_AUDIT_MGMT.AUDIT_TRAIL_FGA_STD,--this moves table FGA_LOG$
  4  audit_trail_location_value => 'AUDITUSER');
  5  END;
  6  /

PL/SQL procedure successfully completed.

SQL> SELECT table_name, tablespace_name FROM dba_tables WHERE table_name IN ('AUD$', 'FGA_LOG$') ORDER BY table_name;

TABLE_NAME                     TABLESPACE_NAME
------------------------------ ------------------------------
AUD$                           AUDIT_TBS
FGA_LOG$                       AUDIT_TBS

==================== dai msb clean audit  do select * from x$unified_audit_trail sieu cham==================
SQL> BEGIN
DBMS_AUDIT_MGMT.SET_LAST_ARCHIVE_TIMESTAMP
(audit_trail_type => DBMS_AUDIT_MGMT.AUDIT_TRAIL_UNIFIED,
last_archive_time => TO_TIMESTAMP('09-JUN-2020 06:00:00.0','DD-MON-RRRR HH24:MI:SS.FF'));
END;
/

PL/SQL procedure successfully completed.


BEGIN
DBMS_AUDIT_MGMT.CLEAN_AUDIT_TRAIL(
audit_trail_type => DBMS_AUDIT_MGMT.AUDIT_TRAIL_UNIFIED,
use_last_arch_timestamp => TRUE);
END;
/
----------------- select lob read lob
select sql_id,sql_text,(dbms_lob.substr(sql_text,4000,1)) full_text from dba_hist_sqltext
where sql_id in (select distinct SQL_ID from dba_hist_sql_plan where object_owner not in  ('SYS','SYSTEM','DBSNMP','GGADMIN')
and OPERATION = 'TABLE ACCESS' and OPTIONS = 'FULL');
================ loi permission oracle MSB
cd $ORACLE_HOME/bin
chmod 6751 oracle
-rwsr-s--x 1 oracle asmadmin 324497984 Jul 30  2018 oracle

grid$ ls -l $ORACLE_HOME/bin/oracle
-rwxrwxr-x    1 grid     oinstall  535414729 Jul 03 11:55 /oracle/app/grid/12.1.0.2/bin/oracle
bash-4.3$ chmod 6751 /oracle/app/grid/12.1.0.2/bin/oracle
bash-4.3$ ls -l $ORACLE_HOME/bin/oracle
-rwsr-s--x    1 grid     oinstall  535414729 Jul 03 11:55 /oracle/app/grid/12.1.0.2/bin/oracle
---------------- check partition nambt---------------------
select table_owner,table_name,PARTITION_NAME,partition_position,high_value ,
REGEXP_SUBSTR ( high_value , '[^ ]+' , 1 , 2 ) partition_date 
from 
(
SELECT table_owner,table_name,PARTITION_NAME,partition_position,
                extractvalue
                  ( dbms_xmlgen.getxmltype
                        ( 'select high_value
                           from DBA_TAB_PARTITIONS where table_name = ''' || t.table_name || ''' and PARTITION_NAME = ''' || t.PARTITION_NAME || ''''),
                        '//text()' ) as high_value             
          FROM DBA_TAB_PARTITIONS t
          WHERE table_owner = 'MBANKING' and table_name='TBLMT_LOG'
)                   
;


select partition_name,bytes/1024/1024/1024 from dba_segments
   where
   segment_name in ('GW_IREQUEST')
     order by partition_name

select * from (
WITH xml
     AS (SELECT DBMS_XMLGEN.getxmltype (
                   'select table_owner,table_name,partition_name,tablespace_name, high_value from dba_tab_partitions 
                    where TABLE_OWNER = ''APPS'' AND TABLE_NAME = ''EMB_APIGW_TRANS_LOG_BK'' order by table_name,partition_name')
                   AS x
           FROM DUAL)
SELECT EXTRACTVALUE (rws.object_value, '/ROW/TABLE_OWNER') OWNER,
        EXTRACTVALUE (rws.object_value, '/ROW/TABLE_NAME') table_name,
       EXTRACTVALUE (rws.object_value, '/ROW/PARTITION_NAME') partition,
       EXTRACTVALUE (rws.object_value, '/ROW/HIGH_VALUE') high_value,
	    REGEXP_SUBSTR ( EXTRACTVALUE (rws.object_value, '/ROW/HIGH_VALUE') , '[^ ]+' , 1 , 2 ) partition_date  -- truong hop partition theo interval
  FROM xml x, TABLE (XMLSEQUENCE (EXTRACT (x.x, '/ROWSET/ROW'))) rws
  ORDER BY TABLE_NAME,HIGH_VALUE 
  ) a
  where to_Date(a.partition_date,'yyyy-mm-dd')<=to_date('2020-01-01','YYYY-MM-DD') 
  order by to_Date(a.partition_date,'yyyy-mm-dd') desc
   
select 'alter table '||owner||'.'||table_name||' drop partition '||partition||';' from (
WITH xml
     AS (SELECT DBMS_XMLGEN.getxmltype (
                   'select table_owner,table_name,partition_name,tablespace_name, high_value from dba_tab_partitions 
                    where TABLE_OWNER = ''T24RPT'' AND TABLE_NAME = ''EMB_APIGW_TRANS_LOG'' order by table_name,partition_name')
                   AS x
           FROM DUAL)
SELECT EXTRACTVALUE (rws.object_value, '/ROW/TABLE_OWNER') OWNER,
        EXTRACTVALUE (rws.object_value, '/ROW/TABLE_NAME') table_name,
       EXTRACTVALUE (rws.object_value, '/ROW/PARTITION_NAME') partition,
       EXTRACTVALUE (rws.object_value, '/ROW/HIGH_VALUE') high_value,
	    REGEXP_SUBSTR ( EXTRACTVALUE (rws.object_value, '/ROW/HIGH_VALUE') , '[^ ]+' , 1 , 2 ) partition_date  -- truong hop partition theo interval
  FROM xml x, TABLE (XMLSEQUENCE (EXTRACT (x.x, '/ROWSET/ROW'))) rws
  ORDER BY TABLE_NAME,HIGH_VALUE 
  ) a
  where to_Date(a.partition_date,'yyyy-mm-dd')<=to_date('2018-01-01','YYYY-MM-DD') 
  order by to_Date(a.partition_date,'yyyy-mm-dd') desc;

/* Formatted on 2/3/2020 4:25:35 PM (QP5 v5.252.13127.32867) */
DECLARE
   strHigh_value   VARCHAR2 (4000);
BEGIN
   FOR aRow IN (SELECT PARTITION_NAME, HIGH_VALUE
                  FROM ALL_TAB_PARTITIONS
                 WHERE TABLE_OWNER = 'HR' AND TABLE_NAME = 'TEST')
   LOOP
      IF (aRow.HIGH_VALUE <> 'MAXVALUE')
      THEN
         IF (TO_NUMBER (aRow.HIGH_VALUE) > 2020032)
         THEN
            DBMS_OUTPUT.put_line (aRow.HIGH_VALUE);
         END IF;
      END IF;
   END LOOP;
END;


--------- chungtc subparittion
/* Formatted on 12/15/2021 6:32:38 PM (QP5 v5.287) */
WITH xml
     AS (SELECT DBMS_XMLGEN.getxmltype (
                   'SELECT a.table_owner,a.table_name,a.PARTITION_NAME,b.subpartition_name,a.partition_position,
                a.high_value part_high_value, b.high_value subpart_high_value           
          FROM DBA_TAB_PARTITIONS a
          left join dba_tab_subpartitions b on a.table_name=b.table_name and b.table_owner=a.table_owner and a.partition_name=b.partition_name
          WHERE a.table_owner = ''CHUNGTC'' and a.table_name=''PRODUCT_DETAIL''')
                   AS x
           FROM DUAL)
  SELECT EXTRACTVALUE (rws.object_value, '/ROW/TABLE_OWNER') OWNER,
         EXTRACTVALUE (rws.object_value, '/ROW/TABLE_NAME') table_name,
         EXTRACTVALUE (rws.object_value, '/ROW/PARTITION_NAME') partition_name,
                  EXTRACTVALUE (rws.object_value, '/ROW/SUBPARTITION_NAME') subpartition_name,

         EXTRACTVALUE (rws.object_value, '/ROW/SUBPART_HIGH_VALUE') subpartition_value,
         REGEXP_SUBSTR (EXTRACTVALUE (rws.object_value, '/ROW/PART_HIGH_VALUE'),'[^ ]+',1,2)   partition_Date               -- truong hop partition theo interval
    FROM xml x, TABLE (XMLSEQUENCE (EXTRACT (x.x, '/ROWSET/ROW'))) rws
    where to_date(REGEXP_SUBSTR (EXTRACTVALUE (rws.object_value, '/ROW/PART_HIGH_VALUE'),'[^ ]+',1,2),'yyyy-mm-dd')=to_date('2021-12-07','YYYY-MM-DD') 
    and EXTRACTVALUE (rws.object_value, '/ROW/SUBPART_HIGH_VALUE')='''100'''

		 
--------- CHECK DUNG LUONG TRUNG BINH CUA PARTITION -------------
select
     round( sum(bytes)/(1024*1024*1024)/count(1),2) || 'GB' Value
   from (
   select partition_name,sum(bytes) bytes from
   (select partition_name,bytes from dba_segments
   where
   segment_name in ('CPS_REQUEST')
   and (partition_name >= 'DATA'|| to_char(to_date('01/08/2016','dd/mm/yyyy'),'yyyymmdd')
   and partition_name <= 'DATA'|| to_char(to_date('22/08/2016','dd/mm/yyyy'),'yyyymmdd'))
   union all
   select lob_.partition_name,bytes
   from dba_segments seg,dba_lob_partitions lob_
   where lob_.table_owner='OCSG_OWNER'
   and lob_.table_name in ('CPS_REQUEST')
   and lob_.partition_name >= 'DATA'|| to_char(to_date('01/08/2016','dd/mm/yyyy'),'yyyymmdd')
   and lob_.partition_name <= 'DATA'|| to_char(to_date('22/08/2016','dd/mm/yyyy'),'yyyymmdd')
   and seg.partition_name = lob_.lob_partition_name
   and seg.segment_name = lob_.lob_name)
   group by partition_name
   order by partition_name)
-----------CHECK DUNG LUONG TUNG BANG TABLE SIZE------------------
select owner, segment_type, segment_name, sum(bytes)
from dba_segments
group by owner, segment_type, segment_name;

select
    owner,
    segment_name,
    partition_name,
    segment_type,
    TABLESPACE_NAME,
    bytes / 1024/1024 "MB"
from
    dba_segments
where
    TABLESPACE_NAME in ('DATA')
    order by bytes;   

------
SELECT
   owner, 
   table_name, 
   TRUNC(sum(bytes)/1024/1024) Meg,
   ROUND( ratio_to_report( sum(bytes) ) over () * 100) Percent,
   TABLESPACE_NAME
FROM
(SELECT segment_name table_name, owner, bytes,TABLESPACE_NAME
 FROM dba_segments
 WHERE segment_type IN ('TABLE', 'TABLE PARTITION', 'TABLE SUBPARTITION')
 UNION ALL
 SELECT i.table_name, i.owner, s.bytes,s.TABLESPACE_NAME
 FROM dba_indexes i, dba_segments s
 WHERE s.segment_name = i.index_name
 AND   s.owner = i.owner
 AND   s.segment_type IN ('INDEX', 'INDEX PARTITION', 'INDEX SUBPARTITION')
 UNION ALL
 SELECT l.table_name, l.owner, s.bytes,s.TABLESPACE_NAME
 FROM dba_lobs l, dba_segments s
 WHERE s.segment_name = l.segment_name
 AND   s.owner = l.owner
 AND   s.segment_type IN ('LOBSEGMENT', 'LOB PARTITION')
 UNION ALL
 SELECT l.table_name, l.owner, s.bytes,s.TABLESPACE_NAME
 FROM dba_lobs l, dba_segments s
 WHERE s.segment_name = l.index_name
 AND   s.owner = l.owner
 AND   s.segment_type = 'LOBINDEX')
WHERE owner in UPPER('cps_owner')------------------------------------------------
GROUP BY table_name, owner,TABLESPACE_NAME
HAVING SUM(bytes)/1024/1024 > 10  /* Ignore really small tables */
ORDER BY SUM(bytes) desc
;

-------------------------
SELECT
   owner, 
   table_name, 
   partition_name,---
   TRUNC(sum(bytes)/1024/1024) Meg,
   ROUND( ratio_to_report( sum(bytes) ) over () * 100) Percent,
   TABLESPACE_NAME
FROM
(SELECT segment_name table_name,partition_name, owner, bytes,TABLESPACE_NAME
 FROM dba_segments
 WHERE segment_type IN ('TABLE', 'TABLE PARTITION', 'TABLE SUBPARTITION')
 UNION ALL
 SELECT i.table_name,s.partition_name, i.owner, s.bytes,s.TABLESPACE_NAME
 FROM dba_indexes i, dba_segments s
 WHERE s.segment_name = i.index_name
 AND   s.owner = i.owner
 AND   s.segment_type IN ('INDEX', 'INDEX PARTITION', 'INDEX SUBPARTITION')
 UNION ALL
 SELECT l.table_name,s.partition_name, l.owner, s.bytes,s.TABLESPACE_NAME
 FROM dba_lobs l, dba_segments s
 WHERE s.segment_name = l.segment_name
 AND   s.owner = l.owner
 AND   s.segment_type IN ('LOBSEGMENT', 'LOB PARTITION')
 UNION ALL
 SELECT l.table_name,s.partition_name, l.owner, s.bytes,s.TABLESPACE_NAME
 FROM dba_lobs l, dba_segments s
 WHERE s.segment_name = l.index_name
 AND   s.owner = l.owner
 AND   s.segment_type = 'LOBINDEX')
WHERE owner in UPPER('cps_owner')------------------------------------------------------
GROUP BY table_name,partition_name, owner,TABLESPACE_NAME
HAVING SUM(bytes)/1024/1024 > 10  /* Ignore really small tables */
ORDER BY SUM(bytes) desc
;

=========== OEM
[oracle@monitorapp log]$ pwd
/u01/app/Oracle/gc_inst/em/EMGC_OMS1/sysman/log
[oracle@monitorapp log]$ echo $OMS_HOME
/u01/app/Oracle/MW_13c

======== oem doi contact:
+ doi tren OEM: Targets -> Group -> edit group "chungtc"
+ apply tren app OEM
ssh 10.1.193.204 -> su - oracle
emcli login -user=sysman
emcli set_target_property_value -property_records="chungtc:composite:Department:Phong CSDL&UD - TTVH - Khoi CNTT" -propagate_to_members
emcli set_target_property_value -property_records="chungtc:composite:Lifecycle Status:Production" -propagate_to_members
emcli set_target_property_value -property_records="chungtc:composite:Line of Business:ORACLE_DB" -propagate_to_members
emcli set_target_property_value -property_records="chungtc:composite:Location:Data Center" -propagate_to_members
emcli set_target_property_value -property_records="chungtc:composite:Mobile:84902297333" -propagate_to_members
emcli set_target_property_value -property_records="chungtc:composite:Downtime Contact:Trang Cong Chung - chungtc@mbbank.com.vn - 0902297333" -propagate_to_members
emcli set_target_property_value -property_records="chungtc:composite:Contact:Trang Cong Chung - chungtc@mbbank.com.vn - 0902297333" -propagate_to_members

======================chungtc thu tuc hay =======================================
declare
   type array_t is varray(500) of varchar2(50);
   array array_t := array_t('TR_THLK',
'MB_VN_LICHTRAGOC',
'MB_TR_SOPHU_NEW',
'MB_TR_SOPHU',
'MB_TR_T24_STMT',
'TR_CRB',
'MB_TR_CRF',
'MB_INT_CRF',
'DOC',
'EMB_APIGW_TRANS_LOG',
'TR_TG',
'REP_TOI_FINAL_DAILY',
'MB_TR_CRB_PS',
'DOC_OLD',
'TR_TSTC',
'TR_ACCTGL',
'FTP_TR_TG',
'MB_TR_STMT_DOISOAT',
'BANKPLUS_BP_TRANSACTIONS',
'NHS_CARD_DOC_TRANS_ALL',
'MB_TR_FT',
'COMS_LOG',
'EMB_IND_LOG_ACTV',
'MB_TR_T24_STMT_DETAIL',
'ACNT_CONTRACT_LIEN',
'CRM_TR_HDV_BQ_DAILY_KPI_201804',
'CREDIT_HISTORY',
'TR_TK',
'MB_TR_T24_STMT_BK_TEMP',
'TR_KU',
'TR_KHACHHANG_RM',
'CREDIT_HISTORY_OLD',
'MB_TR_HDV_BQ_DAILY_201804',
'ATM_T24_TRANS_LOG',
'FTP_CAL_MV_TG_CKH',
'TR_THLK_THUE',
'TCBS_GL_DAILY_BAL_TC01_TEMP',
'ACNT_CONTRACT_LIEN',
'MB_CRM_DOANHTHU',
'CRM_TR_PRODUCT_CROSS_CELL',
'DOC',
'PROCESS_MESS',
'REP_THLK_BSPL',
'TR_CRB',
'CRM_RESULT_CORRECT_CROSS_SELL',
'BPM_TBL_RPT_PRO_LDDATA',
'MB_LOAD_CREDIT_CARD_STATEMENT',
'TR_THLK_NSLD',
'TR_THLK',
'MB_MAP_LOAN_CONTRACT',
'PROCESS_MESS_OLD',
'MB_AGG_CRF_NHDT',
'FTP_CAL_BV_TIENVAY',
'ENTRY',
'BPMCORP_TBL_CS_IND_COMMENTS',
'BPMIND_TBL_RPT_SLA_LOANDATA',
'TR_CRB',
'MB_TR_LD_DUNO_LAISUAT',
'CREDIT_HISTORY',
'MB_CARD_XHTD_DATA',
'FTP_TR_KU_DP',
'MB_TR_HDV_BQ_DAILY',
'MB_TR_SAOKE_TINDUNG_LICHTRANO',
'BANKPLUS_U3_ALL_TRANS',
'CRM_TR_HDV_BQ_DAILY_KPI',
'MB_TR_DUTHU_LD',
'CRM_RESULT_CORRECT_X_SELL_HIS',
'MB_SAOKE_VTPAY',
'BPM_TBL_CS_PERFORM_DETAIL',
'ATM_T24_TRANS_LOG',
'MB_TR_TSTC_ORG',
'BPM_TBL_CS_PERF_LDCHILD',
'BPMCORP_TBL_CS_IND_COMTS_HIS',
'MB_TR_SAOKE_LIMIT',
'ENTRY_OLD',
'BPM_TBL_RPT_PRO_COMPOSE',
'REP_TOI_FINAL_MONTH_LK',
'ACNT_CONTRACT_SODU',
'MB_TR_SOPHU',
'TR_TG',
'MB_TR_CHARGE_ENTRY',
'M_TRANSACTION',
'CP_XHTD_DATA_CDC',
'MB_TR_CHOVAY_BQ_DAILY',
'MB_CIC_CRB_M',
'MB_TR_TRALAI_TAIKHOAN',
'DOC_OLD2',
'TR_MD',
'MB_TR_VAYMON_NGOAIBANG',
'BPMCORP_TBL_CS_LDSLADATA',
'MB_TR_KU_DP',
'TR_SK_LD',
'CRM_TR_PRODUCT_CROSS_CELL_HIS',
'BPMCORP_TBL_CS_COLLATERALLOAN',
'NHS_CARD_DOC_TRANS_SUCCESS',
'ORIGINAL_DOC',
'TBLMT_LOG',
'TR_TG',
'ALL_TRANSACTIONS',
'ITEM_OLD',
'GL_TRACE',
'BANKPLUS_U3_ALL_TRANS_BK',
'REP_TOI_FINAL_TT',
'TR_KHACHHANG_RM_BK20190628',
'M_TRANSACTION_OLD',
'REP_CRF_THE',
'ITEM',
'MB_DWH_CUS_ACTIVE',
'EMB_CORP_LOG_ACTV',
'TT35_TR_TG',
'GL_TRACE_OLD',
'BPMCORP_TBL_CS_LDSLADATA_HIST',
'MB_TR_CRB_DUCHI',
'ENTRY',
'PREPAID_CARD_SDBQ',
'MB_TR_FT_KPIS',
'TR_PD',
'MB_TR_SOPHU_GIAINGAN',
'REP_THLK_INTEREST',
'TR_TK',
'SME_KH360_MB_TR_SOPHU',
'MB_AGG_THLK_OPT_DAILY',
'MB_TR_CKH_FTP',
'REP_TOI_FINAL_TT_KH',
'MB_TR_SOPHU_ATM_THANHTOAN',
'FTP_TR_TG_HIS',
'MB_KTNB_SOPHU_BL_CHAM_TEMP',
'MB_TR_CUSTOMER_ACCT_M',
'STATUS_MESSAGE_OLD',
'CAM_TR_MVMT',
'MB_TR_LIMIT_COLLA',
'IN_SK_VTPAY',
'TR_TG_GG',
'MB_TR_SOPHU_2012OLD',
'TCBS_GL_DAILY_BALANCES',
'CPF_CARD_BALANCE_PREPAID',
'USAGE_ACTION_OLD',
'TR_CRB_HOLIDAY_TEMP',
'MB_TR_CREDIT_CARD_DETAILS',
'MB_SOPHU_KIEMTOAN',
'MB_GL_V6_BALANCES',
'CPF_CARD_BALANCE_TAB_V',
'MB_FACT_FT_CTN',
'LOG_ACTV',
'REP_TOI_FINAL',
'TT35_TR_TK',
'MB_STAG_GL_PL',
'TR_TG_M',
'TR_TK',
'MB_TR_T24_STMT_NOW',
'MB_TR_FT_NSLD',
'TCBS_GL_DAILY_BAL_TKTC_TEMP',
'MB_TR_SOPHU_ATM',
'MB_TR_CARD_CREDITS',
'TR_FTP_CUS',
'MB_REP_MVMT_INTEREST_M',
'TR_HDV_BQ',
'MB_TR_CANDOI_MONTH',
'REP_SOPHU_01',
'BANKPLUS_GATEWAY_DATA',
'REP_THLK_CT',
'CPF_CARD_TRN_DETAIL',
'ORIGINAL_DOC_TEMP',
'MB_AGG_NIM_M',
'M_TRANSACTION',
'CPF_TR_TRANS_EBANK',
'MB_TR_CRB_NOW_20170523_TEMP',
'MB_TR_T24_STMT_HIS',
'DOC_CAPTURE',
'GL_TRACE',
'TR_TSTC',
'USAGE_ACTION',
'ACNT_CONTRACT',
'MB_TR_CUS_NHOMNO',
'REP_TOI_FINAL_TT_KH_201904',
'BPM_DVXNK_BCTXKCN',
'MB_KPIS_CUS_PRODUCT_M',
'ORIGINAL_DOC',
'TR_TSTC',
'TT35_TR_NGANQUY_PHATSINH',
'REP_FLEX_BUTTOAN_VM1',
'ACNT_CONTRACT',
'ACNT_CONTRACT_OLD',
'MB_TR_STMT_NOSTRO',
'TDN_STMT_MVMT_NONDUP_TODROP',
'TR_CRB_HIS_09_10',
'FTP_CAL_MV_TG_CKH_HIS',
'MB_TR_KPIS_KIEMNGAN',
'ITEM',
'MB_TR_CHOVAY_FTP',
'MB_TR_CITAD_T24',
'MB_TR_HOADONVAT',
'MB_CITAD_ADVICE',
'AICT_PL65',
'CPF_TR_TRANS_EBANK_HIS',
'REP_THLK_TD',
'CP_SKDT_DATA_CDC',
'MB_TR_SK_ORS_CANDOI',
'CAM_TR_SOPHU',
'TR_TK_GG',
'TR_CRB_HOLIDAY_TEMP',
'BPM_PRESENTED_DOCS_REPORT',
'AICT_PL64_TMP',
'MB_TR_TT',
'MB_TR_THLK_KPIS',
'OPT_DOC_POSTED',
'TR_FTP_CUS_DIEUCHINH',
'INT_ACNT_CONTRACT_LASTDAY',
'BPMCORP_TBL_CS_CP_CR_CHILDATA',
'USAGE_ACTION',
'CPF_TR_TRANS_EMB',
'APPL_ACNT',
'TR_KU',
'FTP_TR_SAOKE_THE',
'MB_TR_PCRT_CTR',
'MB_TR_LINE_BAL',
'EMB_IND_IM_IE_LOGIN_HIST',
'REP_TOI_FINAL_TT_HIS',
'TR_TK_M',
'MB_BC_RUT_TRUOC_HAN_TH',
'MB_EBANKING_IM_IE_LOGIN_HIST',
'REP_QTRR_DHTP_KB1',
'MB_AGG_NIM_DUPHONG_DAILY2',
'CRM_INDIV_RM_RESULT_DAILY',
'CRM_RESUFT_CROSSCELL_DAILY',
'FTP_CAL_BV_TIENVAY_HIS',
'TR_KHACHHANG_ACTIVE_M');
begin
   for i in 1..array.count loop
       dbms_output.put_line(array(i));
       for vds in (
       SELECT segment_name table_name,partition_date, a.owner, bytes/1024/1024/1024 GB,TABLESPACE_NAME
 FROM dba_segments A,
(
WITH xml
     AS (SELECT DBMS_XMLGEN.getxmltype (
                   'select table_owner,table_name,partition_name,tablespace_name, high_value from dba_tab_partitions where table_owner not in (''SYS'',''SYSTEM'')  
                   and table_name in('''||array(i)||''')')
                   AS x
           FROM DUAL)
SELECT EXTRACTVALUE (rws.object_value, '/ROW/TABLE_OWNER') OWNER,
        EXTRACTVALUE (rws.object_value, '/ROW/TABLE_NAME') table_name,
       EXTRACTVALUE (rws.object_value, '/ROW/PARTITION_NAME') partition,
       EXTRACTVALUE (rws.object_value, '/ROW/HIGH_VALUE') high_value,
	    REGEXP_SUBSTR ( EXTRACTVALUE (rws.object_value, '/ROW/HIGH_VALUE') , '[^ ]+' , 1 , 2 ) partition_date  -- truong hop partition theo interval
  FROM xml x, TABLE (XMLSEQUENCE (EXTRACT (x.x, '/ROWSET/ROW'))) rws
  ORDER BY TABLE_NAME,HIGH_VALUE
 ) B
 where A.partition_name=b.partition
 and a.segment_name=b.table_name
 )
 loop
 dbms_output.put_line(vds.table_name||','||vds.partition_date||','||vds.owner||','||vds.GB||','||vds.TABLESPACE_NAME);
 end loop;
   end loop;
end;
===============
--------------- select path datafile  from tablespace--------------------------
select * from dba_data_files where TABLESPACE_NAME='EXAMPLE';
select * from dba_data_files where TABLESPACE_NAME like '%UNDO%';
#add datafile
ALTER TABLESPACE "ORSINDEX" ADD  DATAFILE '+DATANEW/evs/datafile/indx02.dbf' SIZE 8196M
ALTER TABLESPACE   SYSAUX ADD DATAFILE '+DATA' size 1000M; -- cach nay se de oracle tu sinh sequence, filenames...
ALTER TABLESPACE YOUR_TABLESPACE_NAME ADD DATAFILE 'LOCATION_OF_CURRENT_DATAFILES/NEW_DATAFILE.dbf' SIZE 50M AUTOEXTEND ON NEXT 512K MAXSIZE 32767m;
ALTER TABLESPACE ORSINDEX ADD DATAFILE '+FDATA' SIZE 30G AUTOEXTEND ON NEXT 512M MAXSIZE 32767m;
ALTER TABLESPACE AICT_DATA ADD DATAFILE '+DATA' SIZE 32767m AUTOEXTEND ON NEXT 512M MAXSIZE 32767m;
ALTER TABLESPACE FTBS   ADD DATAFILE '+FNEW'   SIZE 32767M   AUTOEXTEND ON   NEXT 1G  MAXSIZE UNLIMITED;
-- check free tablespace
SELECT a.Tablespace_name, (b.Free_space + a.Extend_space)/1024/1024/1024
  FROM (  SELECT COUNT (*) Total_datafile,
                 tablespace_name,
                 ROUND (
                    SUM (DECODE (autoextensible, 'YES', maxbytes - bytes, 0)))
                    Extend_space
            FROM dba_data_files
        GROUP BY tablespace_name) a,
       (  SELECT tablespace_name, ROUND (SUM (bytes)) Free_space
            FROM dba_free_space
        GROUP BY tablespace_name) b
 WHERE     a.tablespace_name = b.tablespace_name
       AND a.tablespace_name NOT IN ('SYSTEM',
                                     'UNDOTBS1',
                                     'UNDOTBS2',
                                     'SYSAUX',
                                     'TEMP',
                                     'USERS')
       AND ( (b.Free_space + a.Extend_space) <
               ( (1024 * 1024 * 10240) + 128 * 1024 * 1024 * a.Total_datafile))
       AND a.tablespace_name IN (SELECT DISTINCT tablespace_name
                                   FROM user_tab_partitions
                                  WHERE UPPER (table_name) =
                                           UPPER ('PC_IREQUEST'));
-- check partition										   
SELECT HIGH_VALUE
  FROM USER_TAB_PARTITIONS TP
 WHERE     PARTITION_POSITION = (SELECT MAX (PARTITION_POSITION)
                                   FROM USER_TAB_PARTITIONS TP1
                                  WHERE TP1.TABLE_NAME = TP.TABLE_NAME)
       AND UPPER (TP.TABLE_NAME) = UPPER ('PC_IREQUEST');		

------------------ hungtn1 check size of table
SELECT
   owner,
   table_name,
   TRUNC(sum(bytes)/1024/1024) Meg,
   ROUND( ratio_to_report( sum(bytes) ) over () * 100) Percent
FROM
(SELECT segment_name table_name, owner, bytes
 FROM dba_segments
 WHERE segment_type IN ('TABLE', 'TABLE PARTITION', 'TABLE SUBPARTITION')
 UNION ALL
 SELECT i.table_name, i.owner, s.bytes
 FROM dba_indexes i, dba_segments s
 WHERE s.segment_name = i.index_name
 AND   s.owner = i.owner
 AND   s.segment_type IN ('INDEX', 'INDEX PARTITION', 'INDEX SUBPARTITION')
 UNION ALL
 SELECT l.table_name, l.owner, s.bytes
 FROM dba_lobs l, dba_segments s
 WHERE s.segment_name = l.segment_name
 AND   s.owner = l.owner
 AND   s.segment_type IN ('LOBSEGMENT', 'LOB PARTITION')
 UNION ALL
 SELECT l.table_name, l.owner, s.bytes
 FROM dba_lobs l, dba_segments s
 WHERE s.segment_name = l.index_name
 AND   s.owner = l.owner
 AND   s.segment_type = 'LOBINDEX')
WHERE owner='T24CORE' and table_name=upper('ACFBNK_STMT022_TAFC ')
GROUP BY table_name, owner
ORDER BY SUM(bytes) desc
;	

with f as(select distinct segment_name from dba_Segments where tablespace_name='EMB_DATA_TBS' and segment_type in ( 'TABLE PARTITION','TABLE'))
SELECT
   owner,
   table_name,
   TRUNC(sum(bytes)/1024/1024) Meg,
   ROUND( ratio_to_report( sum(bytes) ) over () * 100) Percent
FROM
(SELECT segment_name table_name, owner, bytes
 FROM dba_segments
 WHERE segment_type IN ('TABLE', 'TABLE PARTITION', 'TABLE SUBPARTITION')
 and segment_name in ( select * from f)
 UNION ALL
 SELECT i.table_name, i.owner, s.bytes
 FROM dba_indexes i, dba_segments s
 WHERE s.segment_name = i.index_name
 AND   s.owner = i.owner
 AND   s.segment_type IN ('INDEX', 'INDEX PARTITION', 'INDEX SUBPARTITION')
  and segment_name in ( select * from f)
 UNION ALL
 SELECT l.table_name, l.owner, s.bytes
 FROM dba_lobs l, dba_segments s
 WHERE s.segment_name = l.segment_name
 AND   s.owner = l.owner
 AND   s.segment_type IN ('LOBSEGMENT', 'LOB PARTITION')
   and s.segment_name in ( select * from f)

 UNION ALL
 SELECT l.table_name, l.owner, s.bytes
 FROM dba_lobs l, dba_segments s
 WHERE s.segment_name = l.index_name
 AND   s.owner = l.owner
 AND   s.segment_type = 'LOBINDEX'
   and s.segment_name in ( select * from f)
)
--WHERE  table_name in (select distinct segment_name from dba_Segments where tablespace_name='EMB_DATA_TBS' and segment_type in ( 'TABLE PARTITION','TABLE'))
GROUP BY table_name, owner
ORDER BY SUM(bytes) desc
;	      
-------------------Total size DB---------------------------------------
select sum(bytes)/1024/1024/1024 Database_in_MB from dba_data_files;
---------------------allocated DB----------------------------------
select sum(bytes)/1024/1024 Used_space_in_mb from dba_segments;
++++++++++++++++CHECK INDEX  TABLESPACE NAME++++++++++++++++++++++++++++++
== check index co bi partition khong
select PARTITIONED from dba_indexes where index_name='SUB_INFO_DAILY_UNIQUE_IDX1';
== 
select tablespace_name,index_name
from all_indexes
where owner = 'SC_OWNER'
and index_name = 'SUB_INFO_DAILY_UNIQUE_IDX1';
++++++++++++++++++check phan manh INDEX ++++++++++++++++++++++++++++++
analyze index KMTD5.C_NEIF_RELAY_HISTORY_PK validate structure;
select name,del_lf_rows/lf_rows from index_stats;  -->20% thi can rebuild

=================== move lob of table ======================
ALTER TABLE MBANKING.ARC_TBLMT_LOG move lob(original_message) store AS (TABLESPACE ARCHIVING)

==================== allocate extent for lob ===========================
-- lay ra column_name tu cau lenh duoi
select * from dba_lobs where table_name='CHUNGTC';
select * from dba_lob_partitions where table_name='CHUNGTC'; 
-- allocate theo column name, nhung chu y, neu la lob partition thi moi partition no se allocate them tung nay dung luong
ALTER TABLE T24.CHUNGTC MODIFY LOB ("SYS_NC00003$") (ALLOCATE EXTENT ( SIZE 300m));

================== check lob segment size ===============================
/* Formatted on 9/30/2019 11:15:54 AM (QP5 v5.252.13127.32867) */
  SELECT b.owner,
         b.segment_name,
         b.table_name,
         b.tablespace_name,
         b.index_name,
         LOBsizeGB
    FROM (  SELECT OWNER,
                   segment_name,
                   ROUND (SUM (BYTES) / 1024 / 1024 / 1024) LOBsizeGB
              FROM DBA_SEGMENTS
             WHERE SEGMENT_NAME IN (SELECT SEGMENT_NAME
                                      FROM DBA_LOBS
                                     WHERE OWNER IN ('T24CORE') and table_name='ICFBNK_ACCO012')
          GROUP BY OWNER, segment_name) a,
         DBA_LOBS b
   WHERE a.segment_name = b.segment_name
ORDER BY LOBsizeGB DESC;
--FINFADM	764   27/09
  SELECT b.owner,
         b.segment_name,
         b.table_name,
         b.tablespace_name,
         b.index_name,
         LOBsizeGB
    FROM (  SELECT OWNER,
                   segment_name,
                   ROUND (SUM (BYTES) / 1024 / 1024 / 1024) LOBsizeGB
              FROM DBA_SEGMENTS
                       GROUP BY OWNER, segment_name) a,
         DBA_LOBS b
   WHERE a.segment_name = b.segment_name
ORDER BY LOBsizeGB DESC;
---------------- check duoc dung luong su dung that securefile lob-------------1h14p cho 18.4G bang CTAS------------------
set serveroutput on
declare  
    l_segment_name          varchar2(30); 
    l_segment_size_blocks   number; 
    l_segment_size_bytes    number; 
    l_used_blocks           number;  
    l_used_bytes            number;  
    l_expired_blocks        number;  
    l_expired_bytes         number;  
    l_unexpired_blocks      number;  
    l_unexpired_bytes       number;  

begin
    select segment_name 
    into l_segment_name 
    from dba_lobs --dba_lob_partitions
    where table_name = 'REFBNK_RE_S012_TAFC'; 
        dbms_output.put_line('Segment Name=' || l_segment_name); 
    dbms_space.space_usage( 
        segment_owner           => 'T24CORE',  
        segment_name            => l_segment_name, 
        segment_type            => 'LOB', --LOB PARTITION
        partition_name          => NULL, 
        segment_size_blocks     => l_segment_size_blocks, 
        segment_size_bytes      => l_segment_size_bytes, 
        used_blocks             => l_used_blocks, 
        used_bytes              => l_used_bytes, 
        expired_blocks          => l_expired_blocks, 
        expired_bytes           => l_expired_bytes, 
        unexpired_blocks        => l_unexpired_blocks, 
        unexpired_bytes         => l_unexpired_bytes 
    );   
    dbms_output.put_line('segment_size_blocks       => '||  l_segment_size_blocks);
    dbms_output.put_line('segment_size_bytes        => '||  l_segment_size_bytes/1024/1024/1024); 	-- DUNG LUONG CHIEM DUNG TREN DB
    dbms_output.put_line('used_blocks               => '||  l_used_blocks);
    dbms_output.put_line('used_bytes                => '||  l_used_bytes/1024/1024/1024);		-- DUNG LUONG CUA DATA THUC SU
    dbms_output.put_line('expired_blocks            => '||  l_expired_blocks);
    dbms_output.put_line('expired_bytes             => '||  l_expired_bytes/1024/1024/1024);
    dbms_output.put_line('unexpired_blocks          => '||  l_unexpired_blocks);
    dbms_output.put_line('unexpired_bytes           => '||  l_unexpired_bytes/1024/1024/1024);
end;
/
------ check securefile lob partition  select * from dba_lob_partitions where table_name='ACFBNK_ACCT010';
--select * from dba_segments where segment_name='SYS_LOB0006831104C00002$$';
set serveroutput on
declare  
    l_segment_name          varchar2(30); 
    l_segment_size_blocks   number; 
    l_segment_size_bytes    number; 
    l_used_blocks           number;  
    l_used_bytes            number;  
    l_expired_blocks        number;  
    l_expired_bytes         number;  
    l_unexpired_blocks      number;  
    l_unexpired_bytes       number;  

begin
    select distinct lob_name 
    into l_segment_name 
    from dba_lob_partitions
    where table_name = 'ACFBNK_ACCT010'; 
        dbms_output.put_line('Segment Name=' || l_segment_name);
 
    dbms_space.space_usage( 
        segment_owner           => 'T24CORE',  
        segment_name            => l_segment_name, 
        segment_type            => 'LOB PARTITION', --LOB PARTITION
        partition_name          => 'SYS_LOB_P251932', 
        segment_size_blocks     => l_segment_size_blocks, 
        segment_size_bytes      => l_segment_size_bytes, 
        used_blocks             => l_used_blocks, 
        used_bytes              => l_used_bytes, 
        expired_blocks          => l_expired_blocks, 
        expired_bytes           => l_expired_bytes, 
        unexpired_blocks        => l_unexpired_blocks, 
        unexpired_bytes         => l_unexpired_bytes 
    );   
    dbms_output.put_line('segment_size_blocks       => '||  l_segment_size_blocks);
    dbms_output.put_line('segment_size_bytes        => '||  l_segment_size_bytes/1024/1024/1024); 	-- DUNG LUONG CHIEM DUNG TREN DB
    dbms_output.put_line('used_blocks               => '||  l_used_blocks);
    dbms_output.put_line('used_Gbytes                => '||  l_used_bytes/1024/1024/1024);		-- DUNG LUONG CUA DATA THUC SU
    dbms_output.put_line('expired_blocks            => '||  l_expired_blocks);
    dbms_output.put_line('expired_Gbytes             => '||  l_expired_bytes/1024/1024/1024);
    dbms_output.put_line('unexpired_blocks          => '||  l_unexpired_blocks);
    dbms_output.put_line('unexpired_Gbytes           => '||  l_unexpired_bytes/1024/1024/1024);
end;
/


set serveroutput on
declare  
    l_total_blocks   number; 
    l_total_bytes    number; 
    l_unused_blocks           number;  
    l_LastUsedExtFileId            number;  
    l_unused_bytes        number;  
    l_LastUsedExtBlockId      number;  
    l_LAST_USED_BLOCK       number;  

begin
     dbms_space.unused_space
( segment_owner => 'T24CORE',
segment_name => 'SYS_LOB0006831104C00002$$',
segment_type => 'LOB PARTITION',
partition_name => 'SYS_LOB_P251932',
total_blocks => l_total_blocks,
total_bytes => l_total_bytes,
unused_blocks => l_unused_blocks,
unused_bytes => l_unused_bytes,
LAST_USED_EXTENT_FILE_ID => l_LastUsedExtFileId,
LAST_USED_EXTENT_BLOCK_ID => l_LastUsedExtBlockId,
LAST_USED_BLOCK => l_LAST_USED_BLOCK );
 
    dbms_output.put_line('total_blocks       => '||  l_total_blocks);
    dbms_output.put_line('l_total_Gbytes        => '||  l_total_bytes/1024/1024/1024); 	-- DUNG LUONG CHIEM DUNG TREN DB
    dbms_output.put_line('l_unused_blocks                => '||  l_unused_blocks/1024/1024/1024);		-- DUNG LUONG CUA DATA THUC SU
    dbms_output.put_line('l_unused_Gbytes             => '||  l_unused_bytes/1024/1024/1024);
    dbms_output.put_line('l_LastUsedExtFileId          => '||  l_LastUsedExtFileId);
    dbms_output.put_line('l_LastUsedExtBlockId          => '||  l_LastUsedExtBlockId);
        dbms_output.put_line('l_LAST_USED_BLOCK          => '||  l_LAST_USED_BLOCK);

end;
/
-------------------RECREATE TEMP TABLESPACE-----------------
Find the existing temp tablespace details
	   select tablespace_name,file_name from dba_temp_files
Create another Temporary Tablespace TEMP1
	CREATE TEMPORARY TABLESPACE TEMP2 TEMPFILE '+DATAHC' SIZE 500M;
Move Default Database temp tablespace
	ALTER DATABASE DEFAULT TEMPORARY TABLESPACE TEMP2;
If any sessions are using temp space, then kill them.
	SELECT b.tablespace,b.segfile#,b.segblk#,b.blocks,a.sid,a.serial#,
	a.username,a.osuser, a.status
	FROM v$session a,v$sort_usage b
	WHERE a.saddr = b.session_addr;
	 
	ALTER SYSTEM KILL session '15,62680' IMMEDIATE; 
Drop the original temp tablespace.
Drop temp tablespace	
	DROP TABLESPACE temp INCLUDING CONTENTS AND DATAFILES;
================ check sql_id using temp ===================
COLUMN module format A20
COLUMN sql_opname format A20
COLUMN etime_secs FORMAT 999,999.9
COLUMN etime_mins FORMAT 999,999.9
COLUMN user_id FORMAT 999999
COLUMN sid FORMAT 99999
COLUMN serial# FORMAT 99999
COLUMN username FORMAT A25
COLUMN inst_id FORMAT 99
COLUMN sql_opname FORMAT A10
COLUMN sql_id FORMAT A13
COLUMN sql_exec_id FORMAT 9999999999
COLUMN max_temp_mb FORMAT 999,999,999
COLUMN sql_start_time FORMAT A21
COLUMN sql_end_time FORMAT A21 
SELECT ASH.inst_id,
  ASH.user_id,
  ASH.session_id sid,
  ASH.session_serial# serial#,
  ASH.sql_id,
  ASH.sql_exec_id,
  ASH.sql_opname,
  ASH.module,
  MIN(sample_time) sql_start_time,
  MAX(sample_time) sql_end_time,
  ((CAST(MAX(sample_time) AS DATE)) - (CAST(MIN(sample_time) AS DATE))) * (3600*24) etime_secs ,
  ((CAST(MAX(sample_time) AS DATE)) - (CAST(MIN(sample_time) AS DATE))) * (60*24) etime_mins ,
  MAX(temp_space_allocated)/(1024*1024) max_temp_mb
FROM gv$active_session_history ASH
WHERE ASH.session_type = 'FOREGROUND'
AND ASH.sql_id        IS NOT NULL
AND sample_time BETWEEN to_timestamp('24-08-2019 00:00', 'DD-MM-YYYY HH24:MI') AND to_timestamp('24-08-2019 22:00', 'DD-MM-YYYY HH24:MI')
GROUP BY ASH.inst_id,
  ASH.user_id,
  ASH.session_id,
  ASH.session_serial#,
  ASH.sql_id,
  ASH.sql_opname,
  ASH.sql_exec_id,
  ASH.module
HAVING MAX(temp_space_allocated) > 0
order by max_temp_mb desc


select sql_id,max(TEMP_SPACE_ALLOCATED)/(1024*1024*1024) gig 
from DBA_HIST_ACTIVE_SESS_HISTORY 
where 
sample_time > sysdate-2 and 
TEMP_SPACE_ALLOCATED > (50*1024*1024*1024) 
group by sql_id order by sql_id;
----- check temp usage history
column sum_max_mb format 999,999,999;
column temporary_tablespace format A20
WITH
pivot1 AS
(
SELECT
trunc(ash.sample_time,'MI') sample_time,
ash.SESSION_ID,
ash.SESSION_SERIAL#,
ash.SQL_ID,
ash.sql_exec_id,
U.temporary_tablespace,
max(temp_space_allocated)/(1024*1024) max_temp_mb
FROM  GV$ACTIVE_SESSION_HISTORY ash, dba_users U
WHERE
ash.user_id = U.user_id
and ash.session_type = 'FOREGROUND'
and ash.temp_space_allocated>  0
GROUP BY
trunc(ash.sample_time,'MI'),
ash.SESSION_ID,
ash.SESSION_SERIAL#,
ash.SQL_ID,
ash.sql_exec_id,
U.temporary_tablespace
)
SELECT  temporary_tablespace, sample_time, sum(max_temp_mb) sum_max_mb
from pivot1
GROUP BY sample_time, temporary_tablespace
ORDER BY sum_max_mb desc;

----------------------------- temp usage
select
   username,
   blocks*(8192)/(1024*1024) mb
from
   v$tempseg_usage;
   
   
set pagesize 60 linesize 132 verify off
break on file_id skip 1

column file_id heading "File|Id"
column tablespace_name for a15
column object          for a15
column owner           for a15
column MBytes          for 999,999

select tablespace_name,
'free space' owner, /*"owner" of free space */
' ' object,         /*blank object name */
file_id, /*file id for the extent header*/
block_id, /*block id for the extent header*/
CEIL(blocks*4/1024) MBytes /*length of the extent, in Mega Bytes*/
from dba_free_space
where tablespace_name like '%TEMP%'
union
select tablespace_name,
substr(owner, 1, 20), /*owner name (first 20 chars)*/
substr(segment_name, 1, 32), /*segment name */
file_id, /*file id for extent header */
block_id, /*block id for extent header */
CEIL(blocks*4/1024) MBytes /*length of the extent, in Mega Bytes*/
from dba_extents
where tablespace_name like '%TEMP%'
order by 1, 4, 5
/ 


SELECT   S.sid || ',' || S.serial# sid_serial, S.username,T.blocks * TBS.block_size / 1024 / 1024 mb_used, T.tablespace,
T.sqladdr address, Q.hash_value, Q.sql_text
FROM     v$sort_usage T, v$session S, v$sqlarea Q, dba_tablespaces TBS
WHERE    T.session_addr = S.saddr
AND      T.sqladdr = Q.address
AND      T.tablespace = TBS.tablespace_name
ORDER BY S.sid;

--------------CHECK TEMPORARY TABLESPACE SIZE -------------
select a.tablespace_name tablespace,
'`', d.total_mb,
'`', sum(a.used_blocks * d.block_size) / 1024 / 1024 used_mb,
'`', d.total_mb - sum(a.used_blocks * d.block_size) / 1024 / 1024 free_mb,
'`', round((sum(a.used_blocks * d.block_size) / 1024 / 1024) / D.total_mb * 100, 2) "Used%",
'`', round((d.total_mb - sum(a.used_blocks * d.block_size) / 1024 / 1024) / D.total_mb * 100, 2) "Free%",'`'
  from v$sort_segment a,
       (SELECT B.name, C.block_size, SUM(C.bytes) / 1024 / 1024 total_mb
          FROM v$tablespace B, v$tempfile C
         WHERE B.ts# = C.ts#
         group by B.name, C.block_size) D
where a.tablespace_name = d.name
group by a.tablespace_name, d.total_mb;

 select tablespace_name,
(free_blocks*8)/1024/1024 FreeSpaceGB,
(used_blocks*8)/1024/1024 UsedSpaceGB,
(total_blocks*8)/1024/1024 TotalSpaceGB,
i.instance_name,i.host_name
from gv$sort_segment ss,gv$instance i where ss.tablespace_name in (select tablespace_name from dba_tablespaces where contents='TEMPORARY') and
i.inst_id=ss.inst_id;

==================== chungtc check tablespace size change =======================
select f1.snap_id,
       f1.sumts,f2.sumts2,((f1.sumts-f2.sumts2)*8)/1024/1024 diff
  from (select d1.snap_id, sum(tablespace_size) sumts
          from dba_hist_tbspc_space_usage d1, v$tablespace v1
         where d1.tablespace_id = v1.TS#
           and rtime >= '06/16/2020'
           and rtime < '06/18/2020'
         group by d1.snap_id) f1 ,       (select snap_id,sum(tablespace_size) sumts2
          from dba_hist_tbspc_space_usage d1
         group by d1.snap_id) f2   
where f2.snap_id=f1.snap_id-1;

=================== chungtc statistic of read write process ===================
select d3.sample_id,
       d3.sample_time,
       d3.session_type,
       d5.USERNAME,
       d3.session_id,
       d3.session_serial#,
       d3.sql_opname,
       d3.sql_id,
       d3.event,
       d3.module,
       d3.action,
       d3.delta_read_io_requests,
       d3.delta_write_io_requests,
       d3.delta_read_io_bytes,
       d3.delta_write_io_bytes,
       d4.sql_text
  from dba_hist_active_sess_history d3, dba_hist_sqltext d4, dba_users d5
 where d3.sample_time >=
       to_date('22/06/2014 05:00:00', 'dd/mm/yyyy hh24:mi:ss')
   and d3.sample_time <
       to_date('22/06/2014 06:00:00', 'dd/mm/yyyy hh24:mi:ss')
   and d3.sql_id = d4.sql_id(+)
   and d3.user_id = d5.USER_ID(+)
 order by d3.sample_id
============= get last partition ============================
/* Formatted on 9/20/2019 8:01:20 AM (QP5 v5.252.13127.32867) */
SELECT HIGH_VALUE
  FROM USER_TAB_PARTITIONS TP
 WHERE     PARTITION_POSITION = (SELECT MAX (PARTITION_POSITION)
                                   FROM USER_TAB_PARTITIONS TP1
                                  WHERE TP1.TABLE_NAME = TP.TABLE_NAME)
       AND UPPER (TP.TABLE_NAME) = UPPER ('PC_IREQUEST');
=========================== Daily growth of a tablespace in oracle database =========================	
SELECT b.tsname tablespace_name
, MAX(b.used_size_mb) cur_used_size_mb
, round(AVG(inc_used_size_mb),2)avg_increas_mb
FROM (
  SELECT a.days, a.tsname, used_size_mb
  , used_size_mb - LAG (used_size_mb,1)  OVER ( PARTITION BY a.tsname ORDER BY a.tsname,a.days) inc_used_size_mb
  FROM (
      SELECT TO_CHAR(sp.begin_interval_time,'MM-DD-YYYY') days
       ,ts.tsname
       ,MAX(round((tsu.tablespace_usedsize* dt.block_size )/(1024*1024),2)) used_size_mb
      FROM DBA_HIST_TBSPC_SPACE_USAGE tsu, DBA_HIST_TABLESPACE_STAT ts
       ,DBA_HIST_SNAPSHOT sp, DBA_TABLESPACES dt
      WHERE tsu.tablespace_id= ts.ts# AND tsu.snap_id = sp.snap_id
       AND ts.tsname = dt.tablespace_name  AND sp.begin_interval_time > sysdate-7
      GROUP BY TO_CHAR(sp.begin_interval_time,'MM-DD-YYYY'), ts.tsname
      ORDER BY ts.tsname, days
  ) A
) b GROUP BY b.tsname ORDER BY b.tsname;
   
   
+++++++++++++++++ check tablespace CDB ++++++++++++++++++++++++++++
set line 200 pages 999
column name for a10
column tablespace_name for a15
column "MAXSIZE (MB)" format 9,999,990.00
column "ALLOC (MB)" format 9,999,990.00
column "USED (MB)" format 9,999,990.00
select a.con_id,c.name,b.tablespace_name,a.bytes_alloc/(1024*1024) "MAXSIZE (MB)",nvl(a.physical_bytes,0)/(1024*1024) "ALLOC (MB)" ,nvl(b.tot_used,0)/(1024*1024) "USED (MB)"
from
(select con_id,tablespace_name, sum(bytes) physical_bytes,sum(decode(autoextensible,'NO',bytes,'YES',maxbytes)) bytes_alloc
from cdb_data_files group by con_id,tablespace_name ) a,
(select con_id,tablespace_name, sum(bytes) tot_used from cdb_segments group by con_id,tablespace_name ) b,
(select name,con_id from v$containers) c
where a.con_id= b.con_id and a.con_id = c.con_id and a.tablespace_name = b.tablespace_name (+)
order by 1,3;
+++++++++++ CHECK TABLESPACE++++++++++++++++++++++++++++++++++++++++++
/* Formatted on 9/20/2019 7:57:28 AM (QP5 v5.252.13127.32867) */
/* Formatted on 9/20/2019 7:57:28 AM (QP5 v5.252.13127.32867) */
SELECT a.Tablespace_name, (b.Free_space + a.Extend_space)
  FROM (  SELECT COUNT (*) Total_datafile,
                 tablespace_name,
                 ROUND (
                    SUM (DECODE (autoextensible, 'YES', maxbytes - bytes, 0)))
                    Extend_space
            FROM dba_data_files
        GROUP BY tablespace_name) a,
       (  SELECT tablespace_name, ROUND (SUM (bytes)) Free_space
            FROM dba_free_space
        GROUP BY tablespace_name) b
 WHERE     a.tablespace_name = b.tablespace_name
       AND a.tablespace_name NOT IN ('SYSTEM',
                                     'UNDOTBS1',
                                     'UNDOTBS2',
                                     'SYSAUX',
                                     'TEMP',
                                     'USERS')
       AND ( (b.Free_space + a.Extend_space) <
               ( (1024 * 1024 * 10240) + 128 * 1024 * 1024 * a.Total_datafile));
==========================
SELECT a.Tablespace_name tbsname, (b.Free_space + a.Extend_space)/1024/1024/1024 , tbs_Size/1024/1024/1024
  FROM (  SELECT COUNT (*) Total_datafile,
                 tablespace_name,
                 ROUND (
                    SUM (DECODE (autoextensible, 'YES', maxbytes - bytes, 0)))
                    Extend_space,
                    sum(bytes) tbs_Size
            FROM dba_data_files
        GROUP BY tablespace_name) a,
       (  SELECT tablespace_name, ROUND (SUM (bytes)) Free_space
            FROM dba_free_space
        GROUP BY tablespace_name) b
 WHERE     a.tablespace_name = b.tablespace_name
       AND a.tablespace_name  IN ('AICT_DATA',
                                     'DATAFAST',
                                     'ETL',
                                     'INDEXFAST',
                                     'INDEXS',
                                     'ORSINDEX',
                                     'INTERFACES2',
                                     'ORSDATA',
                                     'TBS_T24RPT',
                                     'TCBS_DATA',
                                     'W4RPT',
                                     'NHS',
                                     'WAY4SYNC','WAY4SYNCIDX',
                                     'NSLD','DOISOAT','CITAD','T24RPTIDX')
       AND ( (b.Free_space + a.Extend_space) <
               ( (1024 * 1024 * 30240) + 128 * 1024 * 1024 * a.Total_datafile))
       and (b.Free_space + a.Extend_space)/tbs_Size<0.5
               ;
               

			   
										   
select b.tablespace_name, tbs_size SizeMb, a.free_space FreeMb
from
(select tablespace_name, round(sum(bytes)/1024/1024 ,2) as free_space
from dba_free_space group by tablespace_name) a,
(select tablespace_name, sum(bytes)/1024/1024 as tbs_size
from dba_data_files group by tablespace_name
UNION
select tablespace_name, sum(bytes)/1024/1024 tbs_size
from dba_temp_files
group by tablespace_name ) b
where a.tablespace_name(+)=b.tablespace_name;

select	a.TABLESPACE_NAME,
	a.BYTES mbytes_total,
	b.BYTES mbytes_free,
	b.largest,
	round(((a.BYTES-b.BYTES)/a.BYTES)*100,2) percent_used,
	round(a.BYTES+b.BYTES) total
from 	
	(
		select 	TABLESPACE_NAME,
			sum(BYTES)/1024/1024 BYTES 
		from 	dba_data_files 
		group 	by TABLESPACE_NAME
	)
	a,
	(
		select 	TABLESPACE_NAME,
			sum(BYTES)/1024/1024 BYTES ,
			max(BYTES)/1024/1024 largest 
		from 	dba_free_space 
		group 	by TABLESPACE_NAME
	)
	b
where 	a.TABLESPACE_NAME=b.TABLESPACE_NAME
order 	by ((a.BYTES-b.BYTES)/a.BYTES) desc;


		
            SELECT   tablespace_name,
                     used || ' MB' used,
                     free || ' MB' free,
                     pct_used || '#' pct_used,
                     total || ' MB' total,
                     status 
              FROM   (  SELECT   a.tablespace_name,
                                 ROUND ( ( (c.bytes - NVL (b.bytes, 0)) / c.bytes) * 100,
                                        2)
                                     pct_used,
                                 ROUND (c.bytes / 1024 / 1024 , 2) total,
                                 ROUND (
                                     c.bytes / 1024 / 1024 
                                     - NVL (b.bytes, 0) / 1024 / 1024 ,
                                     2)
                                     used,
                                 ROUND (NVL (b.bytes, 0) / 1024 / 1024 , 2) free,
                                 c.datafiles,
                                 a.status
                          FROM   dba_tablespaces a,
                                 (  SELECT   tablespace_name, SUM (bytes) bytes
                                      FROM   dba_free_space
                                  GROUP BY   tablespace_name) b,
                                 (  SELECT   COUNT (1) datafiles,
                                             SUM (bytes) bytes,
                                             tablespace_name
                                      FROM   dba_data_files
                                  GROUP BY   tablespace_name) c
                         WHERE   b.tablespace_name(+) = a.tablespace_name
                                 AND c.tablespace_name(+) = a.tablespace_name
                      ORDER BY   tablespace_name 
                      )
-- list all tablespaces with their associated files, the 
-- tablespace's allocated space, free space, and the 
-- next free extent:
 rich1234
clear breaks
SET linesize 130
SET pagesize 60
break ON tablespace_name skip 1
col tablespace_name format a15
col file_name format a50
col tablespace_kb heading 'TABLESPACE|TOTAL KB'
col kbytes_free heading 'TOTAL FREE|KBYTES'
 
SELECT dd.tablespace_name tablespace_name, dd.file_name file_name, dd.bytes/1024 TABLESPACE_KB, SUM(fs.bytes)/1024 KBYTES_FREE, MAX(fs.bytes)/1024 NEXT_FREE
FROM sys.dba_free_space fs, sys.dba_data_files dd
WHERE dd.tablespace_name = fs.tablespace_name
AND dd.file_id = fs.file_id
GROUP BY dd.tablespace_name, dd.file_name, dd.bytes/1024
ORDER BY dd.tablespace_name, dd.file_name;
==========tfa================
https://support.oracle.com/epmos/faces/DocumentDisplay?_afrLoop=291866047784965&parent=EXTERNAL_SEARCH&sourceId=HOWTO&id=2687715.1&_afrWindowMode=0&_adf.ctrl-state=wz5ky4h2o_4
oracle@tfactl diagcollect -srdc dbracperf -database T24VN -from "2022-04-28 16:00:00" -to "2022-04-28 17:00:00"
/opt/oracle.ahf/tfa/bin/tfactl.tfa diagcollect -srdc ORA-00600 
/opt/oracle.ahf/tfa/bin/tfactl.tfa print status
/opt/oracle.ahf/tfa/bin/tfactl.tfa print config
/opt/oracle.ahf/tfa/bin/tfactl.tfa start 
/opt/oracle.ahf/tfa/bin/tfactl.tfa stop

tfactl diagcollect –srdc <srdc_profile>
$TFA_HOME/bin/tfactl diagcollect -srdc ora600
tfactl diagcollect -srdc dbperf 
 tfactl diagcollect -srdc dbsqlperf
tfactl diagnosetfa -local
===================== oratop ==================================
tfactl toolstatus
Development Tools | orachk | 20.2.0.0.0 | DEPLOYED |
| | oratop | 14.1.2 | DEPLOYED |. - >>> ORATOP IS AVAIABLE.

tfactl oratop -help
tfactl oratop -database t24vn
tfactl oratop -database PROD1
/opt/oracle.ahf/tfa/bin/tfactl.pl oratop -database t24cob -rsf
================ redact =============================
grant exempt redaction policy to TrangDH ;

-- loi ORA-28094: SQL CONSTRUCT NOT SUPPORTED BY DATA REDACT
_strict_redaction_semantics=false;


------ view redact policy
SELECT object_owner,
       object_name,
       policy_name,
       expression,
       enable,
       policy_description
FROM   redaction_policies
ORDER BY 1, 2, 3;

SET LINESIZE 300 VERIFY OFF


SELECT object_owner,
       object_name,
       column_name,
       function_type,
       function_parameters,
       regexp_pattern,
       regexp_replace_string,
       regexp_position,
       regexp_occurrence,
       regexp_match_parameter,
       column_description
FROM   redaction_columns
WHERE  object_owner = DECODE(UPPER('MBK'), 'ALL', object_owner, UPPER('MBK'))
AND    object_name  = DECODE(UPPER('ACNT_CONTRACT'), 'ALL', object_name, UPPER('ACNT_CONTRACT'))
ORDER BY 1, 2, 3;

--------- add table to policy
BEGIN
  SYS.DBMS_REDACT.ADD_POLICY (
    object_schema      => 'MBK',
    object_name        => 'DOC',
    policy_name        => 'REDACT_MBK_01',
    expression         => '1=1',
    policy_description => '',
    enable             => TRUE);

  SYS.DBMS_REDACT.ALTER_POLICY (
    object_schema          => 'MBK',
    action                 => SYS.DBMS_REDACT.ADD_COLUMN,
    object_name            => 'DOC',
    policy_name            => 'REDACT_MBK_01',
    column_name            => 'TARGET_NUMBER',
    function_type          => SYS.DBMS_REDACT.PARTIAL,
    function_parameters    => 'VVVVVVVVVVVVVVVV,VVVVVVVVVVVVVVVV,X,7,12');

  SYS.DBMS_REDACT.ALTER_POLICY (
    object_schema          => 'MBK',
    action                 => SYS.DBMS_REDACT.ADD_COLUMN,
    object_name            => 'DOC',
    policy_name            => 'REDACT_MBK_01',
    column_name            => 'CARD_EXPIRE',
    function_type          => SYS.DBMS_REDACT.PARTIAL,
    function_parameters    => 'VVVVVVVVVVVVVVVV,VVVVVVVVVVVVVVVV,X,7,12');

  SYS.DBMS_REDACT.ALTER_POLICY (
    object_schema          => 'MBK',
    action                 => SYS.DBMS_REDACT.ADD_COLUMN,
    object_name            => 'DOC',
    policy_name            => 'REDACT_MBK_01',
    column_name            => 'SOURCE_NUMBER',
    function_type          => SYS.DBMS_REDACT.PARTIAL,
    function_parameters    => 'VVVVVVVVVVVVVVVV,VVVVVVVVVVVVVVVV,X,7,12');
END;
/
--------- drop redact policy
BEGIN
  DBMS_REDACT.drop_policy (
    object_schema => 'MBK',
    object_name   => 'ACNT_CONTRACT',
    policy_name   => 'REDACT_MBK_04'
  );
END;
/
+++++++++++++ KIEM TRA JOB GATHER ++++++++++++++++++++++++++++
set lines 200
col repeat_interval format a60
select window_name, repeat_interval,duration,ACTIVE,ENABLED from dba_scheduler_windows;
================== LOB retention chungtc ===============================
/* https://smarttechways.com/2019/09/30/avoid-snapshot-too-old-error-for-lob-segments-by-retention-or-pctversion/ */

SELECT b.object_name,
       CASE BITAND (a.flags, 32)
          WHEN 32 THEN 'RETENTION'
          WHEN 0 THEN 'PCTVERSION'
       END
          "PCTVERS/RETENT"
  FROM sys.lob$ a, dba_objects b
 WHERE     a.obj# = b.object_id
       AND b.owner = 'T24CORE'
       AND object_name in ('ACFBNK_ACCOUNT_REP','REFBNK_EB_C000_REP','AZFBNK_AZ_A001_REP');
       
       col owner for a8
col table_name for a20
col segment_name for a28
select owner,table_name,segment_name,pctversion,retention from dba_lobs where table_name in ('ACFBNK_ACCOUNT_REP','REFBNK_EB_C000_REP','AZFBNK_AZ_A001_REP','REFBNK_RE_S012_REP');

select u.name, o.name,
decode(bitand(c.property, 1), 1, ac.name, c.name),
decode(bitand(l.flags, 32), 0, l.pctversion$, to_number(NULL)),
decode(bitand(l.flags, 32), 32, l.retention, to_number(NULL))
from sys.obj$ o, sys.col$ c, sys.attrcol$ ac, sys.lob$ l,
sys.user$ u
where o.owner# = u.user#
and o.obj# = c.obj#
and c.obj# = l.obj#
and c.intcol# = l.intcol#
and c.obj# = ac.obj#(+)
and c.intcol# = ac.intcol#(+)
and bitand(c.property,32768) != 32768 /* not unused column */
--and o.name in ('ACFBNK_ACCOUNT_REP','REFBNK_EB_C000_REP','AZFBNK_AZ_A001_REP');

=========================check querry cause ora 1555 undo ===============
show parameter undo;
== check auto tune undo retention
select to_char(begin_time, 'DD-MON-RR HH24:MI') begin_time,
to_char(end_time, 'DD-MON-RR HH24:MI') end_time, tuned_undoretention
from v$undostat order by end_time;

== check ong nao gay loi ora 1555
select to_char(begin_time,'MM/DD/YYYY HH24:MI') begin_time,to_char(end_time,'MM/DD/YYYY HH24:MI') end_time, UNDOBLKS, UNXPSTEALCNT, EXPSTEALCNT ,
SSOLDERRCNT, NOSPACEERRCNT, MAXQUERYLEN,MAXQUERYID
from v$undostat
where begin_time between to_date('10/11/2019 14:00:00','MM/DD/YYYY HH24:MI:SS')
                 and to_date('10/11/2019 23:30:00','MM/DD/YYYY HH24:MI:SS');
				 
SSOLDERRCNT=1 se la thang gay ora 1555
NOSPACEERRCNT=1 chi ra la undo tablespace qua nho

=============== tune undo retention
SELECT MAX(undoblks/((end_time-begin_time)*3600*24))
INTO v_undo_blocks_per_sec
FROM v$undostat ;

Then the simple calculation below should give you the size of your desired undo tablespace.
database_block_size * max_undo_blocks_generated * undo_retention

alter system set undo_retention=10800 scope=both;
++++++++++++++++ UNDO tablespace ++++++++++++++++++++++++++++
--- check who is using undo tablespace
SELECT a.sid, b.name, a.value
FROM v$sesstat a, v$statname b
WHERE a.statistic# = b.statistic#
AND a.statistic# = 176    
ORDER BY a.value DESC;

select s.sid, t.name, s.value
from v$sesstat s, v$statname t
where s.statistic#=t.statistic#
and t.name='undo change vector size'
order by s.value desc;

### check undo retention
SELECT d.undo_size/(1024*1024) "ACTUAL UNDO SIZE [MByte]",
SUBSTR(e.value,1,25) "UNDO RETENTION [Sec]",
ROUND((d.undo_size / (to_number(f.value) *
g.undo_block_per_sec)))"OPTIMAL UNDO RETENTION [Sec]"
FROM (
SELECT SUM(a.bytes) undo_size
FROM v$datafile a,
v$tablespace b,
dba_tablespaces c
 WHERE c.contents = 'UNDO'
 AND c.status = 'ONLINE'
 AND b.name = c.tablespace_name
 AND a.ts# = b.ts#
 ) d,
 v$parameter e,
 v$parameter f,
 (
 SELECT MAX(undoblks/((end_time-begin_time)*3600*24))undo_block_per_sec
 FROM v$undostat
 ) g
 WHERE e.name = 'undo_retention'
 AND f.name = 'db_block_size'
 ; 
++++++++++

### Undo extent status examples - undo usage========================

select e.status,e.TABLESPACE_NAME,
  round(e.sum_bytes / (1024*1024), 0) as MB
 ,round((e.sum_bytes / f.undo_size) * 100, 0) as PERC
from
(
  select status,TABLESPACE_NAME, sum(bytes) sum_bytes
  from dba_undo_extents
  group by (status,TABLESPACE_NAME)
)  e

left join
(
  select tablespace_name,sum(a.bytes) undo_size
  from dba_tablespaces c
    join v$tablespace b on b.name = c.tablespace_name
    join v$datafile a on a.ts# = b.ts#
  where c.contents = 'UNDO'
    and c.status = 'ONLINE'
    group by tablespace_name
) f
on e.tablespace_name=f.tablespace_name;

SELECT d.undo_size/(1024*1024) "ACTUAL UNDO SIZE [MByte]",
       SUBSTR(e.value,1,25) "UNDO RETENTION [Sec]",
       (TO_NUMBER(e.value) * TO_NUMBER(f.value) *
       g.undo_block_per_sec) / (1024*1024) 
      "NEEDED UNDO SIZE [MByte]"
  FROM (
       SELECT SUM(a.bytes) undo_size
         FROM v$datafile a,
              v$tablespace b,
              dba_tablespaces c
        WHERE c.contents = 'UNDO'
          AND c.status = 'ONLINE'
          AND b.name = c.tablespace_name
          AND a.ts# = b.ts#
       ) d,
      v$parameter e,
       v$parameter f,
       (
       SELECT MAX(undoblks/((end_time-begin_time)*3600*24))
         undo_block_per_sec
         FROM v$undostat
       ) g
 WHERE e.name = 'undo_retention'
  AND f.name = 'db_block_size';

--------------- chungtc session use undo us - contention ; block range reuse ckpt ---------------
SELECT s.username,
       s.sid,
       s.serial#,
       t.used_ublk,
       t.used_urec,
       rs.segment_name,
       r.rssize,
       r.status
FROM   gv$transaction t,
       gv$session s,
       gv$rollstat r,
       dba_rollback_segs rs
WHERE  s.saddr = t.ses_addr
AND    t.xidusn = r.usn
AND   rs.segment_id = t.xidusn
ORDER BY t.used_ublk DESC;  
######## undo tunned	 status ##############
select * from
(
SELECT TO_CHAR(BEGIN_TIME, 'MM/DD/YYYY HH24:Mi:SS') BEGIN_TIME,TO_CHAR(END_TIME, 'MM/DD/YYYY HH24:Mi:SS') END_TIME,
UNDOTSN, UNDOBLKS, TXNCOUNT, MAXCONCURRENCY AS "MAXCON",
MAXQUERYLEN, TUNED_UNDORETENTION
FROM v$UNDOSTAT order by TUNED_UNDORETENTION desc
)
where rownum<10;
    undoblks:  This is the number of undo blocks in the undo tablespace.
    maxquerylen:  This column of v$undostat displays the maximum query length (in seconds) of the largest query during the specified time period.  This is used as feedback for setting the undo_retention parameter because undo_retention should be larger than the value returned by the maxquerylen column.  In sum, the undo_retention initialization parameter should be set to a value larger than the maximum query length.
    expstealcnt:  This v$undostat column shows how many times expired undo blocks were stolen for that time interval.
    unxpstealcnt:  This v$undostat column shows how many times unexpired undo blocks were stolen.
    nospaceerrcnt: This v$undostat column shows how many times there was no free space in the undo tablespace.
    ssolderrcnt: This v$undostat column shows how many times queries received the ORA-1555 error message during that time interval. If this column contains non-zero values, consider raising the undo_retention initialization parameter.
				Note:  If the expstealcnt, unxpstealcnt or the nospaceerrcnt columns contain non-zero values, your undo tablespace may be sized too small and you should consider increasing the size of your undo tablespace.		

select status,
 round(sum_bytes / (1024*1024), 0) as MB,
 round((sum_bytes / undo_size) * 100, 0) as PERC,
 decode(status, 'UNEXPIRED', round((sum_bytes / undo_size * factor) * 100, 0),
                'EXPIRED',   0,
                             round((sum_bytes / undo_size) * 100, 0)) FULL
from
(
  select status,TABLESPACE_NAME, sum(bytes) sum_bytes
  from dba_undo_extents
  group by (status,TABLESPACE_NAME)
)  e

left join
(
  select tablespace_name,sum(a.bytes) undo_size
  from dba_tablespaces c
    join v$tablespace b on b.name = c.tablespace_name
    join v$datafile a on a.ts# = b.ts#
  where c.contents = 'UNDO'
    and c.status = 'ONLINE'
    group by tablespace_name
) f
on e.tablespace_name=f.tablespace_name,
(
 select tuned_undoretention, u.value, u.value/tuned_undoretention factor
 from v$undostat us
 join (select max(end_time) end_time from v$undostat) usm
    on usm.end_time = us.end_time
 join (select name, value from v$parameter) u
    on u.name = 'undo_retention'
);

    ========== trong 1 so truong hop check full undo tablespace theo cach ================
    	SELECT a.* FROM v$UNDOSTAT a order by BEGIN_TIME desc;  -- xem xem end_time hien tai co MAXQUERYID nao gay ra MAXQUERYLEN cao khong. Thuong neu MAXQUERYLEN tang theo thoi gian thi do 1 session nao do ( ke ca da inactive roi)
    	SELECT sid||','||serial# sid_ser,inst_id,						-- kiem tra MAXQUERYID co sid,serial nao roi kill di
        status,
     		schemaname||'@'||service_name  from_where, 
        osuser,
        program,
     		NVL((select DISTINCT sql_text from v$sql sql where sql.sql_id = ses.sql_id),'NOTHING GOING ON') sql_text,
     		blocking_session,
     		TO_CHAR(logon_time,'dd/mm/yyyy HH24:MM:SS AM') as from_when
   			FROM gv$session ses
  			WHERE sql_id ='2mq050dwrn7mj';
  		ALTER SYSTEM KILL SESSION '2776,35469' IMMEDIATE;---kill session co sid_ser lay dc ben tren

++++LOC LOAI BO CAC HANG MINH KHONG CAN++++++++++++++++++++++
 df -h| grep -v 'Filesystem'|grep -v '/devices'|grep -v 'ctfs'|grep -v 'proc'|grep -v 'mnttab'|grep -v 'objfs'|grep -v 'sharefs'|grep -v 'fd'| grep -v  '/vol/dev/dsk/c2t6d0/sol_10_910_sparc'|awk '{ print $5 " " $1 }'
 df -h| grep -v 'rpool/ROOT/s10s_u10wos_17b' |grep -v 'swap' |grep -v '/platform/sun4v/lib/libc_psr/libc_psr_hwcap2.so.1' |grep -v '/platform/sun4v/lib/libc_psr/libc_psr_hwcap2.so.1' | awk '{ print $5 " " $1 }'
 ds=$(df -k /u01 |grep 'u01'| awk '{ print $5}' | cut -d'%' -f1)


if [ $ds -ge 1 ]
then
echo 'chung'
fi


==============================gather system stat sysstat chungtc t24   https://support.oracle.com/epmos/faces/DocumentDisplay?_afrLoop=505965949858942&parent=EXTERNAL_SEARCH&sourceId=HOWTO&id=149560.1&_afrWindowMode=0&_adf.ctrl-state=llislkcki_4
execute DBMS_STATS.GATHER_SYSTEM_STATS ('START');
SELECT  t.RECID FROM t24core.PDFBNK_PD_P003 t WHERE NVL(EXTRACTVALUE(t.XMLRECORD,'/row/c111'),'')>'' ;
SELECT  /*+index(t IDX_PDFBNK_PD_P003$C111)*/t.RECID FROM t24core.PDFBNK_PD_P003 t WHERE NVL(EXTRACTVALUE(t.XMLRECORD,'/row/c111'),'')>'' ;
execute DBMS_STATS.GATHER_SYSTEM_STATS ('STOP');

-- nhu nay gather theo interval 30s
DBMS_STATS.GATHER_SYSTEM_STATS(gathering_mode => 'INTERVAL',interval => 30 );
-- nhu nay gather ve default mode
DBMS_STATS.GATHER_SYSTEM_STATS
-- manual set tham so
EXEC DBMS_STATS.set_system_stats('IOTFRSPEED', 138695);

begin
dbms_stats.set_system_stats('CPUSPEED',500);
dbms_stats.set_system_stats('SREADTIM',5.0);
dbms_stats.set_system_stats('MREADTIM',30.0);
dbms_stats.set_system_stats('MBRC',12);
end;
/
select * from aux_stats$;

  CPUSPEEDNW: 1666 millions instructions/sec (default is 100)   Represents noworkload CPU speed
  IOTFRSPEED: 138695 bytes per millisecond (default is 4096)	I/O transfer speed is the rate at which an Oracle database can read data in a single read request
  IOSEEKTIM:  2 milliseconds (default is 10)					I/O seek time equals seek time + latency time + operating system overhead time.
  MBRC:       NO VALUE blocks (default is 128)  Average observed multiblock read count
  MAXTHR Maximum I/O system throughput in bytes/second
SLAVETHR Average IO Slave IO through put in bytes/second
CPUSPEED Available cycles per second, in millions (relative CPU speed)

  Sreadtim:=ioseektim+db_block_size/IOTFRSPEED=2+8192/138695=2.059064854536934   Time to read single-block I/O, in milliseconds
Mreadtim:=ioseektim+db_file_multiblock_read_count*db_block_size/iotrftspeed =2+128*8192/138695=9.560301380727496    Time to read multiple blocks, in milliseconds
   MB Read Time = IOSEEKTIM + MBRC * Block Size / IOTFRSPEED
 
  iocost:=(No. of Blocks/MBRC)*mreadtim/sreadtim =71872/128*9.560301380727496/2.0590648545369336=2607.061751090756
cpucost:=#cpu cycles/(cpuspeed*(sreadtim*1000))—->#cpu cycles is Total Scan CPU Cost =9277852525.840000/(1666*(2.059064854536934*1000))=2704.59625342537

  
  ========================================================
---------------ORA-01000: maximum open cursors exceeded ORA-00604: error occurred at recursive SQL level 1
select * from v$open_cursor where cursor_Type='OPEN';

SELECT A.VALUE,
       S.USERNAME,
       S.SID,
       S.SERIAL#
  FROM dba_hist_sysstat A, dba_hist_STATNAME B, dba_hist_SESSION S
 WHERE     A.STATISTIC# = B.STATISTIC#
       AND S.SID = A.SID
       AND B.NAME = 'opened cursors current'
       ORDER BY VALUE DESC;
	   
select  sid ,sql_text, count(*) as "OPEN CURSORS", USER_NAME from v$open_cursor where sid in (
select  s.sid from v$sesstat a, v$statname b, v$session s where a.statistic# = b.statistic#  and s.sid=a.sid and b.name = 'opened cursors current' and s.username is not null
)
group  by sid ,sql_text,USER_NAME;
-------- tao thu muc = plsql------------------------------
sqlplus /as sysdb
create directory plsql_dir as 'D:\vms_plsql\labs\reports';
grant read, write on directory plsql_dir1 to hra
I.	N?P TH? CÀO QUA USSD : 
1. N?p ti?n :  *100*14 ch? s? c?a th? cào# - B?m YES
S? máy	S? th?	Th?i gian n?p	K?t qu?	Ghi chú
			ok	

======================== chungtc gather incremental ========================= https://yasu-khan.github.io/Incremental-Statistics-Gathering
-- thuc hien set incremental TR_KU,MB_TR_SOPHU
exec dbms_stats.set_table_prefs('T24RPT','MB_TR_SOPHU','INCREMENTAL','TRUE');
EXEC DBMS_STATS.set_table_prefs('T24RPT', 'MB_TR_SOPHU', 'GRANULARITY', 'AUTO');
EXEC DBMS_STATS.set_table_prefs('T24RPT', 'MB_TR_SOPHU', 'ESTIMATE_PERCENT', DBMS_STATS.AUTO_SAMPLE_SIZE);
-- kiem tra properties truoc gather
SELECT dbms_stats.get_prefs('INCREMENTAL','T24RPT','MB_TR_SOPHU') "INCREMENTAL" FROM   dual;
SELECT dbms_stats.get_prefs('PUBLISH','T24RPT','MB_TR_SOPHU') "PUBLISH" FROM   dual;
SELECT dbms_stats.get_prefs('ESTIMATE_PERCENT','T24RPT','MB_TR_SOPHU') "ESTIMATE_PERCENT" FROM   dual;
SELECT dbms_stats.get_prefs('GRANULARITY','T24RPT','MB_TR_SOPHU') "GRANULARITY" FROM   dual;	
-- thuc hien gather
exec dbms_stats.gather_table_stats('OE','ORDERS_DEMO',partname=>'ORDERS_OCT_2015',ESTIMATE_PERCENT=>DBMS_STATS.AUTO_SAMPLE_SIZE, granularity=>'PARTITION');
EXEC DBMS_STATS.gather_table_stats('NSLD', 'TR_THLK_NSLD',degree=>32);
Name	Owner	Type
TR_THLK_NSLD	NSLD	Table

EXEC DBMS_STATS.gather_table_stats('GCM_AGCM_VIET_MBTT_RET', 'APIGW_REFERRAL_PRESENTEE', granularity => 'AUTO', estimate_percent => DBMS_STATS.AUTO_SAMPLE_SIZE,degree=>8,cascade=>TRUE);
EXECUTE DBMS_STATS.GATHER_SCHEMA_STATS(ownname => 'CMV_NEW', estimate_percent => DBMS_STATS.AUTO_SAMPLE_SIZE,degree=>8);
EXECUTE DBMS_STATS.GATHER_SCHEMA_STATS(ownname => 'SYSTEM', estimate_percent => DBMS_STATS.AUTO_SAMPLE_SIZE,degree=>128);

-- Check synopsis creation time.
SELECT o.name         "Table Name",
       p.subname      "Part",
       c.name         "Column",
       h.analyzetime  "Synopsis Creation Time"
FROM   WRI$_OPTSTAT_SYNOPSIS_HEAD$ h,
       OBJ$ o,
       USER$ u,
       COL$ c,
       ( ( SELECT TABPART$.bo#  BO#,
                  TABPART$.obj# OBJ#
           FROM   TABPART$ tabpart$ )
         UNION ALL
         ( SELECT TABCOMPART$.bo#  BO#,
                  TABCOMPART$.obj# OBJ#
           FROM   TABCOMPART$ tabcompart$ ) ) tp,
       OBJ$ p
WHERE  u.name = 'OE' AND
       o.name = 'ORDERS_DEMO' AND
       tp.obj# = p.obj# AND
       h.bo# = tp.bo# AND
       h.group# = tp.obj# * 2 AND
       h.bo# = c.obj#(+) AND
       h.intcol# = c.intcol#(+) AND
       o.owner# = u.user# AND
       h.bo# = o.obj#
ORDER  BY 4,1,2,3;

-- check co fai incremental gather khong
SELECT partition_name,
       To_char( last_analyzed, 'DD-MON-YYYY, HH24:MI:SS' ) last_analyze,
       num_rows,a.*
FROM   DBA_TAB_PARTITIONS a
WHERE  table_name = 'MB_TR_FT' 
ORDER  BY partition_position;

SELECT o.name,
       Decode( Bitand( h.spare2, 8 ), 8, 'yes',
                                      'no' ) incremental
FROM   HIST_HEAD$ h,
       OBJ$ o
WHERE  h.obj# = o.obj# AND
       o.name = 'MB_TR_FT' AND
       o.subname IS NULL; 		
------------ chungtc gather chay = user sys --------------------------
 EXEC dbms_stats.gather_table_stats('GL', 'GL_BALANCES',degree => 16);

declare
 partition_name varchar2(12);
begin
 select 'DATA'||to_char(sysdate,'YYYYMMDD') into partition_name from dual; 
 dbms_stats.gather_table_stats('OCSG_OWNER', 'CPS_REQUEST',partname=>partition_name,granularity=>'partition',estimate_percent => 5);
end;
-- dbms_stats.gather_table_stats('OCSG_OWNER', 'GW_IREQUEST',partname=>partition_name,granularity=>'partition');

 EXEC dbms_stats.gather_table_stats('DWH', 'CRTB_DDAFTM',degree => 16);
 exec dbms_stats.gather_table_stats(null,'customers_obe', method_opt => 'for all columns size skewonly');
EXEC dbms_stats.gather_table_stats('B2RAW', 'TBCP_CPTY_KP', estimate_percent=>DBMS_STATS.AUTO_SAMPLE_SIZE, method_opt => 'FOR ALL COLUMNS SIZE AUTO',granularity=> 'ALL', degree=>8, cascade=>true,no_invalidate => false);
EXEC dbms_stats.gather_table_stats('PUSHMESSAGE', 'MB_PM_MESSAGES_RECEIVERS', estimate_percent=>DBMS_STATS.AUTO_SAMPLE_SIZE, method_opt => 'FOR ALL COLUMNS SIZE skewonly', degree=>8, granularity=> 'ALL',cascade=>true,no_invalidate => false);
EXEC dbms_stats.gather_table_stats( 'APPS','MB_TR_STMT_DOISOAT',partname => 'SYS_P196873',granularity=>'partition',estimate_percent=>DBMS_STATS.AUTO_SAMPLE_SIZE, degree=>32, cascade=>true,no_invalidate => false);

select 'EXEC dbms_stats.gather_table_stats( '''||table_owner||''','''||table_name||''',partname => '''||partition_name||''',granularity=>''partition'',estimate_percent=>DBMS_STATS.AUTO_SAMPLE_SIZE, degree=>8, cascade=>true,no_invalidate => false);'  from dba_tab_partitions 
where table_name='MB_TR_T24_STMT_NOW' order by partition_position desc;

execute dbms_stats.gather_index_stats(ownname => 'AMLMCOB', indname =>'GWGKUNDE$INSTITUTSNR', estimate_percent =>DBMS_STATS.AUTO_SAMPLE_SIZE,degree => 8,no_invalidate => false);

--- chi gather va tao histogram tren 1 column
BEGIN dbms_stats.Gather_table_stats('CREDITCARD', 'TBCC_CARD',  method_opt => 'FOR COLUMNS SIZE 254 CONTRACT_NUMBER', degree=>8); 
END; 
/


Note thêm 1 chút với cả nhà là với DB 12c trở lên, chúng ta sẽ bỏ tham số estimate_percent vì 12c AUTO đã ổn rồi nên không cần care nữa nhé
Con số estimate_percent phù hợp cho bảng được Oracle recommend (internal, not public):
Số row của bảng	%
<= 1tr	100
1tr – 10tr	30
10 tr – 100 tr	10
100 tr – 1 tỉ	3
>= 1 tỉ	1

 -- ktra lai
 select table_name,num_rows,last_analyzed from dba_tables where table_name in ( 'PMTB_INSTRUMENT_HIST', 'PMTB_INSTRUMENT_INFO', 'PMTB_INSTRUMENT_CALC_HIST');

=======================namvx
SELECT
            *
        FROM
            v_customer_summary_1 custsummary    
         ORDER BY
            custsummary.customer_code ASC  
         OFFSET 10 ROWS FETCH NEXT 10 ROWS ONLY;
		 
select * from(

SELECT             
            custSummary.tax_code,
            custSummary.transaction_frequency,
rank()                 over (order by custsummary.customer_code ) rnk         
FROM             v_customer_summary_1 custSummary
)
where rnk >6344381  and rnk <=6344386 ;	


alter table chungtc.PRODUCT_DETAIL       modify subpartition SYS_SUBP10493     unusable local indexes;
alter table chungtc.PRODUCT_DETAIL       modify subpartition SYS_SUBP10485     rebuild unusable local indexes;	 
 =============================== EXTENDED STATISTIC. khi ko co histogram thi tinh theo ndv, co histogram thi tinh theo histogram
-- tao
 select  dbms_stats.create_extended_stats('AMLMCOB','TEST', '(STATUS, HISTBIS)') from dual;
-- drop 
BEGIN
  DBMS_STATS.DROP_EXTENDED_STATS( 'AMLMCOB', 'PRESULT', 
                                  '("INSTITUTSNR","KUNDNR","PSTATUS")' );
END;
/
--SYS_STUUCWPWISL9756O5#H0H2N7#F  tao xong fai gather moi sinh ra NDV va histogram
EXEC dbms_stats.gather_table_stats('AMLMCOB', 'TEST', estimate_percent=>DBMS_STATS.AUTO_SAMPLE_SIZE, method_opt => 'FOR ALL COLUMNS SIZE AUTO', degree=>8, cascade=>true,no_invalidate => false);
exec dbms_stats.gather_table_stats('DWH','DDFT_TRANSACTION',method_opt=>'FOR COLUMNS SIZE AUTO (TRN_DATE,SEQ_NUMBER,USER_ID,CHANNEL_TRN,DORC_IND,AFFECT_CODE)',degree=>8);

SELECT column_name, num_distinct, num_nulls, histogram,sample_Size
FROM   DBA_tab_col_statistics
WHERE  table_name = 'TEST' AND OWNER='AMLMCOB'
ORDER BY column_name;

SELECT *
FROM   DBA_tab_histograms
WHERE  table_name  = 'TEST'
AND    column_name = 'SYS_STUUCWPWISL9756O5#H0H2N7#F' and owner='AMLMCOB'
ORDER BY endpoint_value;

--frequency 
SELECT endpoint_value,
       endpoint_number,
       endpoint_number - LAG(endpoint_number, 1, 0) OVER (ORDER BY endpoint_value) AS frequency
FROM   DBA_tab_histograms
WHERE  table_name  = 'PRESULT' AND OWNER='AMLMCOB'
AND    column_name = 'STATUS'
ORDER BY endpoint_value; 

--- top-frequency
select * from 
(
select
           endpoint_number
          ,endpoint_actual_value
          ,endpoint_repeat_count
          ,bucket_size
          ,case when Popularity > 0 then 'Pop'
             else 'Non-Pop'
            end Popularity
      from
      (
        select
            uth.endpoint_number
           ,uth.endpoint_actual_value
           ,uth.endpoint_repeat_count
           ,ucs.sample_size/ucs.num_buckets bucket_size
           ,(uth.endpoint_repeat_count - ucs.sample_size/ucs.num_buckets) Popularity
       from
           dba_tab_histograms uth
          ,dba_tab_col_statistics ucs
      where
           uth.table_name   = ucs.table_name
       and uth.column_name   = ucs.column_name
       and uth.table_name    = 'PRESULT'
       and uth.column_name   = 'HISTBIS'
       )
     )
	 
--HYBRID
select
           endpoint_actual_value
          ,endpoint_repeat_count
          ,bucket_size
          ,Popularity
 from
 (
   select
           endpoint_number
           ,endpoint_actual_value
           ,endpoint_repeat_count
           ,bucket_size
           ,case when Popularity > 0 then 'Pop'
              else 'Non-Pop'
             end Popularity
       from
      (
        select
            uth.endpoint_number
           ,uth.endpoint_actual_value
           ,uth.endpoint_repeat_count
           ,ucs.sample_size/ucs.num_buckets bucket_size
           ,(uth.endpoint_repeat_count - ucs.sample_size/ucs.num_buckets) Popularity
       from
           DBA_tab_histograms uth
          ,DBA_tab_col_statistics ucs
      where
           uth.table_name   = ucs.table_name
       and uth.column_name   = ucs.column_name
       and uth.table_name    = 'TEST'
       and uth.column_name   = 'SYS_STUUCWPWISL9756O5#H0H2N7#F' AND UCS.OWNER='AMLMCOB'
       )
    )
 -- where Popularity = 'Pop';
-------------- patch grid + db
https://support.oracle.com/epmos/faces/DocumentDisplay?_afrLoop=369677675701966&id=2246888.1&_afrWindowMode=0&_adf.ctrl-state=xjij7vi2a_486#aref_section117

------------ after datapatch
select count(*) from dba_objects where status != 'VALID' and owner in ('SYS','SYSTEM');
select count(*) from dba_objects where status != 'VALID';
cd $ORACLE_HOME/OPatch
./datapatch -verbose
- fai compile lai
@/oracle/app/oracle/product/12.2.0.1/rdbms/admin/utlrp.sql
select count(*) from dba_objects where status != 'VALID' and owner in ('SYS','SYSTEM');
select count(*) from dba_objects where status != 'VALID';
Check Patch information in DB
 set linesize 500
col STATUS for a10
col ACTION_TIME for a30
col DESCRIPTION for a50
select PATCH_ID, VERSION, STATUS, ACTION_TIME, DESCRIPTION from dba_registry_sqlpatch;
------------------ precheck collision before patch thang atna ------------------
oracle@evs2-db01:~/patch$ env | grep ORA
ORACLE_SID=evsdr1
ORACLE_HOME=/data/oracle/product/11.2.0/dbhome_1
oracle@evs2-db01:~/patch$ cd 10194190/
oracle@evs2-db01:~/patch/10194190$ opatch prereq CheckConflictAgainstOHWithDetail -oh /data/oracle/product/11.2.0/dbhome_1 -ph ./
Oracle Interim Patch Installer version 11.2.0.3.16
Copyright (c) 2018, Oracle Corporation.  All rights reserved.

PREREQ session

Oracle Home       : /data/oracle/product/11.2.0/dbhome_1
Central Inventory : /data/orabase/oraInventory
   from           : /data/oracle/product/11.2.0/dbhome_1/oraInst.loc
OPatch version    : 11.2.0.3.16
OUI version       : 11.2.0.3.0
Log file location : /data/oracle/product/11.2.0/dbhome_1/cfgtoollogs/opatch/opatch2018-03-21_15-40-56PM_1.log

Invoking prereq "checkconflictagainstohwithdetail"

Prereq "checkConflictAgainstOHWithDetail" passed.

OPatch succeeded.
	
--------------------------------hieu atna patch bi loi quyen file ---------------------
root$/db/oracle/11.2.0/grid/bin/setasmgid -o=/db/oracle/11.2.0/dbhome_1/bin/oracle
-----------------------How to find which Oracle inventory is for which Oracle home.
Using correct inventory when you try to apply a patch or installing new software is vital.In order to find which existing Oracle inventory is for which Oracle home , follow the following steps :

- Find oraInst.loc (it is in /etc or in /opt/var/oracle) . This file determines inventory location.
- Find inventory.xml file in {inventory_location}/ContentsXML.This file list all Oracle homes which this inventory has.
- This gives you better idea whether or not the existing inventory is the right inventory for Oralce home. 
------------------------ATNA cai lai oracle inventory -----------------
oracle$ cd /u01/app/evsdr/dbhome/oui/bin
oracle$ ./runInstaller -silent -ignoreSysPrereqs -attachHome ORACLE_HOME="/u01/app/evsdr/dbhome" ORACLE_HOME_NAME="OraDb11g_home_new"
Starting Oracle Universal Installer...

Checking swap space: must be greater than 500 MB.   Actual 53830 MB    Passed

---------check tnsnames.ora toi db remote
sqlplus sys/<password>@<tns_alias> as sysdba
SID_LIST_LISTENER =
  (SID_LIST =
    (SID_DESC =
      (GLOBAL_DBNAME = kmtd5)  => service kmtd5, instance kmtd5
      (ORACLE_HOME = /u01/oracle/product/11.2.0/kmtd5)
      (SID_NAME = kmtd5)
    )
    (SID_DESC =
      (SID_NAME= kmtd5)
      (GLOBAL_DBNAME = kmtd5_stby_DGMGRL)=> service kmtd5_stby_DGMGRL, instance kmtd5
      (ORACLE_HOME = /u01/oracle/product/11.2.0/kmtd5)
    )
  )
====> Vay nen se co cac he qua sau:
ps -ef|grep lsnr
$lsnrctl status
		Service "kmtd5" has 1 instance(s).
		  Instance "kmtd5", status UNKNOWN, has 1 handler(s) for this service...
		Service "kmtd5_stby_DGMGRL" has 1 instance(s).
		  Instance "kmtd5", status UNKNOWN, has 1 handler(s) for this service...
KMTD198_DGMGRL =
  (DESCRIPTION =
    (ADDRESS = (PROTOCOL = TCP)(HOST = HN198-KMTD-B)(PORT = 1521))
    (CONNECT_DATA =
      (SERVER = DEDICATED)
      (SERVICE_NAME = kmtd5_stby_DGMGRL) => service
    )
  )
  
LSNRCTL> services
Connecting to (ADDRESS=(PROTOCOL=tcp)(HOST=)(PORT=1521))
Services Summary...
Service "+ASM" has 1 instance(s).
  Instance "+ASM1", status READY, has 1 handler(s) for this service...
    Handler(s):
      "DEDICATED" established:0 refused:0 state:ready
         LOCAL SERVER
Service "orcl" has 1 instance(s). ==> xem trong SQL> show parameter service;
  Instance "orcl1", status READY, has 1 handler(s) for this service...
    Handler(s):
      "DEDICATED" established:5910 refused:0 state:ready
         LOCAL SERVER
Service "orclXDB" has 1 instance(s).  => xem trong pfile co dong .dispatchers='(PROTOCOL=TCP) (SERVICE=orclXDB)'
  Instance "orcl1", status READY, has 1 handler(s) for this service...
    Handler(s):
      "D000" established:0 refused:0 current:0 max:1022 state:ready
         DISPATCHER <machine: evs-db01, pid: 8040>
         (ADDRESS=(PROTOCOL=tcp)(HOST=evs-db01)(PORT=56870))
The command completed successfully  
-------------- connection identifier tns ----------------------------------------------------------------------------------------
https://docs.oracle.com/cd/A81042_01/DOC/network.816/a76933/concepts.htm#1039613
https://docs.oracle.com/cd/A81042_01/DOC/network.816/a76933/advcfg.htm#465216
sales= 
(description= 
  (address=(protocol=tcp)(host=sales-server)(port=1521))
  (connect_data=
    (service_name=sales.us.acme.com))
=> chuoi tns tren co nghia la: listener, nằm trên server sales-server, nghe trên port tcpip 1521 để phục vụ các connection request cho database services sales.us.acme.com

Configuring Address List Parameters
		When a database service is accessible by multiple listener protocol addresses, it is important to specify the order of how the addresses are to be used. For example, the addresses can be chosen randomly or tried sequentially.
		When multiple protocol addresses have been configured for a net service name or database service, the following options may be configured:
		SOURCE_ROUTE (Source Routing )
				Instructs Net8 to use each address in the order presented until the destination reached when set to ON. This parameter is required when reaching the destination requires more than one address stop. 
				This feature is typically used to enable Oracle Connection Manager features. 
		FAILOVER (Connect-Time Failover) 
				At connect time, instructs Net8 to fail over to a different listener if the first listener fails when set to ON. The number of addresses in the list determines how many addresses are tried. 
				When set to OFF, instructs Net8 to try one address.
				Connect-time failover is turned ON by default for multiple address lists (ADDRESS_LIST), connect descriptors (DESCRIPTION), and multiple connect descriptors (DESCRIPTION_LIST).
				Important: Do not set the GLOBAL_DBNAME parameter in the SID_LIST_listener_name section of the listener.ora file. A statically configured global database name disables connect-time failover. 
		LOAD_BALANCE (Client Load Balancing) 
				When set to ON, instructs Net8 to progress through the list of listener addresses in a random sequence, balancing the load on the various listeners. 
				When set to OFF, instructs Net8 to try the addresses sequentially until one succeeds.
				Client load balancing is turned ON by default for multiple connect descriptors (DESCRIPTION_LIST). 
Net8 Assistant Option : FAILOVER default là ON, LOAD_BALANCE default là OFF, SOURCE_ROUTE default là OFF
		Try each address, in order, until one succeeds :FAILOVER=ON		
																										ORCL =
																										  (DESCRIPTION =
																										    (ADDRESS_LIST =
																										      (ADDRESS = (PROTOCOL = TCP)(HOST = evs-db.mobifone.vn)(PORT = 1521))
																										      (ADDRESS = (PROTOCOL = TCP)(HOST = evs-db.mobifone.vn)(PORT = 1521))
																										    )
																										    (CONNECT_DATA =
																										      (SERVER = DEDICATED)
																										      (SERVICE_NAME = orcl)
																										    )
																										  )
																												
		Try each address, randomly, until one succeeds:	LOAD_BALANCE=ON  FAILOVER=ON
																										ORCL =
																								  (DESCRIPTION =
																								    (ADDRESS_LIST =
																								      (ADDRESS = (PROTOCOL = TCP)(HOST = evs-db.mobifone.vn)(PORT = 1521))
																								      (ADDRESS = (PROTOCOL = TCP)(HOST = evs-db.mobifone.vn)(PORT = 1521))
																								      (LOAD_BALANCE = yes)
																								    )
																								    (CONNECT_DATA =
																								      (SERVER = DEDICATED)
																								      (SERVICE_NAME = orcl)
																								    )
																								  )																			
		Try one address, selected at random:	
																					ORCL =
																			  (DESCRIPTION =
																			    (ADDRESS_LIST =
																			      (ADDRESS = (PROTOCOL = TCP)(HOST = evs-db.mobifone.vn)(PORT = 1521))
																			      (ADDRESS = (PROTOCOL = TCP)(HOST = evs-db.mobifone.vn)(PORT = 1521))
																			      (LOAD_BALANCE = yes)
																			      (FAILOVER = false)
																			    )
																			    (CONNECT_DATA =
																			      (SERVER = DEDICATED)
																			      (SERVICE_NAME = orcl)
																			    )
																			  )

		Use each address in order until destination reached: SOURCE_ROUTE=ON
																													ORCL =
																													  (DESCRIPTION =
																													    (ADDRESS_LIST =
																													      (ADDRESS = (PROTOCOL = TCP)(HOST = evs-db.mobifone.vn)(PORT = 1521))
																													      (ADDRESS = (PROTOCOL = TCP)(HOST = evs-db.mobifone.vn)(PORT = 1521))
																													      (SOURCE_ROUTE = yes)
																													      (FAILOVER = false)
																													    )
																													    (CONNECT_DATA =
																													      (SERVER = DEDICATED)
																													      (SERVICE_NAME = orcl)
																													    )
																													  )
		
		Use only the first address: LOAD_BALANCE=OFF FAILOVER=OFF SOURCE_ROUTE=OFF 
																												ORCL =
																												  (DESCRIPTION =
																												    (ADDRESS_LIST =
																												      (ADDRESS = (PROTOCOL = TCP)(HOST = evs-db.mobifone.vn)(PORT = 1521))
																												      (ADDRESS = (PROTOCOL = TCP)(HOST = evs-db.mobifone.vn)(PORT = 1521))
																												      (FAILOVER = false)
																												    )
																												    (CONNECT_DATA =
																												      (SERVER = DEDICATED)
																												      (SERVICE_NAME = orcl)
																												    )
																												  )
		
---------- profile.xml ---------------
cd /app/newrac/grid/gpnp/evs-db01/profiles/peer  
-------------gpnp tool -----------
./gpnptool get  #The GPnP profile is a small XML file located in GRID_HOME/gpnp/<hostname>/profiles/peer under the name profile.xml. It is used to establish the correct global personality of a node. Each node maintains a local copy of the GPnP Profile and is maintanied by the GPnP Deamon (GPnPD) .
./gpnptool lfind #- How to find GPnP Deamons are running on the local node
/app/newrac/grid/bin/gpnptool  getpval -asm_spf -p=/app/newrac/grid/gpnp/evs-db01/profiles/peer/profile.xml #How to find the location of ASM spfile if the ASM is down
/app/newrac/grid/bin/gpnptool  check -p=/app/newrac/grid/gpnp/evs-db01/profiles/peer/profile.xml #Check if GPnP configuration is valid
/app/newrac/grid/bin/gpnptool get 2>/dev/null  |  xmllint --format - | egrep 'CSS-Profile|ASM-Profile|Network id' 

========== khi bi loi ko start duoc RAC ===================
[oracle@rac1 ~]$ cd /u01/app/11.2.0/grid/bin
[oracle@rac1 bin]$ ./crsctl check crs
CRS-4639: Could not contact Oracle High Availability Services
[oracle@rac1 bin]$ 
[oracle@rac1 bin]$ su - root
Password: 
[root@rac1 ~]# cd /u01/app/11.2.0/grid/bin
[root@rac1 bin]# ./crsctl start crs
CRS-4124: Oracle High Availability Services startup failed
CRS-4000: Command Start failed, or completed with errors
[root@rac1 bin]#

Then I have verified cluster Oracle High Availability auto start-up is configured or not?
       
[root@rac1 bin]# ./crsctl config has
CRS-4622: Oracle High Availability Services autostart is enabled.
[root@rac1 bin]# 

-- thuc hien sua loi
[root@rac1 ~]# nohup /etc/init.d/init.ohasd run &
[1] 20959
[root@rac1 ~]#

[root@rac1 bin]# ./crsctl start crs
CRS-4640: Oracle High Availability Services is already active
CRS-4000: Command Start failed, or completed with errors.
[root@rac1 bin]# 
[root@rac1 bin]# ./crsctl check crs
CRS-4638: Oracle High Availability Services is online
CRS-4537: Cluster Ready Services is online
CRS-4529: Cluster Synchronization Services is online
CRS-4533: Event Manager is online
[root@rac1 bin]#


------------------WHAT IS OCR ------------
n this post, I will discuss about Oracle Cluster Registry which is a critical component of RAC.
The  Oracle Cluster Registry (OCR)  records cluster configuration information. If it  fails, the entire clustered environment for Oracle 11g RAC will be adversely affected and a possible outage may result if  OCR is lost.
 
 
OCR is the central repository for CRS, which stores the metadata, configuration and state information for all cluster resources defined in clusterware. It is a cluster registry used to maintain application resources and their availability within the RAC environment. It also stores configuration information for CRS daemons and clusterwaremanaged applications.
 
What is stored in OCR ?
- Node membership information i.e. which nodes are part of the cluster
- Software active version
- the location of the 11g voting disk.
- Serverpools
- Status for the cluster resources such as RAC databases, listeners, instances, and services
  . Server up/down
  . Network up/down
  . Database up/down
  . Instance up/down
  . Listener up/down …
 

- configuration for the cluster resources such as RAC databases, listeners, instances, and services.
  . Dependencies
  . Management policy (automatic/manual)
  . Callout scripts
  . Retries
  . ….- cluster database instance to node mapping

- ASM instance, Diskgroups etc.
- CRS application resource profiles such as VIP addresses, services etc.
- Database services’ characteristics e.g preferred/available nodes, TAF policy , Load balancing goal etc.
- Information about clusterware processes
- Information about interaction and management of  third party applications controlled by CRS
- Details of the network interfaces held by the cluster network
- Communication settings where the Clusterware daemons or background processes listen
- Information about OCR backups

--------- what is voting disk ---------------
 What is stored in voting disk?
——————————
Voting disks contain static and dynamic data.
Static data : Info about nodes in the cluster
Dynamic data : Disk heartbeat logging
It maintains and consists of important details about the cluster nodes membership, such as
- which node is part of the cluster,
- who (node) is joining the cluster, and
- who (node) is leaving the cluster.
--------- chungtc rac log grid log---------------------------------- 11g $grid_home/log/hostname/  12c ORACLE_BASE/crsdata/host_name/output/*trc  /u01/app/grid/diag/crs/msb-dbcenter01/crs  
++ dbca trace :$ORACLE_BASE/cfgtoollogs/dbca/<DBNAME>/
++ ora.ctssd là service de dong bo thoi gian giua 2 host: observer la ke - dong bo theo ntp; active la dong bo theo RAC ctssd
		/db/oracle/11.2.0/grid/log/ingwhn1/ctssd/octssd.log
		[ctssd(13443)]CRS-2409:The clock on host node2 is not synchronous with the mean cluster time. No action has been taken as the Cluster Time Synchronization Service is running in observer mode.
able H-1 Locations of Oracle Clusterware Component Log Files Component	Log File LocationFoot 1
Cluster Ready Services Daemon (CRSD) Log Files 	Grid_home/log/host_name/crsd
Cluster Synchronization Services (CSS) 	Grid_home/log/host_name/cssd                ------------> interconnect
Cluster Time Synchronization Service (CTSS) 	Grid_home/log/host_name/ctssd
Grid Plug and Play 	Grid_home/log/host_name/gpnpd
Multicast Domain Name Service Daemon (MDNSD) 	Grid_home/log/host_name/mdnsd
Oracle Cluster Registry 	
ora.ons	/u01/app/evsdr/grid/opmn/logs/ons.log
config for ora.ons /u01/app/evsdr/grid/opmn/conf/ons.config
Oracle Cluster Registry tools (OCRDUMP, OCRCHECK, OCRCONFIG) record log information in the following location:Foot 2
crfmond.log cho crv
Grid_home/log/host_name/client

Cluster Ready Services records Oracle Cluster Registry log information in the following location:

Grid_home/log/host_name/crsd
Oracle Grid Naming Service (GNS) 	Grid_home/log/host_name/gnsd
Oracle High Availability Services Daemon (OHASD) 	Grid_home/log/host_name/ohasd
Event Manager (EVM) information generated by evmd 	Grid_home/log/host_name/evmd
Oracle RAC RACG	

The Oracle RAC high availability trace files are located in the following two locations:

Grid_home/log/host_name/racg

$ORACLE_HOME/log/host_name/racg

Core files are in subdirectories of the log directory. Each RACG executable has a subdirectory assigned exclusively for that executable. The name of the RACG executable subdirectory is the same as the name of the executable.

Additionally, you can find logging information for the VIP and database in these two locations, respectively.
Server Manager (SRVM) 	Grid_home/log/host_name/srvm
Disk Monitor Daemon (diskmon) 	Grid_home/log/host_name/diskmon
Grid Interprocess Communication Daemon (GIPCD) 	Grid_home/log/host_name/gipcd


++Where are the traces/logs of ora.cvu located?
		The logs related to ora.cvu are located under <GRID_HOME>/log/<node>/cvu/.
		There are two directories underneath: one for log file s(cvulog) and one for trace files (cvutrc).
		For 12.1.0.2 onward, it's in <ORACLE_BASE>/crsdata/<node>/cvu/cvulog and <ORACLE_BASE>/crsdata/<node>/cvu/cvutrc
		
-------------------chungtc chay root.sh
[root@drt24rpt2db01:/]# /oracle/app/grid/11.2.0.3/bin/crsctl modify res ora.cluster_interconnect.haip -attr "ENABLED=1" -init
	/oracle/app/grid/11.2.0.3/bin/crsctl start resource ora.cluster_interconnect.haip -init
Khi chay root sh thi co the xem log trong $gridhome/log/<hostname>/alert<hostname>.log		
---- chungtc rac trace log--------------
root@evs-db02 # cd /app                    
root@evs-db02 #  find . -name *d.trc -print

$grid_base/diag/crs/evs-db02/crs/trace/ohasd.trc
$grid_base/diag/crs/evs-db02/crs/trace/ohasd_oraagent_grid.trc
$grid_base/diag/crs/evs-db02/crs/trace/evmd.trc
$grid_base/diag/crs/evs-db02/crs/trace/mdnsd.trc
$grid_base/diag/crs/evs-db02/crs/trace/gpnpd.trc
$grid_base/diag/crs/evs-db02/crs/trace/gipcd.trc
$grid_base/diag/crs/evs-db02/crs/trace/ocssd.trc
$grid_base/diag/crs/evs-db02/crs/trace/octssd.trc
$grid_base/diag/crs/evs-db02/crs/trace/osysmond.trc
$grid_base/diag/crs/evs-db02/crs/trace/crsd.trc
$grid_base/diag/crs/evs-db02/crs/trace/crsd_oraagent_grid.trc


----------------- khai niem trong rac ------------------
CRS: Cluster Ready Service, name for pre-11gR2 Oracle clusterware

GI: Grid Infrastructure, name for 11gR2 Oracle clusterware

GI cluster: Grid Infrastructure in cluster mode

Oracle Restart: GI Standalone, Grid Infrastructure in standalone mode

ASM user: the OS user who installs/owns ASM. For 11gR2, ASM and grid user is the same as ASM and GI share the same ORACLE_HOME. For pre-11gR2 CRS cluster, ASM and CRS user can be different as ASM and CRS will be in different ORACLE_HOME. For pre-11gR2 single-instance ASM, ASM and local CRS user is the same as ASM and local CRS share the same home.

CRS user: the OS user who installs/owns pre-11gR2 Oracle clusterware

grid user: the OS user who installs/owns 11gR2 Oracle clusterware

clusterware user: CRS or grid user which must be the same in upgrade environment

Oracle Clusterware software owner: same as clusterware user

clusterware home: CRS or GI home 

ORACLE_BASE:ORACLE_BASE for grid or CRS user.

 

root script checkpoint file: the file that records root script (root.sh or rootupgrade.sh) progress so root script can be re-executed, it's located in $ORACLE_BASE/Clusterware/ckptGridHA_${nodename}.xml

OCR: Oracle Cluster Registry. To find out OCR location, execute: ocrcheck

VD: Voting Disk. To find out voting file location, execute: crsctl query css votedisk

Automatic OCR Backup: OCR is backed up automatically every four hours in cluster environment on OCR Master node, the default location is <clusterware-home>/cdata/<clustername>. To find out backup location, execute: ocrconfig -showbackup

SCR Base: the directory where ocr.loc and olr.loc are located.


------- khi cai dat chay root.sh---------------
root@evs-db02 # /app/newrac/11.2.0/grid/root.sh
Performing root user operation for Oracle 11g 

The following environment variables are set as:
    ORACLE_OWNER= grid
    ORACLE_HOME=  /app/newrac/11.2.0/grid

Enter the full pathname of the local bin directory: [/usr/local/bin]: 
The contents of "dbhome" have not changed. No need to overwrite.
The contents of "oraenv" have not changed. No need to overwrite.
The contents of "coraenv" have not changed. No need to overwrite.

Entries will be added to the /var/opt/oracle/oratab file as needed by
Database Configuration Assistant when a database is created
Finished running generic part of root script.
Now product-specific root actions will be performed.
Using configuration parameter file: /app/newrac/11.2.0/grid/crs/install/crsconfig_params


++Verfiy currently used networks by RAC using by grid user
$ oifcfg getif 
eth1  192.168.1.0  global  public
eth2  192.168.2.0  global  cluster_interconnect
-> We only use eth2 interface for cluster_interc
++Verify the new network with oifcfg iflist
$ oifcfg iflist
++ check private rac interconnect rac
select        
     inst_id,
     name,
     ip_address
  from
     gv$cluster_interconnects;
+++++++++++++++++++++++++++++++++++++++++++
srvctl config listener -asmlistener

srvctl config asm	 
------------- chungtc Starting Redo Apply ----------------------------------
To start apply services on a physical standby database, ensure the physical standby database is started and mounted and then start Redo Apply using the SQL ALTER DATABASE RECOVER MANAGED STANDBY DATABASE statement.

You can specify that Redo Apply runs as a foreground session or as a background process, and enable it with real-time apply.

To start Redo Apply in the foreground, issue the following SQL statement:

SQL> ALTER DATABASE RECOVER MANAGED STANDBY DATABASE;
If you start a foreground session, control is not returned to the command prompt until recovery is canceled by another session.

To start Redo Apply in the background, include the DISCONNECT keyword on the SQL statement. For example:

SQL> ALTER DATABASE RECOVER MANAGED STANDBY DATABASE DISCONNECT;
This statement starts a detached server process and immediately returns control to the user. While the managed recovery process is performing recovery in the background, the foreground process that issued the RECOVER statement can continue performing other tasks. This does not disconnect the current SQL session.

To start real-time apply, include the USING CURRENT LOGFILE clause on the SQL statement. For example:

SQL> ALTER DATABASE RECOVER MANAGED STANDBY DATABASE USING CURRENT LOGFILE;
recover automatic standby database;

ALTER DATABASE RECOVER MANAGED STANDBY DATABASE DELAY 60 disconnect; -- apply delayed for 60 minutes.


7.3.2 Stopping Redo Apply
To stop Redo Apply, issue the following SQL statement in another window:

SQL> ALTER DATABASE RECOVER MANAGED STANDBY DATABASE CANCEL;


KIEM TRA LAI
SELECT RECOVERY_MODE FROM V$ARCHIVE_DEST_STATUS;
-------------chungtc dgmgrl dataguard broker ----------------------------
dgmgrl /
connect sys/sys
show configuration  verbose;
show database verbose cdb03_stby;
				Database - kmtd5                                     
				                                                     
				  Role:            PHYSICAL STANDBY                  
				  Intended State:  APPLY-ON                          
				  Transport Lag:   0 seconds (computed 0 seconds ago)  ## tu primary transport sang co lag ko?
				  Apply Lag:       1 second (computed 0 seconds ago) 	## standby dang apply log co lag ko
				  Apply Rate:      25.34 MByte/s                     
				  Real Time Query: ON                                
				  Instance(s):                                       
				
				
				
				
				
show database verbose dbtestracdr;
show instance verbose evs21 on database evs2;
edit database 'dbtestracdr' SET PROPERTY  LogFileNameConvert='';
SHOW DATABASE dbtestdr_dr 'StatusReport';   
 SHOW INSTANCE VERBOSE dbtest     
DGMGRL> edit database 'pps1_stb' set state='APPLY-OFF'
Equivalent Broker Commands to 'ALTER SYSTEM'
SQL> alter database recover managed standby database cancel;
DGMGRL> edit database 'stby_dbname' set state='LOG-APPLY-OFF';

SQL> alter database recover managed standby database disconnect;
DGMGRL> edit database 'stby_dbname' set state='ONLINE';
## A HAI SVTECH RESTORE DATABASE CLUSTER='TRUE' ROI THUC HIEN LUON
ALTER DATABASE RECOVER MANAGED STANDBY DATABASE  THROUGH ALL SWITCHOVER DISCONNECT  USING CURRENT LOGFILE

SQL> alter system set log_archive_max_processes=4;
DGMGRL> edit database 'dbname' set property 'LogArchiveMaxProcesses'=4;

SQL> alter system set log_archive_dest_state_2='enable' scope=both;
DGMGRL> edit database 'stby_dbname' set property 'LogShipping'='ON';

SQL> alter system set log_archive_dest_state_2='defer' scope=both;
DGMGRL> edit database 'stby_dbname' set property 'LogShipping'='OFF';

DGMGRL> edit database 'pri_dbname' set state='LOG-TRANSPORT-OFF';
This will defer all standby databases

DGMGRL> EDIT DATABASE devdb SET PROPERTY 'DbFileNameConvert' = '/u01/od01/datafile/, /oradisk/od01/datafile/';

========= loi mat label cua oracleasm
[root@warm-data-ors iid]# blkid
/dev/sdc1: TYPE="oracleasm" 
/dev/sdd1: TYPE="oracleasm" 
/dev/sdj1: LABEL="ORCVOTE02" TYPE="oracleasm" 
/dev/sdf1: TYPE="oracleasm"    # mat LABEL nay?

crsctl stop crs. Sau do lam vs user root:
oracleasm renamedisk -f /dev/sdf1 ARCHIVE01
asmtool -I -l "/dev/oracleasm" -n /dev/sdi1 -a label
asmtool: Disk "/dev/sdi1" is marked an ASM disk with the label "ORCVOTE01"
oracleasm scandisks
oracleasm listdisks
------------- CHUNGTC ORACLE RAC ----------------------------
sqlplus IBS/\"iBs@2017\"
sqlplus sys/<password>@<tns_alias> as sysdba
sqlplus 'evs2_owner/evs2016@(DESCRIPTION=(ADDRESS = (PROTOCOL = TCP)(HOST = 10.151.248.99)(PORT = 1521))(ADDRESS = (PROTOCOL = TCP)(HOST = 10.151.248.100)(PORT = 1521))(LOAD_BALANCE = yes)(CONNECT_DATA =(SERVER = DEDICATED)(SERVICE_NAME = stbyedb.vms.com.vn)))'
sqlplus 'SARS/telsoft1234@(DESCRIPTION=(ADDRESS=(PROTOCOL=TCP)(HOST=10.50.8.250)(PORT=1521))(CONNECT_DATA=(SID=pttb1)))'
sqlplus dbsnmp/mb#123dba@${strarr[1]}:1521/${strarr[2]}
--a hai svtech : stop cluster 
/app/newrac/grid/bin/crsctl  stop cluster -all
/app/11.2.0/grid/bin/crsctl check cluster -all
-- add physical db -d la dbunique name
srvctl -h
srvctl add database -d t24drnew -r PHYSICAL_STANDBY -o /oracle/app/oracle/product/19c -s "READ ONLY"  
/oracle/app/oracle/product/12.2.0.1/bin/srvctl  add instance -d t24drnew -i t24cob1 -n dr-r20db01
/oracle/app/oracle/product/12.2.0.1/bin/srvctl  add instance -d t24drnew -i t24cob2 -n dr-r20db02
srvctl modify database -d t24drnew -p +DATA/t24drnew/spfile.ora
srvctl modify instance -d t24vndlmdc -n dc-r20-dbro1 -o /oracle/app/oracle/product/19.11
srvctl modify database -d t24cob  -o /oracle/app/oracle/product/19c_new

+DATA/t24cob/spfilet24vn.ora


/oracle/app/oracle/product/12.2.0.1/bin/srvctl  config database -d owproddr 
srvctl start database -d owproddr -i owprod1

srvctl start instance -d owproddr -node drway4db01
srvctl start instance -d owproddr -node drway4db02

 45298483 

--------
/app/grid/12.1/grid/bin/srvctl modify scan -scanname evs-scan
srvctl status scan
srvctl config scan

-- add primary db tren rac
srvctl add database -d ewalletdr -o /u01/app/oracle/product/19c/dbhome_4
srvctl add instance -d ewalletdr -i ewallet1 -n drexaclient01
srvctl add instance -d ebank -i ebank3 -n dcexadbadm02
srvctl config database -d ewalletdr


srvctl start database -d ewalletdr -o "READ ONLY"
alter system set job_queue_processes=0 scope=both sid='*';

-- ad primary db tren oracle restart
srvctl add database -d cdbn_aux -o /u01/app/oracle/product/12.2.0/db_1 -i cdbn_aux
-- add primary db serverpool
srvctl status srvpool
srvctl status srvpool -serverpool  dc_msbsrv_p1 -detail
srvctl add database -db dbg6stb -oraclehome /u01/app/oracle/product/12.1.0/dbhome_1 -dbtype RAC -dbname dbg6 -serverpool "dc_msbsrv_p1" 
srvctl start instance -d dbg6stb -node dc-msbsrv02

-- nhieu khi bi loi listerner ko nhan   HOST= ip vat ly cua host SID=ps -ef|grep smon
alter system set local_listener='(ADDRESS=(PROTOCOL=TCP)(HOST=10.1.7.150)(PORT=1521))' scope=both sid='aictrpt';
alter system set local_listener='(ADDRESS=(PROTOCOL=TCP)(HOST=10.2.8.168)(PORT=1521))' scope=both sid='ecmscadr1';
==================add service tren serverpool
srvctl add service -d dbg6stb -service basel -pdb basel2 -serverpool dc_msbsrv_p1
  srvctl config service -d dbg6stb -s  basel
  srvctl status service -d dbg6stb -s  basel

==============add service 
-----TAC
  srvctl add service -db mbods -service ods_user -preferred mbods1,mbods2 -failover_restore AUTO -failoverretry 1 -failoverdelay 3 -commit_outcome TRUE -failovertype AUTO -replay_init_time 600 -retention 86400 -notification TRUE -drain_timeout 300 -stopoption IMMEDIATE   
  srvctl start service -d mbods -s  ods_user
  ODS_LIVE =
  (DESCRIPTION =
  (CONNECT_TIMEOUT=5)(TRANSPORT_CONNECT_TIMEOUT=3)(RETRY_COUNT=3)
  (ADDRESS_LIST =(load_balance=YES) (FAILOVER=YES)
  (ADDRESS = (PROTOCOL = TCP)(HOST = 10.1.9.133)(PORT = 1521))
  (ADDRESS = (PROTOCOL = TCP)(HOST = 10.1.9.134)(PORT = 1521))
  (ADDRESS = (PROTOCOL = TCP)(HOST = 10.1.9.135)(PORT = 1521))
   )
  (CONNECT_DATA =
  (SERVER = DEDICATED)
  (SERVICE_NAME = ods_user)
  )
)


------- NORMAL
. cmsprod 
 /u01/app/12.2.0/grid//bin/srvctl add service -d mbods -s ods_user -r cmsprod2 -a cmsprod1  --uu tien service chay instance 2
srvctl relocate service -db apps -service crm -oldinst apps1 -newinst apps3			-- relocate service crm tu apps1 sang apps3
 /u01/app/12.2.0/grid//bin/srvctl start service -d cmsprodnew -s BATCH_cmsprodnew
  srvctl config service -d cmsprodnew -s  batch_cmsprodnew
     srvctl start service -d cmsprodnew -s  batch_cmsprodnew

 -- add service thong thuong
 srvctl add service -d mbods -s ods_user -pdb p_dsb -preferred cdb101,cdb102
  srvctl add service -d mbods -s ods_batchjob -preferred mbods1,mbods2

 srvctl add service -db cdb10 -service dsb -preferred cdb101,cdb102 -tafpolicy BASIC -policy AUTOMATIC -failovertype SELECT -failovermethod BASIC  -failoverretry 5 -pdb p_dsb -verbose 
   srvctl start service -d mbods -s  ods_batchjob

 srvctl config service -d cdb10 -s  dsb
  srvctl status service -d cdb10 -s  dsb
  srvctl stop service -d cdb10 -s  dsb
    srvctl stop service -d cdb10 -s  dsb -n msb-dbcenter01
    srvctl start service -d cdb10 -s  dsb -n msb-dbcenter01

	
  srvctl remove service -d mbods -s  odsuser

 srvctl start service -d cdb10 -s dsb


---------- add service bang thu tuc database
ALTER PLUGGABLE DATABASE ALL SAVE STATE;
-- xoa casc service
SELECT SERVICE_ID,NAME,NETWORK_NAME,CREATION_DATE,PDB,CON_ID  FROM CDB_SERVICES;
exec dbms_service.delete_service('examicrodb');
BEGIN
  DBMS_SERVICE.create_service(
    service_name => 'khdn_pdb_service',
    network_name => 'khdn_pdb_service'
  );
END;
/
select * from gv$services;
SELECT * FROM   gv$active_services ORDER BY 1;

-- sau khi add service thi fai start tren tung instance 
BEGIN
  DBMS_SERVICE.start_service(
    service_name => 'ONBEHALFPAYMENT_service'
  );
END;
/

BEGIN
  DBMS_SERVICE.stop_service(
    service_name => 'ONBEHALFPAYMENT_service'
  );
END;
/
 
================== oracle flex asm http://ora-srv.wlv.ac.uk/oracle19c_doc/ostmg/manage-flex-asm.html#GUID-545C311D-24C6-421A-ACBE-CA29E1FDA0A6
srvctl config listener -asmlistener
oifcfg setif -global en2/172.17.91.0:cluster_interconnect,asm
/oracle/app/grid/19c/bin/srvctl  add asmnetwork -netnum 2 -subnet 172.17.91.0/255.255.255.0
srvctl add listener -asmlistener -netnum 2 -listener ASMNET1LSNR_ASM
srvctl modify asmnetwork -netnum 1 -deptype optional

 
--- kiem tra list
alter system set  local_listener   ='(ADDRESS=(PROTOCOL=TCP)(HOST=10.0.17.25)(PORT=1521))' scope=both sid='*';
alter system set  remote_listener   ='carddb-scan.msb.com.vn:1521' scope=both sid='*';
oracle.cmsprod1@carddb01: nslookup carddb-scan.msb.com.vn
Server:         10.1.16.1
Address:        10.1.16.1#53

Name:   carddb-scan.msb.com.vn
Address: 10.1.72.88
Name:   carddb-scan.msb.com.vn
Address: 10.1.72.86
Name:   carddb-scan.msb.com.vn
Address: 10.1.72.87
  ====
srvctl modify database -d KMTD5 -s "read only"
		oracle@HN196-KMTD-A # srvctl config database -d kmtd5
		Database unique name: kmtd5
		Database name: 
		Oracle home: /u01/app/oracle/product/11.2.0/dbhome_1
		Oracle user: oracle
		Spfile: 
		Domain: 
		Start options: read only
		Stop options: immediate
		Database role: PHYSICAL_STANDBY
		Management policy: AUTOMATIC
		Database instance: kmtd5
		Disk Groups: DATA
		Services: 
srvctl remove database -d "test"		-- xoa khoi srvctl nhung ko lam mat db
-- xem status cua scan listener
srvctl status scan_listener
### stop listener
srvctl config listener
srvctl start listener -n evs-db01
srvctl relocate scan_LISTENER -i 1 -n evs-db02
#show cluster config -- kiem tra trang thai cua cluster
crsctl stat res -p
crsctl modify resource ora.APS1.dg -attr AUTO_START=always
$GRID_HOME/bin/crsctl start res ora.crsd -init

crsctl stat res -t
crsctl stat res -t -init
crsctl status resource -t
crsctl status resource ora.LISTENER.lsnr
crsctl status resource ora.ons -p    -- xem chi tiet cau hinh
crsctl modify res ora.orcl.db -attr "RESTART_ATTEMPTS=1"
crsctl stop resource ora.LISTENER.lsnr
/db/soft/122/bin/crsctl delete resource ora.crsd -init -f

srvctl stat res ora.ons -t
srvctl start  ons 
[oracle@drexaclient02 ~]$ srvctl start asm -proxy -n drexaclient02
[oracle@drexaclient02 ~]$ srvctl status asm -proxy
crsctl status res ora.chad
srvctl start cha

alter system reset db_file_name_convert scope=spfile sid='*';
ALTER SYSTEM RESET audit_syslog_level SCOPE=SPFILE sid='*';
# database name
	show parameter db_name;  -- SID = the unique name of your DB
	show parameter service_names; -- ServiceName = the alias used when connecting
	select name from v$database;
	select sys_context('userenv','db_name') from dual;
	select ora_database_name from dual;
# which instance is connecting
	select host_name from gv$instance where instance_number=userenv('instance');
# select instance_name, hostname of RAC
	select instance_name, host_name, archiver, thread#, status from gv$instance;
	select instance from v$thread;	
#Nodeapps:
	olsnodes -n -i -s -t
	srvctl status nodeapps -n nodename
	srvctl config nodeapps -n nodename

#ASM:
	srvctl status asm -n ingwhn2
	srvctl config asm -n nodename

#Database:
	srvctl status database -d orcl  (dbname)
	srvctl config database -d ocsg (shows instances name, node and oracle home)
#Instance:
	srvctl status instance -d ocsg -i ocsg2

#Services:
	srvctl status service -d charging

	select instance_name, host_name, archiver, thread#, status from gv$instance;
	select file_name, bytes/1024/1024 from dba_data_files;
	select group#, type, member, is_recovery_dest_file  from v$logfile  order by group#;

#Querying the v$asm_diskgroup view...
	select group_number, name,allocation_unit_size alloc_unit_size,state,type,total_mb,REQUIRED_MIRROR_FREE_MB,usable_file_mb from v$asm_diskgroup;
		Total Raw Size (TRS)
		Used Raw Size (URS)
		Free Raw Size (FRS)
		Total Allocatable Size (TAS) => TRS / Redundancy Factor ( tong dung luong CO THE cap phat )
		Used Allocatable Size (UAS) => URS / Redundancy Factor ( tong dung luong DA cap phat)
		Free Allocatable Size (FAS) => FRS / Redundancy Factor ( tong dung luong CON free )
		Size Needed for Disk Failure Coverage (SNDFC) => Largest Disk (or 2 Disks for High R.)
		Size Needed for Cell Failure Coverage (SNCFC) => Largest Cell (or 2 Cells for High R.)
		Total Disk Failure Safe Allocatable Size => (TRS - SNDFC) / Redundancy Factor
		Total Cell Failure Safe Allocatable Size => (TRS - SNCFC) / Redundancy Factor
		Free Disk Failure Safe Allocatable Size => (FRS - SNDFC) / Redundancy Factor
		Free Cell Failure Safe Allocatable Size => (FRS - SNCFC) / Redundancy Factor

	
#Querying v$asm_disk for our volumes (remember the ones we created first on OS level with the asmlib) :
	select name, path, header_status, total_mb free_mb, trunc(bytes_read/1024/1024) read_mb, trunc(bytes_written/1024/1024) write_mb from v$asm_disk;
#datafile
	select name from v$datafile union  select name from v$controlfile  union  select name from v$tempfile union  select member from v$logfile;
#Listing all the tablespaces...
	select tablespace_name, file_name
	from dba_data_files
	union
	select tablespace_name, file_name
	from dba_temp_files ;
###khi bi day netstat -na a Hoc
grid$ crs_stop ora.ons
### de vao oracle db OCSG, xem duong dan alert.log
. .profile_rac 
sqlplus / as sysdba
show parameter dia;
### de vao oracle asm OCSG, xem duong dan asm alert.log
su - grid
sqlplus / as sysasm
show parameter dia;


# find location cluster clock
ps -ef|grid 
cd /u01/11.2.0/grid/log/db01/ctssd
----------------------------------check retention cua SYSAUX ---------------SYSAUX tang chong mat https://support.oracle.com/epmos/faces/DocumentDisplay?_afrLoop=223541272217004&parent=EXTERNAL_SEARCH&sourceId=PROBLEM&id=454678.1&_afrWindowMode=0&_adf.ctrl-state=80daic7re_110
SELECT extract(day from snap_interval)*24*60+extract(hour from snap_interval)*60+extract(minute from snap_interval) snapshot_Interval,
extract(day from retention)*24*60+extract(hour from retention)*60+extract(minute from retention) retention_Interval
FROM dba_hist_wr_control;

select dbms_stats.get_stats_history_retention from dual;
select dbms_stats.get_stats_history_availability from dual;

  select OCCUPANT_NAME,OCCUPANT_DESC,SPACE_USAGE_KBYTES/1024/1024
      from V$SYSAUX_OCCUPANTS
      order by SPACE_USAGE_KBYTES desc;
select trunc(SAVTIME),count(1) from WRI$_OPTSTAT_HISTHEAD_HISTORY group by  trunc(SAVTIME) order by 1;	


-- thay doi retention 
exec dbms_stats.alter_stats_history_retention(28);
-- xoa bot partition cu hon 31 ngay cua bang WRI$_OPTSTAT_HISTHEAD_HISTORY
exec DBMS_STATS.PURGE_STATS(SYSDATE-28);
  
+++++++++++++++++++++++++++++++MVIEW++++++++++++++++++++++++++++++++++++++
###
select * from all_mviews;
select  master, log, temp_log from sys.mlog$ ;
###Script to List Materialized Views Dependent on Specific Tables
				REM LOCATION:   Object Management\Materialized Views and Materialized View Logs
				REM FUNCTION:   Find dependent tables for a given MView
				REM TESTED ON:  10.2.0.3, 11.1.0.6
				REM PLATFORM:   non-specific
				REM REQUIRES:   dbms_metadata
				REM
				REM  This is a part of the Knowledge Xpert for Oracle Administration library.
				REM  Copyright (C) 2008 Quest Software
				REM  All rights reserved.
				REM
				REM ******************** Knowledge Xpert for Oracle Administration ********************
				UNDEF ENTER_OWNER_NAME
				UNDEF ENTER_TABLE_NAME
				SET serveroutput on
				SET feedback off
				
				DECLARE
				   v_output   VARCHAR2 (2000);
				   v_owner    VARCHAR2 (30);
				   v_table    VARCHAR2 (30);
				BEGIN
				   v_owner := UPPER ('&&ENTER_OWNER_NAME');
				   v_table := UPPER ('&&ENTER_TABLE_NAME');
				   dbms_mview.get_mv_dependencies (v_owner || '.' || v_table, v_output);
				   DBMS_OUTPUT.put_line (CHR (13));
				   DBMS_OUTPUT.put_line
				      ('Materialized Views Dependent on table      &&ENTER_OWNER_NAME..&&ENTER_TABLE_NAME'
				      );
				   DBMS_OUTPUT.put_line (CHR (13));
				   DBMS_OUTPUT.put_line (v_output);
				END;
				/
#################create mview
ALTER SESSION SET CURRENT_SCHEMA=MSB;
create materialized view log on ACCOUNT_MASK with rowid ,sequence;
create materialized view log on ACNT_CONTRACT with rowid ,sequence;
create materialized view log on DOC with rowid   ,sequence;
create materialized view log on M_TRANSACTION with rowid ,sequence;


CREATE MATERIALIZED VIEW chungtc_MV
 REFRESH  ON DEMAND complete
AS
SELECT ISS_CONTRACT.CONTRACT_NUMBER AS CONTRACT_NUMBER,
       D.TARGET_NUMBER AS CARD_NUMBER,
       D.SETTL_AMOUNT,
       D.POSTING_DATE,
       D.TRANS_AMOUNT,
       M.TRANS_AMOUNT AS M_AMOUNT,
       SOURCE.ACCOUNT_MASK_NAME AS SOURCE,
       TARGET.ACCOUNT_MASK_NAME AS TARGET,
       D.rowid as Drowid,
       ISS_CONTRACT.rowid as ISS_CONTRACTrowid,
       CARD.rowid as cardrowid,
       m.rowid as mrowid,
       target.rowid as targetrowid,
       SOURCE.rowid as sourcerowid       
  FROM ACNT_CONTRACT ISS_CONTRACT,
       ACNT_CONTRACT CARD,
       DOC D,
       M_TRANSACTION M,
       ACCOUNT_MASK TARGET,
       ACCOUNT_MASK SOURCE
 WHERE     CARD.ACNT_CONTRACT__OID = ISS_CONTRACT.ID
       AND D.TARGET_NUMBER = CARD.CONTRACT_NUMBER
       AND D.ID = M.DOC__OID
       AND M.TARGET_ACCOUNT_MASK = TARGET.ID
       AND M.SOURCE_ACCOUNT_MASK = SOURCE.ID
       AND D.POSTING_DATE >=
              trunc (ISS_CONTRACT.LAST_BILLING_DATE)
       AND REPLACE (UPPER (SOURCE.ACCOUNT_MASK_NAME), ' ', '') IN ('CLDEPOSIT')
       AND REPLACE (UPPER (TARGET.ACCOUNT_MASK_NAME), ' ', '') IN ('OVD',
                                                              'OVDFEE',
                                                              'OVD30',
                                                              'OVD30FEE');
-----
ALTER SESSION SET CURRENT_SCHEMA=MSB;
create materialized view log on ACCOUNT_MASK with rowid (ACCOUNT_MASK_NAME),sequence;
create materialized view log on ACNT_CONTRACT with rowid(ID,LAST_BILLING_DATE,ACNT_CONTRACT__OID) ,sequence;
create materialized view log on DOC with rowid(TARGET_NUMBER,SETTL_AMOUNT,POSTING_DATE,TRANS_AMOUNT,ID)   ,sequence;
create materialized view log on M_TRANSACTION with rowid(DOC__OID,TARGET_ACCOUNT_MASK ,SOURCE_ACCOUNT_MASK) ,sequence;


CREATE MATERIALIZED VIEW chungtc_MV
 REFRESH  ON DEMAND FAST
ENABLE QUERY REWRITE
ENABLE ON QUERY COMPUTATION
AS
SELECT ISS_CONTRACT.CONTRACT_NUMBER AS CONTRACT_NUMBER,
       D.TARGET_NUMBER AS CARD_NUMBER,
       D.SETTL_AMOUNT,
       D.POSTING_DATE,
       D.TRANS_AMOUNT,
       M.TRANS_AMOUNT AS M_AMOUNT,
       SOURCE.ACCOUNT_MASK_NAME AS SOURCE,
       TARGET.ACCOUNT_MASK_NAME AS TARGET,
       D.rowid as Drowid,
       ISS_CONTRACT.rowid as ISS_CONTRACTrowid,
       CARD.rowid as cardrowid,
       m.rowid as mrowid,
       target.rowid as targetrowid,
       SOURCE.rowid as sourcerowid       
  FROM ACNT_CONTRACT ISS_CONTRACT,
       ACNT_CONTRACT CARD,
       DOC D,
       M_TRANSACTION M,
       ACCOUNT_MASK TARGET,
       ACCOUNT_MASK SOURCE
 WHERE     CARD.ACNT_CONTRACT__OID = ISS_CONTRACT.ID
       AND D.TARGET_NUMBER = CARD.CONTRACT_NUMBER
       AND D.ID = M.DOC__OID
       AND M.TARGET_ACCOUNT_MASK = TARGET.ID
       AND M.SOURCE_ACCOUNT_MASK = SOURCE.ID
       AND D.POSTING_DATE >=
              trunc (ISS_CONTRACT.LAST_BILLING_DATE)
       AND REPLACE (UPPER (SOURCE.ACCOUNT_MASK_NAME), ' ', '') IN ('CLDEPOSIT')
       AND REPLACE (UPPER (TARGET.ACCOUNT_MASK_NAME), ' ', '') IN ('OVD',
                                                              'OVDFEE',
                                                              'OVD30',
                                                              'OVD30FEE');

EXEC DBMS_STATS.gather_table_stats('MSB', 'CHUNGTC_MV');

----

EXEC DBMS_STATS.gather_table_stats('MSB', 'CHUNGTC_MV');
select * from chungtc_MV;

@/u01/app/oracle/product/12.2.0/dbhome_1/rdbms/admin/utlxmv.sql
exec dbms_mview.explain_mview('MSB.CHUNGTC_MV');
select * from sys.MV_CAPABILITIES_TABLE;
				
+++++++++++++++++++++++++++++++++++++ Oracle Golden Gate +++++++++++++++++++++++++++++++++++++++++++++++++++++++
ps -ef|grep gg
ps -ef |grep server
cd /u01/oracle/goldengate  -> file log ggserr.log
./ggsci   
INFO MGR
view report mgr
VIEW PARAMS ./GLOBAL
view PARAMS MGR  -- xem tham so manager
stats ER *
STATUS ER *
Info all
INFO REPLICAT REP_OCSG DETAIL
view PARAMS REP_OCSG
view report groups
lag REP_GOLD 
stats REPLICAT REP_OCSG
info rep rep detail  -- xem thong tin thu muc chua file trail
view params mgr  -- xem thong tin giu file trail trong may ngay
INFO RMTTRAIL *
info replicat *
-- start len
START REPLICAT REP_OCSG
START REPLICAT REP_OCSG SKIPTRANSACTION bo qua loi cuoi cung
START REPLICAT REP_MVAS AFTERCSN 11863434400906 -- start len tu sau CSN la ket qua cua select to_char(dbms_flashback.get_system_change_number) from dual;
--- delete
DBLOGIN USERID goldgate, PASSWORD goldgate
add checkpointtable TEST_ggate.TESTcheckpoint
delete replicat rep_ic
----------------- binhtv tinh cuoc -------------
GGSCI (vaspdb02) 10> stop goldrep
GGSCI (vaspdb02) 12> info goldrep

REPLICAT   GOLDREP   Last Started 2018-05-09 01:06   Status STOPPED
Checkpoint Lag       00:00:00 (updated 00:00:25 ago)
Log Read Checkpoint  File /ggate/dirdat/goldrmt/rm000285
                     2018-05-09 11:22:55.704367  RBA 1280

GGSCI (vaspdb02) 13> alter goldrep extseqno 286 extrba 0
GGSCI (vaspdb02) 14> start goldrep                     
-------- send manager
SEND MANAGER GETPORTINFO DETAIL
DYNAMICPORTLIST specifies up to 256 entries for ports to be dynamically assigned to processes started by Manager. If no dynamic ports are specified, Manager will start with 7840 and increment until it finds an available port.
Oracle GoldenGate Director Server connects to remote Oracle GoldenGate instances
through each of their Manager ports. If a firewall is present within the Oracle GoldenGate
network, do the following:
1. Use the DYNAMICPORTLIST parameter in each Manager parameter file to specify a list of
available ports. For usage and syntax, see the Oracle GoldenGate Windows and UNIX
Reference Guide or the Oracle GoldenGate HP NonStop Reference Guide, as
appropriate for the platform.
2. Open those ports, plus the Manager port and the Oracle GoldenGate Director Server
http port, through the firewall.
2018-02-28 12:39:04  INFO    OGG-00974  Oracle GoldenGate Manager for Oracle, mgr.prm:  Manager started collector process (Port 7846).

---------------- grep cac port server cua goldengate
root@ingwhn2 # ps -ef|grep server
  oracle 25123  3622   0   Feb 28 ?           4:55 ./server -w 300 -p 7846 -k -l /db/ggate/ggserr.log
  oracle  1624     1   0   Feb 19 ?           3:37 ./server -w 120 -p 7845 -k -l /db/ggate/ggserr.log

$logdump
ggsci>open /db/ggate/dbtestdr/dirdat/rh000011
>pos 1003

+++++++++++++++++++++++++golden gate logdump ++++++++++++++++
FieldComp identifies records where a Compressed Update operation was written to the source database transaction log. Because most databases only write the primary key or table index data, column index, and change data to the transaction log, the majority of Update operations will be identified as FieldComp in the Trail.
GHDR ON
DETAIL ON
DETAIL DATA
fileheader detail
ggstoken detail
RECLEN length
count
n  -- next recored

++++++++ read trail goldengate
root@evs-db01 # cat /home/oracle/trail_parser.sh 
#!/bin/bash
. /export/home/oracle/.profile
TMPLOGTRAIL='temp_'`(date +%Y%m%d%H%M%S)`'.log'  ########## file log cua chuong trinh
LOGFINAL='trail_log_'`(date +%Y%m%d%H%M%S)`'.log'########## file ket qua
rm $TMPLOGTRAIL
echo $1
######## thay duong dan logdump
/acfs01/goldengate/ogg_ebank19/logdump <<EOF   
log to $TMPLOGTRAIL
open $1
count 
exit
EOF
# Get the number of records in the trail file
TF_NUMRECORDS=`cat $TMPLOGTRAIL | egrep -i "has" | cut -d" " -f4`
echo "the number of records in the trail file is " $TF_NUMRECORDS

rm temp.sh
for ((i = 1; i <= $TF_NUMRECORDS; i++)); do

   echo "n;" >> temp.sh
done 
value=`cat temp.sh`
echo "$value"
############ thay duong dan logdump
/acfs01/goldengate/ogg_ebank19/logdump <<EOF!
log to $LOGFINAL
GHDR ON
DETAIL ON
DETAIL DATA
open $1
count
$value
exit;
EOF!

======================
read_trail.sh 


GGS_HOME=/acfs01/goldengate/ogg_ebank19    #######GG home
MPWD=/home/oracle ####### noi chua script va output
LOGDUMP_OUTPUT_FILE=$MPWD/logdump_output_$1.txt         ####### ket qua doc logdump cua trail file
COUNT_OUTPUT_FILE=$MPWD/count_result.txt                ######## file interim chua so ban ghi cua trail file
TRAIL_NAME=/home/oracle/$1                          ####### trail file, la bien $1 truyen vao
rm $COUNT_OUTPUT_FILE

#dem so ban ghi cua trail file
echo "
        
        GGS_HOME=/acfs01/goldengate/ogg_ebank19		####### gghome
" > count.sh
echo 'COUNT_OUTPUT_FILE='$COUNT_OUTPUT_FILE >> count.sh
echo 'cd '$GGS_HOME >> count.sh
echo './logdump << EOF ' >> count.sh
echo 'LOG '$COUNT_OUTPUT_FILE >> count.sh
echo 'OPEN '$TRAIL_NAME  >> count.sh
echo 'COUNT'  >> count.sh
echo "exit
EOF" >> count.sh

chmod 775 $MPWD/count.sh
$MPWD/count.sh
count=`cat $COUNT_OUTPUT_FILE |grep has | awk -F ' ' '{print $4}'`
echo 'count='$count

# sau khi co so ban ghi, ta doc logdump cua trail file
echo "
        
        GGS_HOME=/acfs01/goldengate/ogg_ebank19   ########GG HOME
        " > logmine_$1.sh
        echo 'LOGDUMP_OUTPUT_FILE=/home/oracle/logdump_output_'$1 >> logmine_$1.sh  ##########
        echo 'cd '$GGS_HOME >> logmine_$1.sh
        echo './logdump << EOF ' >> logmine_$1.sh
        echo 'LOG '$LOGDUMP_OUTPUT_FILE >> logmine_$1.sh
        echo "FILEHEADER DETAIL
        GHDR ON
        DETAIL ON
USERTOKEN DETAIL " >> logmine_$1.sh

echo 'OPEN '$TRAIL_NAME  >> logmine_$1.sh

for (( i=1; i <= $count+3; ++i ))
do
    echo "next" >> logmine_$1.sh
done

echo "EOF" >> logmine_$1.sh

chmod 775 $MPWD/logmine_$1.sh
$MPWD/logmine_$1.sh
++++++++++++++++++++++ timesten cachegrid ++++++++++++++++++++++++++++++++++++++++++++
--To attach to a standalone TimesTen database to a grid:
CALL ttGridAttach (1, 'alone2','sys2',5002);
--To attach an active master database to a grid:
CALL ttGridAttach(1,'cacheact','sys1',5003,'cachestand','sys2',5004);
--To attach a standby master database to a grid:
CALL ttGridAttach(2,'cacheact','sys1',5003,'cachestand','sys2',5004);
--You can verify that a standalone database grid member is attached to the grid by calling the ttRepStateGet built-in procedure. If it is attached, you should see this output:
Command> CALL ttRepStateGet;
< IDLE, AVAILABLE >
1 row found.
-- xem info cua grid
CALL ttGridInfo;
CALL ttGridInfo('ttGrid');
CALL ttGridNodeStatus;
-- xoa moi node trong grid
CALL ttGridDetachAll();
++++++++++++++++++++++++++++++++TIMESTEN++++++++++++++++++++++++++++++++++++++++++++++++++++++++

su - ttuser
ps -ef|grep time 
cd /etc/TimesTen/tt1121/info ; cat sys.odbc.ini   -> có dsn=cachecps
cd /u01/app/TimesTen/tt1121/bin
./ttisql dsn="cachecps"
bash-3.00$ ./ttisql dsn="TT_SYSTEM"

Command> alltables;

ttDaemonLog
ttStatus

5.2.3.  Kiểm tra hoạt động của TIMESTEN
/u01/app/TimesTen/tt1121/bin/ttstatus
5.2.3.1. Kiểm tra hoạt động của TIMESTEN server
Timesten server được cài đặt ở đường dẫn: /u01/app/TimesTen/tt1121 máy chủ 10.50.15.9 đối với hệ thống Cổng giao tiếp tập trung tại Hà Nội
02 log file được cấu hình ở : /u01/app/TimesTen/tt1121/info/ (tterrors.log và ttmesg.log)
-	Start timesten
Login vào máy chủ 10.50.15.9 (HN) bằng user ttuser
#cd /u01/app/TimesTen/tt1121/bin

#./ttDaemonAdmin –start
-	Stop timesten
Login vào máy chủ 10.50.15.9 (HN) bằng user ttuser
# cd /u01/app/TimesTen/tt1121/bin
#./ttDaemonAdmin -stop
-	Kiểm tra hoạt động timesten
Kiểm tra trạng thái
Login vào máy chủ 10.50.15.9 (HN) bằng user ttuser
#cd /u01/app/TimesTen/tt1121/bin
 # ./ttadmin dsn=cacheocsg
bash-3.2$ ./ttadmin dsn=cacheocsg
RAM Residence Policy            : inUse
Replication Agent Policy        : manual
Replication Manually Started    : False
Cache Agent Policy              : manual
Cache Agent Manually Started    : True
-	Kiểm tra bằng thực hiện lệnh sql
Login vào máy chủ 10.50.15.9 (HN) bằng user ttuser
# cd /u01/app/TimesTen/tt1121/bin
#./ttisql "dsn=cacheocsg;uid=ocsg_owner"   
timesten
5.2.3.2. Kiểm tra hoạt động của TIMESTEN client
Timesten client là các thư viện được copy trên toàn bộ các máy chủ ứng dụng, đặt ở đường dẫn: /app/TimesTen/tt1121 đối với hệ thống Cổng giao tiếp tập trung tại Hà Nội
02 log file được cấu hình ở : /app/TimesTen/tt1121/info/ (tterrors.log và ttmesg.log).
Đối với timesten client có thể thực hiện kiểm tra bằng cách đăng nhập timesten vào thực hiện các câu lệnh sql:
Login vào các máy chủ cài timesten client bằng user app_user
#cd /app/TimesTen/tt1121/bin
#./ttisqlcs "dsn=cacheocsgCS;uid=ocsg_owner"


++++++++++ cac  buoc check cau hinh replicate master standby +++++++++++++
ttRepAdmin -dsn cachedbtestdr -self -list
Check that the replication agents are communicating
	ttRepAdmin -receiver -list cachedbtestdr
Check replication state: tren master cachedbtestdr check secondary, co start la ok
	Command> CALL ttReplicationStatus ('stby_cachedbtestdr');	
Check config tren master, trong List of subcriber ma latency be' la ok	
	ttRepAdmin -showconfig cachedbtestdr
xem cot latency nho va logs<=1 la duoc	
	ttRepAdmin -dsn stby_cachedbtestdr -receiver -list 

ttRepAdmin  -showstatus TT_VASP

++++++++++++++++++++++++ timesten cluster +++++++++++++++++++++++++++++++++++++
ttuser#/app/TimesTenHA/TimesTen/TT_VASP/bin/ttCWAdmin -status -dsn TT_VASP
grid#crsctl status resource TT_Activeservice_TT_VASP_app_user_TT_VASP
grid#crsctl status resource TT_Master_TT_VASP_app_user_TT_VASP_0
grid#crsctl status resource TT_Master_TT_VASP_app_user_TT_VASP_1

ttuser#/grid/product/ogi/11.2.0/bin/crsctl stop resource TT_Master_TT_VASP_app_user_TT_VASP_1
ttuser#/grid/product/ogi/11.2.0/bin/crsctl start resource TT_Master_TT_VASP_app_user_TT_VASP_1

ttuser#/app/TimesTenHA/TimesTen/TT_VASP/bin/ttCWAdmin -stop -dsn TT_VASP


========== tat timesten cluster = tay
-- tat cluster agent
./ttCWAdmin -shutdown  
-- tat ttDaemon
./ttDaemonAdmin -stop
TimesTen Daemon stopped.


++++++++++++++++++++++++++++++++ tuning db install ++++++++++++++++++++++++++++++++++
+++++++++++++++chungtc loi opatch lsinv
grid$ ./opatch lsinv
./opatch: whereis: not found
Invoking OPatch 11.2.0.1.7

Oracle Interim Patch Installer version 11.2.0.1.7
Copyright (c) 2011, Oracle Corporation.  All rights reserved.


Oracle Home       : /u01/app/evsdr/grid
Central Inventory : /u01/app/oraInventory
   from           : /var/opt/oracle/oraInst.loc
OPatch version    : 11.2.0.1.7
OUI version       : 11.2.0.3.0
Log file location : /u01/app/evsdr/grid/cfgtoollogs/opatch/opatch2018-03-20_18-00-35PM.log

List of Homes on this system:

  Home name= OraDb11g_home1, Location= "/u01/app/evsdr/dbhome"
Inventory load failed... OPatch cannot load inventory for the given Oracle Home.
Possible causes are:
   Oracle Home dir. path does not exist in Central Inventory
   Oracle Home is a symbolic link
   Oracle Home inventory is corrupted
LsInventorySession failed: OracleHomeInventory gets null oracleHomeInfo

OPatch failed with error code 73
===> ta co the thay su lech truc cua Central Inventory /u01/app/oraInventory
=> ta chinh lai root#vi /var/opt/oracle/oraInst.loc
#inventory_loc=/u01/app/oraInventory
inventory_loc=/u01/app/evsdr/oraInventory
inst_group=oinstall


================= select loi corrupt datafile ===========================
Errors in file /u01/app/database/diag/rdbms/ftphis/FTPHIS/trace/FTPHIS_j003_18088240.trc  (incident=25626):
ORA-01578: ORACLE data block corrupted (file # 18, block # 7436)
ORA-01110: data file 18: '+FTP_HIST/FTPHIS/DATAFILE/ftp_02.tbs'

SELECT tablespace_name, segment_type, owner, segment_name FROM dba_extents 
WHERE file_id=18 and 7436 BETWEEN block_id AND block_id + blocks - 1;


select * from V$DATABASE_BLOCK_CORRUPTION 

++++++++++++++++++++++++++++++ CHUNGTC QFS +++++++++++++++++ https://docs.oracle.com/cd/E51305_01/en/E42062/html/configsharedfs.htm#BABDCAHE
+++++++++++++ https://docs.oracle.com/cd/E22586_01/html/E22573/glbku.html
-- CHECK OFS IN SYSTEM
cat /etc/opt/SUNWsamfs/mcf
	root@bhttdb1 # cat /etc/opt/SUNWsamfs/mcf
		#DATA:
		#
		bhttdbu02     20     ma      bhttdbu02     on      shared
		/dev/dsk/c3t60080E50002C09CC000002474EFBF607d0s3        21     mm      bhttdbu02     on
		/dev/dsk/c3t60080E50002C09CC000002474EFBF607d0s4        22     mr      bhttdbu02     on
		
		#BKDATABASE:
		#
		bhttdbu03     30     ma      bhttdbu03     on      shared
		/dev/dsk/c3t60080E50002C09CC0000024A4EFBF65Ed0s3        31     mm      bhttdbu03     on
		/dev/dsk/c3t60080E50002C09CC0000024A4EFBF65Ed0s4        32     mr      bhttdbu03     on
		
		#BKU04
		#
		bhttdbu04     40     ma      bhttdbu04     on      shared
		/dev/dsk/c3t600507680C8002D94800000000000308d0s0        41     mm      bhttdbu04     on
		/dev/dsk/c3t600507680C8002D94800000000000308d0s1        42     mr      bhttdbu04     on
-- check trong /etc/vfstab
root@bhttdb1 # cat /etc/vfstab
			bhttdbu02       -       /oracle/data    samfs   -       no      shared
			bhttdbu03       -       /oracle/backup  samfs   -       no      shared
			bhttdbu04       -       /u04            samfs   -       no      shared

-- Check the mcf file for errors by running the sam-fsd command, and correct any errors found.
-- check cac host duoc share
grid@bhttdb2$ cat /etc/opt/SUNWsamfs/hosts.bhttdbu02.local 
bhttdb1  clusternode1-priv,bhttdb1      
bhttdb2  clusternode2-priv,bhttdb2 
grid@bhttdb2$ cat /etc/opt/SUNWsamfs/hosts.bhttdbu02
bhttdb1  clusternode1-priv,bhttdb1      1       0       server
bhttdb2  clusternode2-priv,bhttdb2      2       0

-- Use the scstat command to verify that the Sun QFS resource group is online.
metadataserver# scstat
+++++++++++++++++++++++++++++++CHUNGTC ASM ++++++++++++++++++++++++++++++++++++++++++++++++++++
============ get password file / spfile ASM
[grid@test-db01:/home/grid]$ asmcmd pwget --asm
+OCRVOTE/orapwASM
[grid@test-db01:/home/grid]$ asmcmd spget
+OCRVOTE/test-db-clus/ASMPARAMETERFILE/registry.253.1089317085
================drop file asm =====================
sqlplus / as sysasm
 SET LONG 1000000
SET LONGCHUNKSIZE 1000000
SET LINESIZE 1000
SET PAGESIZE 0
SET TRIM ON
SET TRIMSPOOL ON
SET ECHO OFF
SET FEEDBACK OFF
SPOOL  dropfile1.sql
SELECT    'alter diskgroup '
       || gname
       || ' drop file '''
       || full_alias_path
       || ''';'
  FROM (    SELECT gname,
                   CONCAT ('+' || gname, SYS_CONNECT_BY_PATH (aname, '/'))
                      full_alias_path,
                   system_created
              FROM (SELECT g.name gname,
                           a.parent_index pindex,
                           a.name aname,
                           a.reference_index rindex,
                           a.system_created
                      FROM v$asm_alias a, v$asm_diskgroup g
                     WHERE a.group_number = g.group_number)
        START WITH (MOD (pindex, POWER (2, 24))) = 0
        CONNECT BY PRIOR rindex = pindex)
 WHERE full_alias_path LIKE '+DATA/CDB1STB/%' or full_alias_path LIKE '+DATA/CDB1/%';
 SPOOL OFF
# tao diskgroup
CREATE DISKGROUP DATAUAT EXTERNAL REDUNDANCY DISK '/dev/rhdisk19','/dev/rhdisk20','/dev/rhdisk21','/dev/rhdisk22';
-- tren node con lai:
alter diskgroup DATA mount;
select INST_ID,NAME,STATE from gv$asm_diskgroup;
crsctl stat res -t
# add disk them vao diskgroup
grid#sqlplus  / as sysasm
alter diskgroup DATA add disk '/dev/rhdisk18' rebalance power 8 nowait;
select INST_ID, OPERATION, STATE, POWER, SOFAR, EST_WORK, EST_RATE, EST_MINUTES from GV$ASM_OPERATION;      -- ktra bao h xong
trong asm alert.log se co cac dong duoi
NOTE: starting rebalance of group 2/0x708061e1 (FRANEW) at power 6
SUCCESS: rebalance completed for group 2/0x708061e1 (FRANEW)

# drop disk
alter diskgroup RECOHC1 drop disk RECOHC1_CD_00_DREXACELADM02,RECOHC1_CD_00_DREXACELADM03,RECOHC1_CD_00_DREXACELADM04,RECOHC1_CD_00_DREXACELADM05,RECOHC1_CD_00_DREXACELADM06;
alter diskgroup DATAHC1 drop disk DATAHC1_CD_00_DREXACELADM02,DATAHC1_CD_00_DREXACELADM03,DATAHC1_CD_00_DREXACELADM04,DATAHC1_CD_00_DREXACELADM05,DATAHC1_CD_00_DREXACELADM06;

# check voting disk
crsctl query css votedisk
ocrcheck


set linesize 9999;
select NAME,STATE,GROUP_NUMBER,TOTAL_MB,FREE_MB,REQUIRED_MIRROR_FREE_MB,USABLE_FILE_MB,ROUND(Free_MB/Total_MB*100) "Free %" from v$asm_diskgroup; 
thuc ra USABLE_FILE_MB moi la dung luong co the su dung that su
(FREE_MB - REQUIRED_MIRROR_FREE_MB) / <redundancy factor> = USABLE_FILE_MB

Khi USABLE_FILE_MB < 0 nghia la ta da dung qua , se lam mat kha nang redundancy cua diskgroup.

# select datafile thuoc tablespace asm
		select aa.name, aa.file_number, af.file_number, af.bytes/1024/1024
		from v$asm_alias aa, v$asm_file af
		where af.file_number=aa.file_number
		and ( aa.name like 'gw_data%' or aa.name like 'GW_DATA%')
		and af.type='DATAFILE';
#Viewing disks in disk groups with V$ASM_DISK
set linesize 9999;
			SELECT SUBSTR(d.name,1,16) AS asmdisk, d.mount_status, d.state, 
     dg.name AS diskgroup FROM V$ASM_DISKGROUP dg, V$ASM_DISK d 
     WHERE dg.group_number = d.group_number;
#This example displays disk groups with information about the connected database client instances.     
    SELECT dg.name AS diskgroup, SUBSTR(c.instance_name,1,12) AS instance,
    SUBSTR(c.db_name,1,12) AS dbname, SUBSTR(c.SOFTWARE_VERSION,1,12) AS software,
    SUBSTR(c.COMPATIBLE_VERSION,1,12) AS compatible 
    FROM V$ASM_DISKGROUP dg, V$ASM_CLIENT c  
    WHERE dg.group_number = c.group_number;
    
    select name, path, header_status, total_mb free_mb, trunc(bytes_read/1024/1024) read_mb, trunc(bytes_written/1024/1024) write_mb from v$asm_disk;
			
			col diskgroup for a50
          col diskname for a50
          col path for a50
         select a.name DiskGroup,b.name DiskName, b.total_mb, b.free_mb,b.path, b.header_status   from v$asm_disk b, v$asm_diskgroup a where a.group_number (+) =b.group_number order by         
		 b.group_number,b.name;
		 
# su dung asmcmd
	env -- lay duoc ORACLE_GRID=/u01/11.2.0/grid
	export ORACLE_HOME=/u01/evsapp/grid/
	lsnrctl status -- lay duoc Instance "+ASM1"
  export ORACLE_SID=+ASM2   
  asmcmd
 Check diskgroup including the dismounted DGs
$  asmcmd lsdg -g  --discovery 

Check ASM disk status
$ asmcmd lsdsk -k -g  

Check ASM disk status for candidate disk 
$  asmcmd lsdsk -k -g --candidate

Clients accessing ASM instance:
$ asmcmd lsct

Files opened by ASM instance:
$ asmcmd lsof

======== doi password sys asm
ASMCMD> lspwusr   --list cac user
ASMCMD> help passwd
		passwd
		Changes the password of a user.
 ASMCMD> passwd sys
		Enter old password (optional):
		Enter new password: *********
		
Hoac don gian hon 
sqlplus / as sysasm
SQL> alter user sys identified by "msbsysadmin123";

==================a tam msb === sua loi MRP0 applying nhung ko apply duoc gi
khi bat lai dong bo thi co loi dang
SQL>recover managed standby database cancel;
SQL>recover automatic standby database;
ORA-00279: change 11090127602875 generated at 09/02/2019 01:07:44 needed for thread 1
ORA-00289: suggestion : /data/VISIONSTB/archivelog/2019_09_02/o1_mf_1_79916_%u_.arc
ORA-00280: change 11090127602875 for thread 1 is in sequence #79916
ORA-00278: log file '/data/VISIONSTB/archivelog/2019_09_02/o1_mf_1_79916_%u_.arc' no longer needed for this recovery
ORA-00308: cannot open archived log '/data/VISIONSTB/archivelog/2019_09_02/o1_mf_1_79916_%u_.arc'
ORA-27037: unable to obtain file status
Linux-x86_64 Error: 2: No such file or directory
Additional information: 7
-- kiem tra ben standby xem dang apply toi sequence nao 
SELECT 'HOST',a.thread#, b.last_seq, a.applied_seq, a.timestamp, b.last_seq-a.applied_seq arc_diff,sysdate FROM 
(SELECT thread#, MAX(sequence#) applied_seq, MAX(next_time) timestamp FROM gv$archived_log
WHERE applied = 'YES' and resetlogs_change# = (select RESETLOGS_CHANGE# from v$database) 
GROUP BY thread#) a, (SELECT  thread#, MAX (sequence#) last_seq FROM gv$archived_log
where resetlogs_change# = (select RESETLOGS_CHANGE# from v$database) GROUP BY thread#) b WHERE a.thread# = b.thread#;	
-- check gap tren standby
select * from v$archive_gap; 
THREAD# LOW_SEQUENCE# HIGH_SEQUENCE#     CON_ID
---------- ------------- -------------- ----------
         1         10330          10331          1
-> thieu sequence 10331
-- kiem tra ben primary xem sequence do co ten la gi

select name, thread#, sequence#, status, first_time, next_time, first_change#, next_change# from gv$archived_log where sequence#=223860 ;
select name, thread#, sequence#, status, first_time, next_time, first_change#, next_change# from gv$archived_log where sequence#=10330 and thread#=1;    
     list archivelog from sequence 79914 until sequence 79916;

-- kiem tra lai tren stanby xem co file archive nay chua , chua co thi copy tu primary sang standby, dung ip vip va sid cua host 
export DBI_TRACE=1
asmcmd ls +ASM:+FRA/CDB2DR/ARCHIVELOG/2019_08_16/thread_2_seq_226324*
asmcmd cp +DATAC1/CDB2/ARCHIVELOG/2019_08_16/thread_2_seq_226324.2952.1016409665 sys@10.0.17.20.+ASM1:+FRA/CDB2DR/ARCHIVELOG/2019_08_16/thread_2_seq_226324
-- register standby log nay ben standby
alter database register logfile '+FRA/CDB2DR/ARCHIVELOG/2019_08_16/thread_2_seq_226324';
-- bat lai dong bo ben standby
alter database recover managed standby database using current logfile disconnect;

==========asmcmd cp dung ip vip va sid cua host 

export DBI_TRACE=1
cp +RECO/CICSTB/ARCHIVELOG/2019_06_26/thread_2_seq_279956.11366.1011996355 sys@10.0.17.210.+ASM1:/data/

local host va remote host deu fai co ASM 
yeu cau can co user sys asm tren remote host
--------------purge table------------------------
 drop table xxx purge; --- neu muon purge thi fai vay
 -- ktra recycle bin xem con ko
select * from dba_recyclebin;--- connect vao user sys
delete from RecycleBin$  
select count(*) from dba_recyclebin;
purge  dba_recyclebin; -- purge all object in recyclebin

============== KMTD SYSAUX day thuong la do bang nay to WRH$_ACTIVE_SESSION_HISTORY========================
 SELECT 
     occupant_name,  
     round( space_usage_kbytes/1024) "Space (M)",  
     schema_name, 
     move_procedure
   FROM 
     v$sysaux_occupants  
   ORDER BY 
     1  ;  --- co the thay SM/AWR is big
++ kiem tra truoc khi lam
SQL> SELECT COUNT(1) Orphaned_ASH_Rows
      FROM wrh$_active_session_history a
      WHERE NOT EXISTS
        (SELECT 1
        FROM wrm$_snapshot
        WHERE snap_id       = a.snap_id
        AND dbid            = a.dbid
        AND instance_number = a.instance_number
        );

SQL> select  count(*), max(snap_id), min(snap_id) from DBA_HIST_SNAPSHOT  order by end_interval_time asc;

  COUNT(*) MAX(SNAP_ID) MIN(SNAP_ID)
---------- ------------ ------------
       152        17839        17688

SQL> select count(distinct(snap_id)), max(snap_id), min(snap_id) from WRH$_ACTIVE_SESSION_HISTORY  ;

COUNT(DISTINCT(SNAP_ID)) MAX(SNAP_ID) MIN(SNAP_ID)
------------------------ ------------ ------------
                   17839        17839            1
 
begin
  DBMS_WORKLOAD_REPOSITORY.DROP_SNAPSHOT_RANGE( 
  low_snap_id => 1, 
  high_snap_id => 2 
 );
end;
/


SQL> SELECT COUNT(1) Orphaned_ASH_Rows
  2      FROM wrh$_active_session_history a
  3      WHERE NOT EXISTS
  4        (SELECT 1
  5        FROM wrm$_snapshot
  6        WHERE snap_id       = a.snap_id
  7        AND dbid            = a.dbid
  8        AND instance_number = a.instance_number
  9        );

ORPHANED_ASH_ROWS
-----------------
                0  -- ket qua =0 thi tiep tuc shringk

SQL> select count(*) from WRH$_ACTIVE_SESSION_HISTORY;

  COUNT(*)
----------
     97533

SQL> alter table WRH$_ACTIVE_SESSION_HISTORY shrink space;

########################## cau hinh resource manager ===================
BEGIN
  DBMS_RESOURCE_MANAGER.CREATE_PENDING_AREA();
   
  
 
  DBMS_RESOURCE_MANAGER.CREATE_PLAN(
    PLAN    => 'apps_plan',
    COMMENT => 'Application consolidation chungtc 20210126');
 
  
  DBMS_RESOURCE_MANAGER.CREATE_PLAN_DIRECTIVE (
    PLAN                  => 'apps_plan',
    GROUP_OR_SUBPLAN      => 'SYS_GROUP',
    COMMENT               => 'For sys task',
    MAX_UTILIZATION_LIMIT => 30);
  DBMS_RESOURCE_MANAGER.CREATE_PLAN_DIRECTIVE (
    PLAN                  => 'apps_plan',
    GROUP_OR_SUBPLAN      => 'ORA$AUTOTASK',
    COMMENT               => 'For automatic task',
    MAX_UTILIZATION_LIMIT => 20);
  DBMS_RESOURCE_MANAGER.CREATE_PLAN_DIRECTIVE (
    PLAN                  => 'apps_plan',
    GROUP_OR_SUBPLAN      => 'OTHER_GROUPS',
    COMMENT               => 'Mandatory for all user task',
    MAX_UTILIZATION_LIMIT => 50);
 
  DBMS_RESOURCE_MANAGER.VALIDATE_PENDING_AREA();
END;
/
begin 
 dbms_resource_manager.submit_pending_area();   --changed from PENDING to ACTIVE. 
end; 
alter system set resource_manager_plan='APPS_PLAN';  --- apply resource manager to live

SELECT name, is_top_plan FROM v$rsrc_plan;			--xem duoc active plan





----------- limit cpu   alter system set resource_manager_plan = default_plan;
BEGIN
  DBMS_RESOURCE_MANAGER.CREATE_PENDING_AREA();

  DBMS_RESOURCE_MANAGER.CREATE_PLAN(
    PLAN    => 'MAXCAP_PLAN',
    COMMENT => 'Limit overall database CPU');
   
  DBMS_RESOURCE_MANAGER.CREATE_PLAN_DIRECTIVE(
    PLAN              => 'MAXCAP_PLAN',
    GROUP_OR_SUBPLAN  => 'OTHER_GROUPS',
    COMMENT           => 'This group is mandatory',
    MAX_UTILIZATION_LIMIT => 50);

  DBMS_RESOURCE_MANAGER.VALIDATE_PENDING_AREA();
  DBMS_RESOURCE_MANAGER.SUBMIT_PENDING_AREA();
END;
/
#######################Managing Resources with Oracle Database Resource Manager#############################
-- cac resource plan tren he thong
   select * from DBA_RSRC_PLANS;
      select * from dba_cdb_rsrc_plans;

   SELECT name, is_top_plan FROM v$rsrc_plan; --Viewing the Currently Active Plans

SELECT *    FROM dba_rsrc_plan_directives; 
select * from DBA_RSRC_CONSUMER_GROUPS;
SELECT * FROM dba_rsrc_consumer_group_privs;
SELECT sid,serial#,username,resource_consumer_group FROM v$session;

------- xem resource plan dang ap cho live
select * from v$rsrc_plan where is_top_plan = 'TRUE';
-- xem plan directive cua plan dang ap cho live
select  * from dba_rsrc_plan_directives where plan = (select name from v$rsrc_plan where is_top_plan = 'TRUE');
select  * from dba_cdb_rsrc_plan_directives where plan = (select name from v$rsrc_plan where is_top_plan = 'TRUE');
select  * from dba_cdb_rsrc_plan_directives where plan ='DEFAULT_CDB_PLAN';
select * from DBA_RSRC_CONSUMER_GROUPS
where consumer_group in ('OTHER_GROUPS','ORA$AUTOTASK','SYS_GROUP');

select * from DBA_RSRC_CONSUMER_GROUP_PRIVS order by grantee;
--- monitor resource manager
select to_char(m.begin_time, 'HH24:MI') time, m.consumer_group_name, m.cpu_consumed_time / 60000 avg_running_sessions, m.cpu_wait_time / 60000 avg_waiting_sessions, d.mgmt_p1*(select value from v$parameter where name = 'cpu_count')/100 allocation 
from v$rsrcmgrmetric_history m, dba_rsrc_plan_directives d, v$rsrc_plan p where m.consumer_group_name = d.group_or_subplan and p.name = d.plan 
order by m.begin_time desc, m.consumer_group_name ;

SELECT consumer_group_name, cpu_consumed_time,
cpu_wait_time, num_cpus FROM v$rsrcmgrmetric;


============== cac buoc resource manager
-- tao 1 consumer group
BEGIN
  DBMS_RESOURCE_MANAGER.CREATE_PENDING_AREA();

  DBMS_RESOURCE_MANAGER.CREATE_CONSUMER_GROUP (
   CONSUMER_GROUP => 'PUSH',
   COMMENT        => 'PUSH applications');
     DBMS_RESOURCE_MANAGER.VALIDATE_PENDING_AREA();
  DBMS_RESOURCE_MANAGER.SUBMIT_PENDING_AREA();
END;
/

select * from DBA_RSRC_CONSUMER_GROUPS;

-- gan 1 user vao consumer group

BEGIN
  DBMS_RESOURCE_MANAGER.CLEAR_PENDING_AREA();
  DBMS_RESOURCE_MANAGER.CREATE_PENDING_AREA();

DBMS_RESOURCE_MANAGER.SET_CONSUMER_GROUP_MAPPING  
     (DBMS_RESOURCE_MANAGER.ORACLE_USER, 'C##TEST', 'PUSH');
DBMS_RESOURCE_MANAGER.VALIDATE_PENDING_AREA();
END; 
/	 
exec  DBMS_RESOURCE_MANAGER.SUBMIT_PENDING_AREA();

select * from dba_users where username='C##TEST';

-- tao 1 plan for resouce manager
BEGIN
  DBMS_RESOURCE_MANAGER.CLEAR_PENDING_AREA();
  DBMS_RESOURCE_MANAGER.CREATE_PENDING_AREA();
   
  DBMS_RESOURCE_MANAGER.CREATE_PLAN(
    PLAN    => 'apps_plan_v2',
    COMMENT => 'Application consolidation chungtc 20210130');
 
  
  DBMS_RESOURCE_MANAGER.CREATE_PLAN_DIRECTIVE (
    PLAN                  => 'apps_plan_v2',
    GROUP_OR_SUBPLAN      => 'SYS_GROUP',
    COMMENT               => 'For sys task',
    MAX_UTILIZATION_LIMIT => 80);
  DBMS_RESOURCE_MANAGER.CREATE_PLAN_DIRECTIVE (
    PLAN                  => 'apps_plan_v2',
    GROUP_OR_SUBPLAN      => 'PUSH',
    COMMENT               => 'PUSHMESSAGE applications',
    MAX_UTILIZATION_LIMIT => 50);
  DBMS_RESOURCE_MANAGER.CREATE_PLAN_DIRECTIVE (
    PLAN                  => 'apps_plan_v2',
    GROUP_OR_SUBPLAN      => 'OTHER_GROUPS',
    COMMENT               => 'Mandatory for all user task',
    MAX_UTILIZATION_LIMIT => 80);
 
  DBMS_RESOURCE_MANAGER.VALIDATE_PENDING_AREA();
END;
/

-- active plan for resource manager
exec  DBMS_RESOURCE_MANAGER.SUBMIT_PENDING_AREA();
-- apply plan for db
alter system set resource_manager_plan='APPS_PLAN_V2';
############### select timestamp scn
select  timestamp_to_scn(to_timestamp('08.06.2018 16.43.00','dd.mm.yyyy hh24:mi:ss')) scn from  dual;

SQL> select  timestamp_to_scn(to_timestamp('24.01.2019 15.16.00','dd.mm.yyyy hh24:mi:ss')) scn from  dual;

       SCN
----------
 436495413


 run{

 recover tablespace testtbs

 until scn 436495413

 auxiliary destination '/db/temp'; 

 } 
 
############### recreate users tablespace chungtc
tao 1 tablespace USERS_TEMP
alter database default tablespace USERS_TEMP; 
expdp \' / as sysdba\' DIRECTORY=DUMP DUMPFILE=DUMP:users.dmp LOGFILE=DUMP:users.log TABLESPACES=USERS 
impdp \' / as sysdba\' DIRECTORY=DUMP DUMPFILE=DUMP:users.dmp table_exists_action=replace remap_tablespace=USERS:USERS_TEMP LOGFILE=DUMP:USERS_TEMP.log
-- xoa INCLUDING CONTENTS AND DATAFILES nhu nay co du lieu cung bi drop , ko nen dung
DROP TABLESPACE users INCLUDING CONTENTS AND DATAFILES;  
alter tablespace USERS_TEMP rename to users;
################ thay undo tbs  drop undo tablespace
 create undo tablespace UNDOTBS01 DATAFILE '+DATA/orcl/datafile/UNDOTBS01.dbf' size 1G;
 ALTER SYSTEM SET UNDO_TABLESPACE=UNDO_TEMP SCOPE=BOTH SID='orcl1';
 sau do drop undo tbs cu di 
  drop tablespace UNDOTBS01 including contents and datafiles;
==== khi dang co recovery thi co ther khong drop duoc undotbs cu
Transaction recovery: lock conflict caught and ignored
Transaction recovery: lock conflict caught and ignored
[26408] **** active transactions found in undo Tablespace 2 - moved to Pending Switch-Out state.
Mon Nov 09 23:34:18 2020
[26408] Undo Tablespace 2 successfully switched out.
 
select usn,
       state,
       undoblockstotal "Total",
       undoblocksdone "Done",
       undoblockstotal - undoblocksdone "ToDo",
       decode(cputime,
              0,
              'unknown',
              sysdate + (((undoblockstotal - undoblocksdone) /
              (undoblocksdone / cputime)) / 86400)) "Estimated time to complete"
  from v$fast_start_transactions;

USN STATE                 Total       Done       ToDo Estimated time to
--- ---------------- ---------- ---------- ---------- ------------------
 14 RECOVERING           549296      69543     479753 10-NOV-20 
 
==> khi nao co log duoi thi co ther drop
Mon Nov 09 23:34:18 2020
[26408] Undo Tablespace 2 successfully switched out.
 
============================== cach drop undo tablespace khi truong hop dang recovery 
https://airydba.wordpress.com/2016/05/23/ora-01548-active-rollback-segment-_syssmu1_3780397527-found-terminate-dropping-tablespace/
select segment_name,status,tablespace_name from dba_rollback_segs;
-> them 1 dong trong pfile vs rollback segment co dang PARTLY AVAILABLE  to NEEDS RECOVERY ( co the ca online)
create pfile='/tmp/pfile' from spfile;
*.undo_tablespace='UNDO_TEMP'
*.use_large_pages='ONLY'
*._offline_rollback_segments=('_SYSSMU34_2331972838$','_SYSSMU35_3070990941$','_SYSSMU46_1323432560$','_SYSSMU47_146527855$','_SYSSMU48_2897207242$','_SYSSMU49_3460180922$','_SYSSMU50_1261912363$','_SYSSMU51_2252325802$','_SYSSMU52_2184988470$','_SYSSMU53_2924731369$','_SYSSMU54_3726638365$','_SYSSMU55_2517764657$','_SYSSMU56_241415221$')

startup pfile ='/tmp/pfile';
select segment_name,status,tablespace_name from dba_rollback_segs; 
-> voi nhung segment PARTLY AVAILABLE  to NEEDS RECOVERY thi drop di
drop rollback segment “_SYSSMU1_3780397527$”;

 ALTER SYSTEM SET UNDO_TABLESPACE=UNDO_TEMP SCOPE=BOTH SID='orcl1';
sau do drop undo tbs cu di 
  drop tablespace UNDOTBS01 including contents and datafiles;
  
########## savepoint
UPDATE employees 
    SET salary = 7000 
    WHERE last_name = 'Banda';
SAVEPOINT banda_sal;

UPDATE employees 
    SET salary = 12000 
    WHERE last_name = 'Greene';
SAVEPOINT greene_sal;

SELECT SUM(salary) FROM employees;

ROLLBACK TO SAVEPOINT banda_sal;

savepoint chi co gia tri trong transaction do, se bi mat khi rollback or commit
######### CHUNGTC CHECK WHICH TABLE IN SGA
select obj.owner, obj.object_name, obj.object_type,
    count(buf.block#) as cached_blocks
from v$bh buf
inner join dba_objects obj
    on buf.objd = obj.data_object_id
where buf.class# = 1 -- data blocks
and buf.status != 'free'
and obj.owner = 'VISION'
--and obj.object_name = 'DEPARTMENTS'
and obj.object_type = 'TABLE'
and obj.object_name like '%chungtc_TEMP_FINHMRG_SEQ_VN_01%'
group by obj.owner, obj.object_name, obj.object_type
;
########## xem cac loai pool tren sga
select component ,current_size from v$memory_dynamic_components where current_size != 0;
## pill an object to pool
create table ic.test1 (id number) tablespace users storage (buffer_pool keep);
Buffer cache configure with three ways:
Default: It is used for storage data blocks in memory that have been retrieved from data files. Parameter db_cache_size defines the default buffer cache.
Keep: Cache is that it will hold frequently accessed blocks without ageing them out. It is managed by user for which object need to put in keep blocks. Parameter db_keep_cache_size is used to define.
Recycle: Those objects that you do not want to keep in memory. keep segments that are scanned rarely or are not useded frequently. Parameter defines as db_recycle_cache_size
--- stream pool
stream pool dung cho GG, cho exp imp dump. default la 10% cua share pool
-----Share pool thi co 2 thanh phan chinh library va dictionary cache
- library cache thi luu sql statement, package, va cung co package, procedure( sql_id )
- dictionary cache: luu dinh nghia ve cac object cua database, ai dang access cac object nay, users...( row cache) 
################################################Oracle's password file

 		
If the DBA wants to start up an Oracle instance there must be a way for Oracle to authenticate this DBA. That is if (s)he is allowed to do so. Obviously, his password can not be stored in the database, because Oracle can not access the database before the instance is started up. Therefore, the authentication of the DBA must happen outside of the database. There are two distinct mechanisms to authenticate the DBA: using the password file or through the operating system.
The init parameter remote_login_passwordfile specifies if a password file is used to authenticate the DBA or not. If it set either to shared or exclusive a password file will be used.
Default location and file name
The default location for the password file is: $ORACLE_HOME/dbs/orapw$ORACLE_SID on Unix and %ORACLE_HOME%\database\PWD%ORACLE_SID%.ora on Windows.
Deleting a password file
If password file authentication is no longer needed, the password file can be deleted and the init parameter remote_login_passwordfile set to none.
Password file state
If a password file is shared or exclusive is also stored in the password file. After its creation, the state is shared. The state can be changed by setting remote_login_passwordfile and starting the database. That is, the database overwrites the state in the password file when it is started up.
A password file whose state is shared can only contain SYS.
Creating a password file
Password files are created with the orapwd tool.
Adding Users to the password file
Users are added to the password file when they're granted the SYSDBA or sysoper privilege.

  orapwd file=orapwqtdldr1 password=mbdba#123 force=y ignorecase=Y;
  orapwd file=orapwqtdldr1 password=Oracle@4U957 force=y ignorecase=Y;
SYS@ora10> show user;
USER is "SYS"
SYS@ora10> select * from v$pwfile_users;

USERNAME                       SYSDB SYSOP
------------------------------ ----- -----
SYS                            TRUE  TRUE

SYS@ora10> grant SYSDBA to rene;

Grant succeeded.

SYS@ora10> select * from v$pwfile_users;

USERNAME                       SYSDB SYSOP
------------------------------ ----- -----
SYS                            TRUE  TRUE
RENE                           TRUE  FALSE

SYS@ora10> grant SYSOPER to rene;

Grant succeeded.

SYS@ora10> select * from v$pwfile_users;

USERNAME                       SYSDB SYSOP
------------------------------ ----- -----
SYS                            TRUE  TRUE
RENE                           TRUE  TRUE

SYS@ora10> revoke SYSDBA from rene;

Revoke succeeded.

SYS@ora10> select * from v$pwfile_users;

USERNAME                       SYSDB SYSOP
------------------------------ ----- -----
SYS                            TRUE  TRUE
RENE                           FALSE TRUE

SYS@ora10> revoke SYSOPER from rene;

Revoke succeeded.

SYS@ora10> select * from v$pwfile_users;

USERNAME                       SYSDB SYSOP
------------------------------ ----- -----
SYS                            TRUE  TRUE



############# MONGO DB ########################
cd C:\Program Files\MongoDB\Server\4.0\bin
mongo.exe
use <dbname>
db
show dbs
db.version()
db.serverCmdLineOpts()		-- xem cac tham so cua MongoDb
show collections
db.createCollection(name, options)	-- tao collection
db.COLLECTION_NAME.drop()						-- xoa collection
db.chung.insert({
   title: 'MongoDB Overview', 
   description: 'MongoDB is no sql database',
   by: 'tutorials point',
   url: 'http://www.tutorialspoint.com',
   tags: ['mongodb', 'database', 'NoSQL'],
   likes: 100
})

db.stores.insert(
   [
     { _id: 1, name: "Java Hut", description: "Coffee and cakes" },
     { _id: 2, name: "Burger Buns", description: "Gourmet hamburgers" },
     { _id: 3, name: "Coffee Shop", description: "Just coffee" },
     { _id: 4, name: "Clothes Clothes Clothes", description: "Discount clothing" },
     { _id: 5, name: "Java Shopping", description: "Indonesian goods" }
   ]
)
db.stores.createIndex( { name: "text", description: "text" } )
db.stores.find( { $text: { $search: "java coffee shop" } } )

db.chung.find().pretty()			-- select * from chung
db.chung.find( { qty: "1!" } )   --SELECT * FROM chung WHERE status = "pen"
db.chung.find({"qty": /1/})	--SELECT * FROM chung WHERE status like "%1%"
db.chung.find({},{"qty":"1!"}).sort({"qty":-1})
db.inventory.find( { status: { $in: [ "A", "D" ] } } )  -- SELECT * FROM inventory WHERE status in ("A", "D")
db.inventory.find( { status: "A", qty: { $lt: 30 } } )		--SELECT * FROM inventory WHERE status = "A" AND qty < 30
db.inventory.find( { $or: [ { status: "A" }, { qty: { $lt: 30 } } ] } )		SELECT * FROM inventory WHERE status = "A" OR qty < 30
db.inventory.find( {
     status: "A",
     $or: [ { qty: { $lt: 30 } }, { item: /^p/ } ]			--SELECT * FROM inventory WHERE status = "A" AND ( qty < 30 OR item LIKE "p%")
} )
					Equality	{<key>:<value>}	db.mycol.find({"by":"tutorials point"}).pretty()	where by = 'tutorials point'
					Less Than	{<key>:{$lt:<value>}}	db.mycol.find({"likes":{$lt:50}}).pretty()	where likes < 50
					Less Than Equals	{<key>:{$lte:<value>}}	db.mycol.find({"likes":{$lte:50}}).pretty()	where likes <= 50
					Greater Than	{<key>:{$gt:<value>}}	db.mycol.find({"likes":{$gt:50}}).pretty()	where likes > 50
					Greater Than Equals	{<key>:{$gte:<value>}}	db.mycol.find({"likes":{$gte:50}}).pretty()	where likes >= 50
					Not Equals	{<key>:{$ne:<value>}}	db.mycol.find({"likes":{$ne:50}}).pretty()	where likes != 50


db.chung.update({item: "pen"}, {$set: {qty: "1!"}}, {multi: true})
db.chung.remove({'title':'MongoDB Overview'})		-- delete from chung where title = 'MongoDB Overview';

===================chungtc check parameter is modified or not dong hay khong===============================
select name, issys_modifiable from V$PARAMETER2 where name like '%parallel_force_local%'
================ check gap dataguard - chay tren primary ===p==========

select ar.inst_id "inst_id",
       ar.dest_id "dest_id",
       ar.status "dest_status",
       ar.destination "destination",
         (select MAX (sequence#) highiest_seq
            from v$archived_log val, v$database vdb
           where     val.resetlogs_change# = vdb.resetlogs_change#
                 and thread# = ar.inst_id
                 and dest_id = ar.dest_id)
       - NVL (
            (select MAX (sequence#)
               from v$archived_log val, v$database vdb
              where     val.resetlogs_change# = vdb.resetlogs_change#
                    and thread# = ar.inst_id
                    and dest_id = ar.dest_id
                    and standby_dest = 'YES'
                    and applied = 'YES'),
            0)
          "applied_gap",
         (SELECT MAX (sequence#) highiest_seq
            from v$archived_log val, v$database vdb
           where     val.resetlogs_change# = vdb.resetlogs_change#
                 AND thread# = ar.inst_id)
       - NVL (
            (SELECT MAX (sequence#)
               from v$archived_log val, v$database vdb
              where     val.resetlogs_change# = vdb.resetlogs_change#
                    and thread# = ar.inst_id
                    and dest_id = ar.dest_id
                    and standby_dest = 'YES'),
            0)
          "received_gap",
       NVL (
          (SELECT MAX (sequence#)
             from v$archived_log val, v$database vdb
            where     val.resetlogs_change# = vdb.resetlogs_change#
                  and thread# = ar.inst_id
                  and dest_id = ar.dest_id
                  and standby_dest = 'YES'),
          0)
          "last_received_seq",
       NVL (
          (SELECT MAX (sequence#)
             from v$archived_log val, v$database vdb
            where     val.resetlogs_change# = vdb.resetlogs_change#
                  and thread# = ar.inst_id
                  and dest_id = ar.dest_id
                  and standby_dest = 'YES'
                  and applied = 'YES'),
          0)
          "last_applied_seq"
  from (SELECT DISTINCT dest_id,
                        inst_id,
                        status,
                        target,
                        destination,
                        error
          from sys.gv_$archive_dest
         where target = 'STANDBY' and STATUS <> 'DEFERRED') ar;
		 
		 
SELECT 'HOST',a.thread#, b.last_seq, a.applied_seq, a.timestamp, b.last_seq-a.applied_seq arc_diff,sysdate FROM 
(SELECT thread#, MAX(sequence#) applied_seq, MAX(next_time) timestamp FROM gv$archived_log
WHERE applied = 'YES' and resetlogs_change# = (select RESETLOGS_CHANGE# from v$database) 
GROUP BY thread#) a, (SELECT  thread#, MAX (sequence#) last_seq FROM gv$archived_log
where resetlogs_change# = (select RESETLOGS_CHANGE# from v$database) GROUP BY thread#) b WHERE a.thread# = b.thread#;		 


-- chay tren standby
select * from v$archive_gap; 
		 

===============BLOB=====================================
CREATE TABLE images (id NUMBER, name varchar2(200), image BLOB);
CREATE OR REPLACE DIRECTORY 
BLOB_DIR AS 
'/export/home/oracle/';


DECLARE
  l_dir    VARCHAR2(10) := 'BLOB_DIR'; -------Is the Directory Object Created Above.
  l_file   VARCHAR2(20) := 'me.jpg'; ------ Is the BLOB File that is present in the Directory mentioned.
  l_bfile  BFILE;
  l_blob   BLOB;
BEGIN
  INSERT INTO images (id, name, image)
  VALUES (1,l_file, empty_blob())
  RETURN image INTO l_blob;

  l_bfile := BFILENAME(l_dir, l_file);
  DBMS_LOB.fileopen(l_bfile, DBMS_LOB.file_readonly);
  DBMS_LOB.loadfromfile(l_blob, l_bfile, DBMS_LOB.getlength(l_bfile));
  DBMS_LOB.fileclose(l_bfile);

  COMMIT;
END;
select * from images;

========== convert blob to clob select T24CORE.convert_to_clob(xmlrecord) from t24core.ebf_user; 
CREATE OR REPLACE FUNCTION T24CORE.convert_to_clob(l_blob BLOB) RETURN CLOB IS
     l_clob         CLOB;
       l_dest_offset  NUMBER := 1;
       l_src_offset   NUMBER := 1;
       l_lang_context NUMBER := dbms_lob.default_lang_ctx;
      l_warning      NUMBER;
    BEGIN
       dbms_lob.createtemporary(l_clob, TRUE);
       dbms_lob.converttoclob(dest_lob     => l_clob,
                             src_blob     => l_blob,
                             amount       => dbms_lob.lobmaxsize,
                             dest_offset  => l_dest_offset,
                             src_offset   => l_src_offset,
                             blob_csid    => nls_charset_id('WE8ISO8859P1'),
                             lang_context => l_lang_context,
                             warning      => l_warning);
      RETURN l_clob;
   END convert_to_clob;
/

============create pdb 
phai kiem tra dg co dang applying khong
standby phai o che do read only

CREATE PLUGGABLE DATABASE PDBN ADMIN USER admin IDENTIFIED BY admin
  DEFAULT TABLESPACE users DATAFILE SIZE 1M AUTOEXTEND ON NEXT 10M;

  => ben standby se co dang
  Recovery created pluggable database QLCTN
WARNING: The converted filename '+DATA/cdb10dr/a3533f4316de04e2e0530a0144645edb/datafile/system.3705.1037815349'
         is an ASM fully qualified filename.
         Changing the filename to '+DATA/MUST_RENAME_THIS_DATAFILE_0.4294967295.4294967295'.
         Please rename it accordingly.

2020-04-15T18:02:57.498786+07:00
Recovery copied files for tablespace SYSTEM
Recovery successfully copied file +DATA/CDB10DR/A3533F4316DE04E2E0530A0144645EDB/DATAFILE/system.1812.1037815367 from +DATA/CDB10DR/A1AC7EF2510204C6E0530A01446427BE/DATAFILE/system.1540.1037298023

  alter pluggable database QLCTN open
=> ben standby
	PDBOLD(6):Successfully added datafile 59 to media recovery
	PDBOLD(6):Datafile #59: '+DATA/CDBDR/A355422331563F1BE0533C44010A216E/DATAFILE/undotbs1.1521.1037824787'
	2020-04-15T20:41:10.050673+07:00
	(6):Successfully added datafile 60 to media recovery
	(6):Datafile #60: '+DATA/CDBDR/A355422331563F1BE0533C44010A216E/DATAFILE/users.1523.1037824869'

alter pluggable database pdbold open read only;
=> alert log 
PDBOLD(6):Database Characterset for PDBOLD is AL32UTF8
PDBOLD(6):WARNING: The following temporary tablespaces in container(PDBOLD)
PDBOLD(6):         contain no files.
PDBOLD(6):         This condition can occur when a backup controlfile has
PDBOLD(6):         been restored.  It may be necessary to add files to these
PDBOLD(6):         tablespaces.  That can be done using the SQL statement:
PDBOLD(6): 
PDBOLD(6):         ALTER TABLESPACE <tablespace_name> ADD TEMPFILE
PDBOLD(6): 
PDBOLD(6):         Alternatively, if these temporary tablespaces are no longer
PDBOLD(6):         needed, then they can be dropped.
PDBOLD(6):           Empty temporary tablespace: TEMP
2020-04-15T20:42:32.382586+07:00
PDBOLD(6):Opening pdb with no Resource Manager plan active
Pluggable database PDBOLD opened read only
Completed: alter pluggable database pdbold open read only

============ lock table parallel dml ====================
http://db.geeksinsight.com/2013/02/14/number-of-locks-that-can-acquire-with-parallel-dml-statements/
https://docs.oracle.com/cd/E11882_01/server.112/e41084/ap_locks001.htm#SQLRF55502
==========drop pdb
phai kiem tra dg co dang applying khong
standby phai o che do read only

alter pluggable database KHDNPDB close instances=all;
drop pluggable database KHDNPDB including datafiles;

  ==============character set
SELECT value$ FROM sys.props$ WHERE name = 'NLS_CHARACTERSET' ;
select * from nls_database_parameters where PARAMETER in ('NLS_NCHAR_CHARACTERSET','NLS_CHARACTERSET');
Name	Owner	Type
APPS.TR_THLK		Table

---nvarchar co do dai 2000 vs AL16UTF16 va 4000 vs UTF8
https://docs.oracle.com/database/121/SQLRF/sql_elements001.htm#i45685
==============create profile
CREATE PROFILE APP LIMIT
  SESSIONS_PER_USER UNLIMITED
  CPU_PER_SESSION UNLIMITED
  CPU_PER_CALL UNLIMITED
  CONNECT_TIME UNLIMITED
  IDLE_TIME UNLIMITED
  LOGICAL_READS_PER_SESSION UNLIMITED
  LOGICAL_READS_PER_CALL UNLIMITED
  COMPOSITE_LIMIT UNLIMITED
  PRIVATE_SGA UNLIMITED
  FAILED_LOGIN_ATTEMPTS UNLIMITED
  PASSWORD_LIFE_TIME UNLIMITED
  PASSWORD_REUSE_TIME UNLIMITED
  PASSWORD_REUSE_MAX UNLIMITED
  PASSWORD_LOCK_TIME 1
  PASSWORD_GRACE_TIME 7
  PASSWORD_VERIFY_FUNCTION NULL;
  
  CREATE USER MSB_LOYALTY
  IDENTIFIED BY <password>
  DEFAULT TABLESPACE USERS
  TEMPORARY TABLESPACE TEMP
  PROFILE APP
  ACCOUNT_MASK UNLOCK;
  -- 2 Roles for MSB_LOYALTY 
  GRANT CONNECT TO MSB_LOYALTY;
  GRANT RESOURCE TO MSB_LOYALTY;
  ALTER USER MSB_LOYALTY DEFAULT ROLE ALL;
  -- 8 Object Privileges for MSB_LOYALTY 
    GRANT SELECT ON MSB.ACCOUNT_MASK TO MSB_LOYALTY;
    GRANT SELECT ON MSB.ACNT_CONTRACT TO MSB_LOYALTY;
    GRANT SELECT ON MSB.CHANNEL_CURRENCY TO MSB_LOYALTY;
    GRANT SELECT ON MSB.CLIENT TO MSB_LOYALTY;
    GRANT SELECT ON MSB.DOC TO MSB_LOYALTY;
    GRANT SELECT ON MSB.DOC_ENTRY TO MSB_LOYALTY;
    GRANT SELECT ON MSB.ENTRY TO MSB_LOYALTY;
    GRANT SELECT ON MSB.TRANS_TYPE TO MSB_LOYALTY;
================== TUNNING ===========================

===================LOGMINER chungtc ================ COMMITTED_DATA_ONLY 
CREATE TABLE SYS.MYLOGANALYSIS3
(
  SCN               NUMBER,
  START_SCN         NUMBER,
  COMMIT_SCN        NUMBER,
  TIMESTAMP         DATE,
  START_TIMESTAMP   DATE,
  COMMIT_TIMESTAMP  DATE,
  XIDUSN            NUMBER,
  XIDSLT            NUMBER,
  XIDSQN            NUMBER,
  XID               RAW(8),
  PXIDUSN           NUMBER,
  PXIDSLT           NUMBER,
  PXIDSQN           NUMBER,
  PXID              RAW(8),
  TX_NAME           VARCHAR2(256 BYTE),
  OPERATION         VARCHAR2(32 BYTE),
  OPERATION_CODE    NUMBER,
  ROLLBACK          NUMBER,
  SEG_OWNER         VARCHAR2(32 BYTE),
  SEG_NAME          VARCHAR2(256 BYTE),
  TABLE_NAME        VARCHAR2(32 BYTE),
  SEG_TYPE          NUMBER,
  SEG_TYPE_NAME     VARCHAR2(32 BYTE),
  TABLE_SPACE       VARCHAR2(32 BYTE),
  ROW_ID            VARCHAR2(18 BYTE),
  USERNAME          VARCHAR2(30 BYTE),
  OS_USERNAME       VARCHAR2(4000 BYTE),
  MACHINE_NAME      VARCHAR2(4000 BYTE),
  AUDIT_SESSIONID   NUMBER,
  SESSION#          NUMBER,
  SERIAL#           NUMBER,
  SESSION_INFO      VARCHAR2(4000 BYTE),
  THREAD#           NUMBER,
  SEQUENCE#         NUMBER,
  RBASQN            NUMBER,
  RBABLK            NUMBER,
  RBABYTE           NUMBER,
  UBAFIL            NUMBER,
  UBABLK            NUMBER,
  UBAREC            NUMBER,
  UBASQN            NUMBER,
  ABS_FILE#         NUMBER,
  REL_FILE#         NUMBER,
  DATA_BLK#         NUMBER,
  DATA_OBJ#         NUMBER,
  DATA_OBJV#        NUMBER,
  DATA_OBJD#        NUMBER,
  SQL_REDO          VARCHAR2(4000 BYTE),
  SQL_UNDO          VARCHAR2(4000 BYTE),
  RS_ID             VARCHAR2(32 BYTE),
  SSN               NUMBER,
  CSF               NUMBER,
  INFO              VARCHAR2(32 BYTE),
  STATUS            NUMBER,
  REDO_VALUE        NUMBER,
  UNDO_VALUE        NUMBER,
  SAFE_RESUME_SCN   NUMBER,
  CSCN              NUMBER,
  OBJECT_ID         RAW(16),
  EDITION_NAME      VARCHAR2(30 BYTE),
  CLIENT_ID         VARCHAR2(64 BYTE)
)
TABLESPACE AUDITUSER
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            INITIAL          64K
            NEXT             1M
            MAXSIZE          UNLIMITED
            MINEXTENTS       1
            MAXEXTENTS       UNLIMITED
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE
MONITORING;

	
declare
v_sql varchar2(20000);
u_sql varchar2(20000);
t_sql varchar2(20000);
z_sql varchar2(20000);
i number;
begin
i:=0;

for vds in
(
SELECT name, TO_CHAR(first_time, 'DD-MON-YYYY HH24:MI:SS') first_time
FROM v$archived_log 
WHERE name IS NOT NULL AND first_time BETWEEN TO_DATE('27-AUG-2020 15:00:00', 'DD-MON-YYYY HH24:MI:SS')
AND TO_DATE('27-AUG-2020 15:59:59', 'DD-MON-YYYY HH24:MI:SS')
and dest_id = (select dest_id from V$ARCHIVE_DEST_STATUS where status='VALID' and type='LOCAL')
ORDER BY first_time)
loop
dbms_output.put_line('exec dbms_output.put_line('||i||')');
i:=i+1;
v_sql:='EXECUTE DBMS_LOGMNR.ADD_LOGFILE(LOGFILENAME => '''||vds.name||''',OPTIONS => DBMS_LOGMNR.NEW);';
dbms_output.put_line(v_sql);

u_sql:='EXECUTE DBMS_LOGMNR.START_LOGMNR(OPTIONS => DBMS_LOGMNR.DICT_FROM_ONLINE_CATALOG + DBMS_LOGMNR.COMMITTED_DATA_ONLY);';
--u_sql:='EXECUTE dbms_logmnr.start_logmnr(OPTIONS =>DBMS_LOGMNR.DDL_DICT_TRACKING +DBMS_LOGMNR.PRINT_PRETTY_SQL);';


dbms_output.put_line(u_sql);
t_Sql:='insert into myLogAnalysis3  select * from v$logmnr_contents where table_name in (''ACFBNK_CUST017'',''ACFBNK_CATE002'',''LDFBNK_LD_L001'',''PDFBNK_PD_P003'',''ACFBNK_ACCOUNT'',''FTFBNK_FUND000'',''TTFBNK_TELLER'',''STFBNK_CUST000'' ) and operation in (''INSERT'',''DELETE'',''UPDATE'');';
--execute immediate t_Sql;
dbms_output.put_line(t_sql);
dbms_output.put_line('commit;');


z_sql:='EXECUTE DBMS_LOGMNR.END_LOGMNR();';
--execute immediate z_sql;
dbms_output.put_line(z_sql);

end loop;
end ;

===================LOGMINER A TAM MSB ================
## select ra archivelog trong khoang thoi gian
SELECT name, TO_CHAR(first_time, 'DD-MON-YYYY HH24:MI:SS') first_time
FROM v$archived_log
WHERE name IS NOT NULL AND first_time BETWEEN TO_DATE('24-FEB-2020 14:06:00', 'DD-MON-YYYY HH24:MI:SS')
AND TO_DATE('24-FEB-2020 14:15:00', 'DD-MON-YYYY HH24:MI:SS')
ORDER BY sequence#;

##2.	Add log vào logminer để phân tích

EXECUTE DBMS_LOGMNR.ADD_LOGFILE(LOGFILENAME => '+ORALOG/t24vn/archivelog/2021_03_13/thread_1_seq_1365651.2421.1067090501',OPTIONS => DBMS_LOGMNR.NEW);
EXECUTE DBMS_LOGMNR.ADD_LOGFILE(LOGFILENAME => '+FRA/qadb01/archivelog/2016_10_19/thread_1_seq_179156.790.925660849',OPTIONS => DBMS_LOGMNR.ADDFILE);
EXECUTE DBMS_LOGMNR.ADD_LOGFILE(LOGFILENAME => '+FRA/qadb01/archivelog/2016_10_19/thread_1_seq_179157.339.925664463',OPTIONS => DBMS_LOGMNR.ADDFILE);

##3.	Tạo bảng để lưu dữ liệu thay đổi

Execute DBMS_LOGMNR.START_LOGMNR(OPTIONS => DBMS_LOGMNR.DICT_FROM_ONLINE_CATALOG);
create table myLogAnalysis3 as select * from v$logmnr_contents;

##4.	Query nội dung bảng để tìm lại dữ liệu cần rollback

SELECT username, operation,
DBMS_LOGMNR.MINE_VALUE(REDO_VALUE,'SCHEMA.TABLENAME.COLNAME') REDO_VALUE,
DBMS_LOGMNR.MINE_VALUE(UNDO_VALUE,'SCHEMA.TABLENAME.COLNAME') UNDO_VALUE,
sql_redo,
sql_undo,
TO_CHAR(timestamp, 'DD-MON-YYYY HH24:MI:SS') timestamp,
scn
FROM
v$logmnr_contents
WHERE username = 'saas_qa_zact'
AND operation = 'DELETE';
--AND seg_owner = 'saas_qa_zact'

SELECT TIMESTAMP,username,SQL_REDO, SQL_UNDO,SESSION_INFO FROM sys.myLogAnalysis3 WHERE sql_redo like '%delete%saas_qa_zact%ACCOUNT_MASKID%';


SELECT username, operation,
--DBMS_LOGMNR.MINE_VALUE(REDO_VALUE,'SCHEMA.TABLENAME.COLNAME') REDO_VALUE,
--DBMS_LOGMNR.MINE_VALUE(UNDO_VALUE,'SCHEMA.TABLENAME.COLNAME') UNDO_VALUE,
sql_redo,
sql_undo,
TO_CHAR(timestamp, 'DD-MON-YYYY HH24:MI:SS') timestamp,
scn
FROM
sys.myLogAnalysis3
WHERE username = 'SAAS_QA_ZACT'
AND operation = 'DELETE' AND sql_redo like '%ACCOUNT_MASK%';


=================== bat sql developer =================
ễopen cmd
cd C:\TimesTen\tt1122_64\bin
ttenv.bat
F:
cd F:\set up\Timesten\sqldeveloper-4.1.5.21.78-no-jre\sqldeveloper
sqldeveloper.exe -> lúc này sẽ có hình kết nối như sau:




=============================chungtc t24=================================
-- tao bang t24
CREATE TABLE T24.chungtc
(
  RECID      VARCHAR2(255 BYTE)                 NOT NULL,
  XMLRECORD  SYS.XMLTYPE
)
XMLTYPE XMLRECORD STORE AS SECUREFILE CLOB (
  TABLESPACE  MCREDIT
  ENABLE      STORAGE IN ROW
  CHUNK       8192
  CACHE
  LOGGING
      STORAGE    (
                  INITIAL          104K
                  NEXT             1M
                  MINEXTENTS       1
                  MAXEXTENTS       UNLIMITED
                  PCTINCREASE      0
                  BUFFER_POOL      DEFAULT
                 ))
TABLESPACE MCREDIT
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            INITIAL          64K
            NEXT             1M
            MAXSIZE          UNLIMITED
            MINEXTENTS       1
            MAXEXTENTS       UNLIMITED
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
NOCOMPRESS 
NOCACHE
MONITORING;

----------- read clob
[4/1/2022 3:33 PM] Trang Cong Chung
select /*+parallel(64)*/ max(dbms_lob.getlength(xmltype.getclobval(xmlrecord))) from t24core.FTFBNK_FUND000 ; --5183
select /*+parallel(64)*/ max(dbms_lob.getlength(xmltype.getclobval(xmlrecord))) from t24core.ACFBNK_ACCO019 ;---77444445
select /*+parallel(64)*/ max(dbms_lob.getlength(xmltype.getclobval(xmlrecord))) from t24core.ACFBNK_ACCOUNT ;--258055
select /*+parallel(64)*/ max(dbms_lob.getlength(xmltype.getclobval(xmlrecord))) from t24core.AZFBNK_AZ_A001 ;--3237
select /*+parallel(64)*/ max(dbms_lob.getlength(xmltype.getclobval(xmlrecord))) from t24core.REFBNK_EB_C000 ;--242331
select /*+parallel(64)*/ max(dbms_lob.getlength(xmltype.getclobval(xmlrecord))) from t24core.STFBNK_CUST000 ;--9584
select /*+parallel(64)*/ max(dbms_lob.getlength(xmltype.getclobval(xmlrecord))) from t24core.STF_MB_BANGKE ;--9029


CREATE TABLE T24CORE.STFBNK_CHEQ018
(
  RECID      VARCHAR2(255 BYTE)                 NOT NULL,
  XMLRECORD  SYS.XMLTYPE
)
XMLTYPE XMLRECORD STORE AS CLOB ;
SELECT t.RECID,t.xmlrecord.getclobval() FROM t24core.stFBNK_CHEQ018 t WHERE RECID LIKE '%0000074559512%' ESCAPE '\';


---------- index la
CREATE INDEX T24CORE.IX_F_MB_BV_M000 ON T24CORE.F_MB_BV_M000
(SYS_MAKEXML("SYS_NC00003$"))
INDEXTYPE IS XDB.XMLINDEX
PARAMETERS('PATHS (INCLUDE (/row/c4))');

================= tach truong cuong syncrodis index domain
SELECT RECID FROM T24CORE."V_STFBNK_STAN001" WHERE ( XMLEXISTS('$t[/row/c24/text()=$id]' PASSING "THE_RECORD" as "t",  '571398'   as "id") );
-- index nay se lay tat ca gia tri cua tag c24 : vdu <c24 m=1>1</c24><c24 m=2>2</c24> tao thanh 1 bang c24 co IX_value ={1,2} va recid tuong ung cua row
CREATE INDEX T24CORE.IX_STFBNK_STAN001 ON T24CORE.STFBNK_STAN001
(SYS_MAKEXML("SYS_NC00003$"))
INDEXTYPE IS XDB.XMLINDEX
PARAMETERS('PATHS (INCLUDE (/row/c24))');
--> de an duoc index tren thi cau select nhu duoi se ko an
SELECT RECID,THE_RECORD FROM T24CORE."V_STFBNK_STAN001" WHERE ( XMLEXISTS('$t[/row/c24/text()=$id]' PASSING "THE_RECORD" as "t",  '571398'   as "id") );
--> de an duoc fai dung nhu duoi, vi bang tao ra la c24 chu ko fai la /row/c24. trong do EXTRACT (a.XMLRECORD, '/row/c24') "ORDERING_CUST_24",
SELECT RECID FROM T24CORE."V_STFBNK_STAN001" WHERE ( XMLEXISTS('$t[c24/text()=$id]' PASSING "ORDERING_CUST_24" as "t",  '571398'   as "id") );


================
select /*+ parallel(64)*/ extractValue(XMLRECORD,'/row/c8[position()=1]') "MATURITY_DATE", recid from AZFBNK_AZ_A001 where REGEXP_LIKE(extractValue(XMLRECORD,'/row/c8[position()=1]'), '[^0-9]+');
========================================= tach truong t24
SELECT
    ExtractValue('<a>ccc<b>ddd</b></a>', '/a')            AS val1,
    ExtractValue('<a>ccc<b>ddd</b></a>', '/a/b')          AS val2,
    ExtractValue('<a>ccc<b>ddd</b></a>', '//b')           AS val3,
    ExtractValue('<a>ccc<b>ddd</b></a>', '/b')            AS val4,
    ExtractValue('<a>ccc<b>ddd</b><b>eee</b></a>', '//b') AS val5;
+------+------+------+------+---------+
| val1 | val2 | val3 | val4 | val5    |
+------+------+------+------+---------+
| ccc  | ddd  | ddd  |      | ddd eee |
+------+------+------+------+---------+

--- tach lay truong c1
SELECT XMLCAST (
               XMLQUERY ('$v/row/c1'
                         PASSING XMLRECORD AS "v" RETURNING CONTENT) AS VARCHAR (256))
    FROM t24core.STFBNK_CUST000 t  
---
SELECT 
           a.XMLRECORD "THE_RECORD",
           EXTRACTVALUE (a.XMLRECORD, '/row/c2 [position()=2]') "CUSTOMER_NO",
           EXTRACTVALUE (a.XMLRECORD, '/row/c2 [position()=1]') "CREDIT",
		   EXTRACTVALUE (a.XMLRECORD,'/row/c179 [@m=15]' )
           EXTRACTVALUE (a.XMLRECORD, '/row/@id') "id",
           EXTRACTVALUE (a.XMLRECORD, '/row/@xml:space') "xml:space"
           from t24.chungtc a
---
with example ( xmldata ) as ( SELECT  
    xmltype('<row id="AA17001J21K8-DRINTEREST">  
    <fromDate>20171121</fromDate>  
    <fromDate m="2">20171120</fromDate>  
    <fromDate m="3">20171119</fromDate>  
    <fromDate m="4">20171118</fromDate>  
    <fromDate m="5">20171118</fromDate>  
    <fromDate m="6">20171118</fromDate>  
    <toDate>20171121</toDate>  
    <toDate m="2">20171120</toDate>  
    <toDate m="3">20171119</toDate>  
    <toDate m="4">20171118</toDate>  
    <toDate m="5">20171118</toDate>  
    <toDate m="6">20171118</toDate>  
    <noOfDays>1</noOfDays>  
    <noOfDays m="2">1</noOfDays>  
    <noOfDays m="3">1</noOfDays>  
    <noOfDays m="4">1</noOfDays>  
    <noOfDays m="5">1</noOfDays>  
    <noOfDays m="6">1</noOfDays>  
    <balance>24121.02</balance>  
    <balance m="2">27502.14</balance>  
    <balance m="3">27485.89</balance>  
    <balance m="4">30000</balance>  
    <balance m="4" s="2">1163.94</balance>  
    <balance m="5">30000</balance>  
    <balance m="6">30000</balance>  
    <balance m="6" s="2">1163.94</balance>  
</row>') from dual)   
select   
    row_id,  
    fromdate,  
    todate,  
    noofdays,  
    to_number(balance1,'999999.99') balance1,  
    to_number(balance2,'999999.99') balance2  
from example,  
xmltable(  
    'for $row in /row  
         let $rowid := $row/@id  
         for $fromdate in $row/fromDate  
            let $m        := $fromdate/@m  
            let $todate   := if (exists($m)) then $row/toDate[@m = $m] else $row/toDate[not(@m)]  
            let $noofdays := if (exists($m)) then $row/noOfDays[@m = $m] else $row/noOfDays[not(@m)]  
            let $balance1 := if (exists($m)) then $row/balance[@m = $m and not(@s)] else $row/balance[not(@m)]  
            let $balance2 := if (exists($m)) then $row/balance[@m = $m and @s = "2"] else ""  
                return   
                    <row> {$rowid} { $fromdate } {$todate} {$noofdays} <B1>{$balance1}</B1> <B2>{$balance2}</B2> </row>'  
    passing xmldata  
    columns  
        row_id   varchar2(30) path '@id',  
        fromdate varchar2(8)  path 'fromDate',  
        todate   varchar2(8)  path 'toDate',  
        noofdays number(10)   path 'noOfDays',  
        balance1 varchar2(10) path 'B1/balance',  
        balance2 varchar2(10) path 'B2/balance'  
) 


--
with example(yourdata) as (  
select xmltype(  
    '<row id="123456">  
       <c1>USD</c1>  
       <c2>AMOUNTS</c2>  
       <c2 m="2">AMOUNT1</c2>  
       <c2 m="3">AMOUNT2</c2>  
       <c2 m="4">AMOUNT3</c2>  
       <c2 m="5">AMOUNT4</c2>  
       <c3 m="6" />  
       <c4 m="7" />  
       <c5>50000000</c5>  
       <c5 m="2">2000000</c5>  
       <c5 m="3">15000000</c5>  
       <c5 m="4">2000000</c5>  
       <c5 m="5">538773.07</c5>  
    </row>'  
) from dual)  
select amount,amtval from example,  
    xmltable(  
        'for $r in /row  
            for $c2 in $r/c2  
                let $m2 := $c2/@m  
                let $c5 := $r/c5[@m=$m2]  
                where exists($c5)  
                    return <amt> {$c2} {$c5} </amt>'  
    passing yourdata  
    columns   
        amount varchar2(10) path 'c2',  
        amtval number(10,2) path 'number(c5)'  
    )    

--- khi  co nhieu truong
Select ENAME From chungtc.DEPT_SAMPLE,
XMLTABLE ('/Department/EmployeeList/Ename' Passing FIELD1
COLUMNS ENAME VARCHAR2(32) path '.');	
		   
		<Department deptno="300">
		  <DeptName>Sales</DeptName>
		  <EmployeeList>
			<Ename>Robert</Ename>
			<Ename>Billy</Ename>
		  </EmployeeList>
		</Department>	

/* Formatted on 6/24/2020 4:43:40 PM (QP5 v5.287) */
SET SERVEROUTPUT ON

DECLARE
   v_XMLTYPE_DATA   SYS.XMLTYPE;

   CURSOR c_SAMPLE
   IS
      SELECT * FROM DEPT_SAMPLE;
BEGIN
   FOR REC_IN IN C_SAMPLE
   LOOP
      v_XMLTYPE_DATA := REC_IN.FIELD1;

      DBMS_OUTPUT.PUT_LINE ('------------');

      DBMS_OUTPUT.PUT_LINE (
         UPPER (
            v_XMLTYPE_DATA.EXTRACT ('/Department/DeptName/text()').getStringVal ()));

      DBMS_OUTPUT.PUT_LINE ('------------');

      FOR record_picked
         IN (SELECT ENAME
               FROM XMLTABLE ('/Department/EmployeeList/Ename'
                              PASSING v_XMLTYPE_DATA
                              COLUMNS ENAME VARCHAR2 (32) PATH '.'))
      LOOP
         DBMS_OUTPUT.PUT_LINE (record_picked.ENAME);
      END LOOP;
   END LOOP;
END;
/


SELECT xt.*
FROM   chungtc.xml_tab x,
       XMLTABLE('/employees/employee'
         PASSING x.xml_data
         COLUMNS 
           empno     VARCHAR2(4)  PATH 'empno',
           ename     VARCHAR2(10) PATH 'ename',
           job       VARCHAR2(9)  PATH 'job',
           hiredate  VARCHAR2(11) PATH 'hiredate'
         ) xt;
				<employees>
				  <employee>
					<empno>7369</empno>
					<ename>SMITH</ename>
					<job>CLERK</job>
					<hiredate>17-DEC-1980</hiredate>
				  </employee>
				  <employee>
					<empno>7499</empno>
					<ename>ALLEN</ename>
					<job>SALESMAN</job>
					<hiredate>20-FEB-1981</hiredate>
				 </employee>

===================tao index t24
CREATE UNIQUE INDEX T24.CHUNGTC_IDX_PK ON T24.CHUNGTC
(RECID)
LOGGING
TABLESPACE MCREDITINDEX
PCTFREE    10
INITRANS   2
MAXTRANS   255
STORAGE    (
            INITIAL          64K
            NEXT             1M
            MAXSIZE          UNLIMITED
            MINEXTENTS       1
            MAXEXTENTS       UNLIMITED
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           );

ALTER TABLE T24.chungtc ADD (
  CONSTRAINT CHUNGTC_PK
  PRIMARY KEY
  (RECID)
  USING INDEX T24.CHUNGTC_IDX_PK
  ENABLE VALIDATE);
  
  
 CREATE  INDEX t24.chungtc_c101_idx ON t24.chungtc
 (extractValue(XMLRECORD, '/row/c101')) TABLESPACE MCREDITINDEX;
---ORA-22950: cannot ORDER objects without MAP or ORDER method
CREATE  INDEX chungtc.STFBNK_C179p15_IDX1 ON chungtc.STFBNK_CUST000
    EXTRACTVALUE(XMLRECORD,'/row/c179[position()=15]')
     TABLESPACE MCREDITINDEX ;
=> doi thanh  
  CREATE  INDEX chungtc.STFBNK_C179p15_IDX1 ON chungtc.STFBNK_CUST000
NVL(EXTRACTVALUE(XMLRECORD,'/row/c179[position()=15]'),'0')
 TABLESPACE MCREDITINDEX ;
--- cot ao T24 
alter table EBFBNK_EB_D000 add (
PURGE_DATE varchar2(100) GENERATED ALWAYS AS (XMLCast(XMLQuery('/row/c1[position()=1]' PASSING XMLRECORD RETURNING CONTENT) AS varchar2(100))) VIRTUAL
);
alter table ACFBNK_ACCO020 add (
  CUSTOMER number GENERATED ALWAYS AS (XMLCast(XMLQuery('/row/c1[position()=1]' PASSING XMLRECORD RETURNING CONTENT) AS number)) VIRTUAL
);

CREATE INDEX IX_EBFBNK_EB_D000_PURGE_DATE on EBFBNK_EB_D000(PURGE_DATE,0) TABLESPACE T24INDEXNEW PARALLEL 16;
;
 
 CREATE TABLE T24.interim
(
  RECID      VARCHAR2(255 BYTE)                 NOT NULL,
  XMLRECORD  SYS.XMLTYPE
)
XMLTYPE XMLRECORD STORE AS SECUREFILE CLOB (
  TABLESPACE  MCREDIT
  ENABLE      STORAGE IN ROW
  CHUNK       8192
  CACHE
  LOGGING
      STORAGE    (
                  INITIAL          104K
                  NEXT             1M
                  MINEXTENTS       1
                  MAXEXTENTS       UNLIMITED
                  PCTINCREASE      0
                  BUFFER_POOL      DEFAULT
                 ))
TABLESPACE MCREDIT
PCTUSED    0
PCTFREE    10
INITRANS   1
MAXTRANS   255
STORAGE    (
            INITIAL          64K
            NEXT             1M
            MAXSIZE          UNLIMITED
            MINEXTENTS       1
            MAXEXTENTS       UNLIMITED
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           )
LOGGING 
PARTITION BY HASH (RECID) 
PARTITIONS 64
NOCOMPRESS 
NOCACHE
MONITORING;

EXEC DBMS_REDEFINITION.can_redef_table('T24', 'CHUNGTC');
EXEC DBMS_REDEFINITION.can_redef_table('PUSHMESSAGE', 'MB_PM_MESSAGES',dbms_redefinition.cons_use_rowid);
ALTER SESSION FORCE PARALLEL DML PARALLEL 16;
ALTER SESSION FORCE PARALLEL QUERY PARALLEL 16;
EXEC DBMS_REDEFINITION.start_redef_table('T24', 'CHUNGTC', 'INTERIM'); --Elapsed: 00:02:29.31
EXEC DBMS_REDEFINITION.start_redef_table('PUSHMESSAGE', 'MB_PM_MESSAGES', 'MB_PM_MESSAGES_INTERIM',options_flag=>dbms_redefinition.cons_use_rowid);
EXEC DBMS_REDEFINITION.start_redef_table('T24CORE', 'PDFBNK_PD_B000_NEW', 'PDFBNK_PD_B000_I',col_mapping =>'recid recid, xmlrecord xmlrecord');

EXEC DBMS_REDEFINITION.sync_interim_table('T24', 'CHUNGTC', 'INTERIM'); 
EXEC DBMS_REDEFINITION.sync_interim_table('PUSHMESSAGE', 'MB_PM_MESSAGES', 'MB_PM_MESSAGES_INTERIM');
exec DBMS_REDEFINITION.ABORT_REDEF_TABLE('T24CORE', 'EBFBNK_EB_D000', 'EBFBNK_EB_D000_I');
--Elapsed: 00:00:30.63
CREATE UNIQUE INDEX T24.INTERIM_ID_PK ON T24.INTERIM  
(RECID)
LOGGING
local
TABLESPACE MCREDITINDEX
PCTFREE    10
INITRANS   2
MAXTRANS   255
STORAGE    (
            INITIAL          64K
            NEXT             1M
            MAXSIZE          UNLIMITED
            MINEXTENTS       1
            MAXEXTENTS       UNLIMITED
            PCTINCREASE      0
            BUFFER_POOL      DEFAULT
           );
ALTER TABLE T24.INTERIM ADD (
  CONSTRAINT PK_INTERIM
  PRIMARY KEY
  (RECID)
  USING INDEX T24.INTERIM_ID_PK
  ENABLE VALIDATE);	

--00:08:53.50
CREATE  INDEX t24.INTERIM_c101_idx ON t24.INTERIM
 (extractValue(XMLRECORD, '/row/c101')) TABLESPACE MCREDITINDEX local;
 

  SELECT * FROM T24.CHUNGTC WHERE RECID='10104245965';
    INSERT INTO T24.CHUNGTC SELECT '10104245968',XMLRECORD  FROM T24.CHUNGTC WHERE RECID='10104245965';
	  SELECT * FROM T24.CHUNGTC WHERE RECID='10104245968';
EXEC DBMS_REDEFINITION.finish_redef_table('T24', 'CHUNGTC', 'INTERIM');  --Elapsed: 00:00:06.23

--Elapsed: 00:00:33.68
execute dbms_stats.gather_table_stats(ownname => 'CRM_CUSTOMER', tabname =>'CUSTOMER', estimate_percent =>DBMS_STATS.AUTO_SAMPLE_SIZE, method_opt => 'FOR ALL COLUMNS SIZE skewonly', cascade => TRUE,degree => 32,no_invalidate => false);



0 0,12 * * * sh /home/oracle/scripts/sms/remove_archive.sh 

export today=`date "+%Y%m%d"`

export ORACLE_BASE=/u01/app/oracle
export ORACLE_HOME=/u01/app/oracle/product/19c/dbhome_3
export PATH=$PATH:$ORACLE_HOME/bin:/oracle/OPatch
export ORACLE_UNQNAME=exasmsdb
export ORACLE_SID=smsdb1

rman target / log=/acfs01/log_delete_archive/arc_smsdb_${today}.log <<EOF
run {
        delete  noprompt archivelog until time 'sysdate-5';
        crosscheck archivelog all;
        delete noprompt expired archivelog all;
    }
exit
EOF

============ cluster table temenous==========
-Create cluster
create cluster HASHLOCKS_CLUSTER ( recid number(10,0) )
initrans 12
pctfree 1
hash is recid
single table hashkeys 3702559;
-Create table
create table TAFJ_HASHLOCKS_TMP (recid number(10,0) sort)
cluster HASHLOCKS_CLUSTER(recid);



Copy record from TEMP file to TAFJ_HASHLOCKS table

================ redefinition 12.2
ALTER SESSION force parallel dml  ;
ALTER SESSION force parallel query  ;
BEGIN
sys.dbms_redefinition.redef_table(
uname=>'T24CORE',
tname=>'F_MVMT_EN003',
table_part_tablespace=>'T24DATANEW',
index_tablespace   =>'T24INDEXNEW',
lob_tablespace => 'T24DATANEW',
lob_store_as => 'SECUREFILE'               
);
END;
=========================== exadata chungtc =========================
+ check nhanh db dang dung SmartScan
list activerequest where ioReason="Smart scan" 

+ check nhanh trang thai cua CELL
describe metricdefinition    
list metriccurrent attributes all where objectType = 'CELL'  
list metricdefinition attributes all where objecttype='CELL' 
list metricdefinition cl_cput detail  

+
LIST METRICCURRENT WHERE objectType = 'IORM_DATABASE' AND - 
metricValue != 0 ATTRIBUTES name, metricObjectName, metricValue, collectionTime

+ check database dung nhieu IO nhat https://docs.oracle.com/cd/E80920_01/SAGUG/exadata-storage-server-monitoring.htm#SAGUG20472
https://docs.oracle.com/en/engineered-systems/exadata-database-machine/sagug/exadata-storage-server-monitoring.html#GUID-1DA45F7D-E853-4987-9780-C4EEBA394A1A

LIST METRICDEFINITION ATTRIBUTES NAME,DESCRIPTION WHERE OBJECTTYPE = IORM_DATABASE

LIST METRICCURRENT where name=DB_FL_IO_RQ_SEC LIMIT 100 order by metricValue desc
LIST METRICCURRENT where name=DB_FD_IO_UTIL LIMIT 100 order by metricValue desc

+check database dung nhieu PMEM CACHE
LIST METRICCURRENT where name=DB_PC_BY_ALLOCATED LIMIT 100 order by metricValue desc

LIST METRICCURRENT where name=DB_FD_IO_LOAD LIMIT 100 order by metricValue desc

+Large I/O requests per second for databases
list metriccurrent where name=DB_IO_RQ_LG_SEC  

+Small I/O requests per second for databases
list metriccurrent where name=DB_IO_RQ_SM_SEC

+Small I/O waits per second for databases
list metriccurrent where name=DB_IO_WT_SM_SEC

+Large I/O waits per second for databases
 list metriccurrent where name=DB_IO_WT_LG_SEC
========================= EXADATA command https://satya-dba.blogspot.com/2018/07/cellcli-commands-in-oracle-exadata.html
list activerequest where ioReason="Smart scan"  

and collectiontime > '2022-08-04T09:56:04+07:00'
list diskmap
list cell detail
list griddisk attributes name,cachingpolicy,cachedby


dcli -g /opt/oracle.SupportTools/onecommand/cell_group -l root cellcli -e "list cell attributes flashcachemode"
-------- flash cache hit
SELECT name, VALUE
        FROM v$mystat JOIN v$statname
            USING (statistic#)
       WHERE name IN ('cell flash cache read hits',
                     'physical read requests optimized',
                     'physical read total IO requests');
					 
select decode(name,
 'cell physical IO bytes saved by storage index', 'SI Savings',
 'cell physical IO interconnect bytes returned by smart scan', 'Smart Scan')
as stat_name,
value/1024/1024 as value
from v$mystat s, v$statname n
where s.statistic# = n.statistic#
and n.name in ('cell physical IO bytes saved by storage index',
'cell physical IO interconnect bytes returned by smart scan');					 

----------Smart Flash Logging dcexaceladm01_FLASHLOG FD_02_dcexaceladm01  - giup redo write nhanh
list flashlog  detail
list metriccurrent where objectType='FLASHLOG';		

-----------Smart Flash Cache dcexaceladm01_FLASHCACHE FD_02_dcexaceladm01  - giup DBWR nhanh, tranh free buffer waits
list flashcache detail
list cell attributes flashcachemode detail
list flashcachecontent  
list flashcachecontent where objectnumber=4294967295 detail


----------- PMEM 
list PMEMLOG detail

list PMEMCACHE detail
list PMEMCACHEcontent
list PMEMCACHEcontent attributes dbUniqueName,objectNumber,hitCount,missCount where dbUniqueName='EWALLET' and objectNumber = 81918;
SELECT SUBSTR(OBJECT_NAME, 0 , 10) OBJ_NAME, SUBOBJECT_NAME, DATA_OBJECT_ID 
     FROM dba_objects WHERE DATA_OBJECT_ID=81918;--153775
	 
CellCLI>  list PMEMCACHEcontent attributes dbUniqueName,objectNumber,hitCount,missCount where dbUniqueName='EWALLET' and objectNumber = 130732;
         EWALLET         130732  109     167

CellCLI> list PMEMCACHEcontent attributes dbUniqueName,objectNumber,hitCount,missCount where dbUniqueName='EWALLET' and objectNumber = 127885;
         EWALLET         127885  119     25

----------- list disk

  list physicaldisk attributes name, id,diskType, slotnumber, luns, physicalSize, physicalUseType
list celldisk attributes name,deviceName,diskType,physicalDisk
list GRIDDISK attributes name,asmDiskName,asmDiskSize,diskType,cellDisk

/opt/MegaRAID/storcli/storcli64 -PDList -aALL

----------- IORMPLAN https://docs.oracle.com/en/engineered-systems/exadata-database-machine/sagug/exadata-storage-server-iorm.html#GUID-670860FA-E8E3-4916-8E23-11DE8214EE12
https://support.oracle.com/epmos/faces/DocumentDisplay?_afrLoop=270181741514244&id=1363188.1&_afrWindowMode=0&_adf.ctrl-state=55r4hcgxn_9
----------- category plan (catplan), interdatabase plan (dbplan), or cluster plan (clusterplan)
list iormplan detail
ALTER IORMPLAN dbplan= ((name=ewallet_profile, pmemCacheMin= 500G, type=profile)) 
ALTER IORMPLAN dbplan= ((name=ewalletdr, pmemCacheMin= 500G)) 

cellcli -e alter iormplan inactive
cellcli -e alter iormplan objective='basic',catPlan='',dbplan=''
cellcli -e alter iormplan active
+++ profile
ALTER IORMPLAN DBPLAN=((name=gold, share=10, limit=100, type=profile),  -
(name=silver, share=5, limit=60, type=profile), (name=bronze, share=1, limit=20, -
 type=profile))

+++ LIMIT: attribute specifies the maximum I/O utilization limit as a percentage of the available resources 
+++ SHARE: A share value represents the relative importance of each entity.

ALTER IORMPLAN dbplan=                                                                                       
      ((name=newcdb, share=8, pmemCacheSize= 2G, flashCacheSize=10G),                                        
       (name=finance, share=8, pmemCacheMin= 1G, pmemCacheLimit= 2G, flashCacheLimit=10G, flashCacheMin=2G), 
       (name=dev, share=2, pmemCacheMin= 100M, pmemCacheLimit= 1G, flashCacheLimit=4G, flashCacheMin=1G),    
       (name=test, share=1, limit=10)) 


	   
pmemCacheMin — Specifies the minimum amount of PMEM cache space that is guaranteed for the specified database, even if the blocks are cold. This is a hard limit.

Because pmemCacheMin is a guaranteed reservation, the sum of pmemCacheMin across all directives should be less than the size of the PMEM cache to ensure that each database gets its respective quota.

pmemCacheLimit — Specifies the soft maximum amount of PMEM cache space that is available to the database. If the PMEM cache is not full, a database can exceed the pmemCacheLimit value.
pmemCacheSize — Specifies the hard maximum amount of PMEM cache space that is available to the database. The pmemCacheSize value cannot be exceeded at any time.

However, if you set pmemCacheSize to a value that is lower than the current space occupied by the database, then starting with Oracle Exadata System Software release 20.1.0 excess data is proactively cleared from the cache. Previously, excess data was only removed when overwritten by other data.

pmemCacheSize is not a guaranteed reservation if the sum of the pmemCacheSize across all directives is more than the size of the PMEM cache. In this case, you can also specify pmemCacheMin to define a guaranteed minimum quota.
+++ ON OFF
ALTER IORMPLAN                                                 
         dbplan=((name=prod, share=8, pmemcache=on, pmemlog=on),        
                (name=dw, share=6, pmemcache=on, pmemlog=on),           
                (name=prod_test, share=2, pmemcache=off, pmemlog=off),  
                (name=prod_dev, share=1, pmemcache=off, pmemlog=off),   
                (name=dw_test, share=2, pmemcache=on, pmemlog=off),     
                (name=other, share=1))	 
+++ ALOCATION: an allocation value specifies the resource allocation as a percentage (0-100).
ALTER IORMPLAN                                       
         dbPlan=((name=prod, level=1,allocation=80),          
                 (name=dw, level=2, allocation=80),           
                 (name=prod_test,  level=3, allocation=50),   
                 (name=prod_dev, level=3, allocation=40),     
                 (name=OTHER, level=3, allocation=10))		

--------------------------- METRICDEFINITION
LIST METRICDEFINITION ATTRIBUTES NAME,DESCRIPTION 
cellcli -e "list metrichistory where objectType  like 'FLASHCACHE|CELLDISK|IORM_DATABASE|FLASHLOG|SMARTIO|IORM_CATEGORY|IORM_CONSUMER_GROUP'  and  collectionTime > '2021-11-15T10:00:08+07:00' and collectionTime < '2021-11-15T11:00:08+07:00'" > cell_metric_history.txt
list metrichistory where collectionTime > '2021-11-15T16:00:08+07:00' and collectionTime < '2021-11-15T17:00:10+07:00' and name like 'FC_IO_BY.*' and  metricvalue > 0
list metrichistory where collectionTime > '2021-11-15T16:00:08+07:00' and collectionTime < '2021-11-15T17:00:10+07:00' and name like 'SIO_IO_RD_FC_SEC.*' and  metricvalue > 0
list metriccurrent where name = 'DB_PC_BY_ALLOCATED'and metricObjectName='EWALLET' detail


DB_PC_BY_ALLOCATED


----------
==================== 	 metric_iorm.pl exadata chungtc https://support.oracle.com/epmos/faces/DocumentDisplay?_afrLoop=254998098735745&id=1337265.1&_afrWindowMode=0&_adf.ctrl-state=yaoqjwnsx_4
trong /home/celladmin cua cell storage
./metric_iorm.pl

./metric_iorm.pl "where collectionTime > '2022-08-03T15:00:00+07:00' and collectionTime < '2022-08-03T15:05:00+07:00'" > output.out

./metric_iorm.pl "where ageInMinutes > 120 and ageInMinutes < 180"

-- neu dung tren compute node. "cell_names.dat" la danh sach cell, moi cell 1 dong
dcli -c cel01,cel02 -l celladmin -f metric_iorm.pl
dcli -g cell_names.dat -l celladmin -f metric_iorm.pl 

dcli -c cel01,cel02 -l celladmin "/home/celladmin/metric_iorm.pl > /var/log/oracle/diag/asm/cell/metric_output"
dcli -g cell_names.dat -l celladmin "/home/celladmin/metric_iorm.pl > /var/log/oracle/diag/asm/cell/metric_output"

dcli -g cell_names.dat -l celladmin /home/celladmin/metric_iorm.pl \"where collectionTime \> \'2010-12-15T17:10:51-07:00\' and collectionTime \< \'2010-12-15T17:15:51-07:00\'\" \> /var/log/oracle/diag/asm/cell/metric_output





============== Tuning SQLs to Optimize Smart Scan Performance https://support.oracle.com/epmos/faces/DocumentDisplay?_afrLoop=82940378336573&parent=EXTERNAL_SEARCH&sourceId=HOWTO&id=2608210.1&_afrWindowMode=0&_adf.ctrl-state=v5cvjeswc_758
select sql_id,
delta_execution_count, delta_elapsed_time, delta_cpu_time, delta_user_io_wait_time
delta_physical_read_requests, delta_physical_read_bytes,
delta_io_interconnect_bytes, delta_cell_offload_elig_bytes
from v$sqlstats
order by delta_cpu_time desc;

========================= T24 =======================
VARIABLE lockhandle VARCHAR2(128)
BEGIN
DBMS_LOCK.ALLOCATE_UNIQUE(
lockname => 'MYAPP_MUTEX6',
lockhandle => :lockhandle
);
END;
/

print lockhandle

VARIABLE result NUMBER
BEGIN
:result:=DBMS_LOCK.REQUEST(
lockhandle => :lockhandle,
lockmode => DBMS_LOCK.X_MODE,
timeout => 0,
release_on_commit => TRUE 
);
END;
/

SELECT decode(:result,0,'Success',
1,'Timeout',
2,'Deadlock',
3,'Parameter error',
4,'Already own lock specified by id or lockhandle',
5,'Illegal lock handle') Result
FROM dual;


CREATE OR REPLACE PROCEDURE T24CORE.T24_request_unique_lock( lockId IN INTEGER, lockName IN VARCHAR2, inTransaction IN INTEGER, timeOut IN INTEGER, lockResult OUT INTEGER) AS
	-- Define mylockid as type lockid from table
	mylockid sys.dbms_lock_allocated.lockid%type;
	lockHandle VARCHAR2(128);
BEGIN
	-- Check if lockid supplied
	if ( lockId != 0 ) then
		-- Allocate lock using supplied value
		lockResult := DBMS_LOCK.REQUEST(
			lockId,
			lockmode => DBMS_LOCK.X_MODE, -- eXclusive
			timeout => timeOut, -- wait for specified period
			release_on_commit => FALSE);
	else
		BEGIN
			-- Look up the lock name in the table to see if already allocated and valid
			select lockid into mylockid from sys.dbms_lock_allocated where name = lockName and expiration > sysdate ;
			-- Use returned lock value
			lockHandle := mylockid ;
		EXCEPTION WHEN NO_DATA_FOUND THEN
			-- Name not found, invoke allocate unique
			lockHandle := T24_get_lock_handle(lockName);
		END;
		-- Allocate lock using lock handle
		lockResult := DBMS_LOCK.REQUEST(
			lockHandle,
			lockmode => DBMS_LOCK.X_MODE, -- eXclusive
			timeout => timeOut, -- wait for specified period
			release_on_commit => FALSE);
	end if;
END T24_request_unique_lock;
/

CREATE OR REPLACE PROCEDURE T24CORE.T24_release_unique_lock ( lockId IN INTEGER, lockName IN VARCHAR2, lockResult OUT INTEGER) AS
	-- Define mylockid as type lockid from table
	mylockid sys.dbms_lock_allocated.lockid%type;
	lockHandle VARCHAR2(128);
BEGIN
	-- Check if lockid supplied
	if ( lockId != 0 ) then
		-- Release lock using integer
		lockResult := DBMS_LOCK.RELEASE(lockId);
	else
		BEGIN
			-- Look up the lock name in the table to see if already allocated and valid, place in mylockid
			select lockid into mylockid from sys.dbms_lock_allocated where name = lockName and expiration > sysdate ;
			-- Use returned lock value
			lockHandle := mylockid ;
		EXCEPTION WHEN NO_DATA_FOUND THEN
			-- Name not found, invoke allocate unique
			lockHandle := T24_get_lock_handle(lockName);
		END;
		-- Release lock using handle
		lockResult := DBMS_LOCK.RELEASE(lockHandle);
	end if;
END T24_release_unique_lock;
/

CREATE OR REPLACE FUNCTION T24CORE.T24_get_lock_handle (lock_name IN VARCHAR2) RETURN VARCHAR2 IS
	-- Allocate unique does commit so declare autonomous transacton so T24 unaffected
	PRAGMA AUTONOMOUS_TRANSACTION;
	lock_handle VARCHAR2(128);
BEGIN
	DBMS_LOCK.ALLOCATE_UNIQUE (
	    lockname => lock_name,
	    lockhandle => lock_handle,
	    expiration_secs => 172800); -- 2 days
	RETURN lock_handle;
END T24_get_lock_handle;
/
